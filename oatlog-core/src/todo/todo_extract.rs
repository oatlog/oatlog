// AUTOGENERATED:

#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
struct Math(u32);

#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
enum Eclass {
    Math(Math),
}

#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
enum Enode {
    Add(Eclass, Eclass),
    Mul(Eclass, Eclass),
    Const(i64),
}
impl Enode {
    fn inputs(self) -> Vec<Eclass> {
        match self {
            Enode::Add(e0, e1) => vec![e0, e1],
            Enode::Mul(e0, e1) => vec![e0, e1],
            Enode::Const(e0) => vec![],
        }
    }
}

#[derive(Clone, Hash, Debug, Eq, PartialEq, Ord, PartialOrd)]
enum ExtractExpr {
    Add(Box<ExtractExpr>, Box<ExtractExpr>),
    Mul(Box<ExtractExpr>, Box<ExtractExpr>),
    Const(i64),
}

impl Eclass {
    fn map_extract(self, extract: impl Fn(Eclass) -> Option<Enode> + Copy) -> Option<ExtractExpr> {
        Some(match extract(self)? {
            Enode::Add(e0, e1) => ExtractExpr::Add(
                Box::new(e0.map_extract(extract)?),
                Box::new(e1.map_extract(extract)?),
            ),
            Enode::Mul(e0, e1) => ExtractExpr::Mul(
                Box::new(e0.map_extract(extract)?),
                Box::new(e1.map_extract(extract)?),
            ),
            Enode::Const(e0) => ExtractExpr::Const(e0),
        })
    }
}

// RUNTIME:

//         (Enode <- Eclass)  (Enode <- Eclass)
//                ->                 ->

// NOTE: only include things we want to be potentially extracted in enode_to_eclass
fn extract(
    enode_to_eclass: std::collections::HashMap<Enode, Eclass>,
    root: Eclass,
) -> Option<ExtractExpr> {
    use std::collections::{HashMap, HashSet};
    type Map<K, V> = HashMap<K, V>;
    type Set<K, V> = HashSet<K, V>;

    // how many unprocessed enodes?
    let mut eclass_in_deg: Map<Eclass, usize> = Map::new();

    // how many unprocessed eclasses?
    let mut enode_in_deg: Map<Enode, usize> = Map::new();

    let mut eclass_to_enode: Map<Eclass, Vec<Enode>> = Map::new();

    let mut eclass_readers: Map<Eclass, Vec<Enode>> = Map::new();
    for (&enode, &eclass) in enode_to_eclass.iter() {
        eclass_to_enode.entry(eclass).or_default().push(enode);
        *eclass_in_deg.entry(eclass).or_default() += 1;

        let inputs = enode.inputs();
        for eclass in inputs.iter().copied() {
            eclass_readers.entry(eclass).or_default().push(enode);
        }

        *enode_in_deg.entry(enode).or_default() = inputs.len();
    }

    let mut eclass_queue: Vec<Eclass> = Vec::new();
    let mut enode_queue: Vec<Enode> = Vec::new();

    for (&enode, &eclass) in enode_to_eclass.iter() {
        if enode_in_deg[&enode] == 0 {
            enode_queue.push(enode);
        }
    }

    let mut enode_cost: Map<Enode, i64> = Map::new();
    let mut eclass_cost: Map<Eclass, (i64, Enode)> = Map::new();

    while !(eclass_queue.is_empty() && enode_queue.is_empty()) {
        while let Some(eclass) = eclass_queue.pop() {
            let (cost, enode) = eclass_to_enode[&eclass]
                .iter()
                .copied()
                .map(|enode| (enode_cost[&enode], enode))
                .min()
                .expect("attempted to extract empty eclass?");

            eclass_cost.insert(eclass, (cost, enode));
            for reader_enode in eclass_readers[&eclass].iter().copied() {
                let count = enode_in_deg.entry(reader_enode).or_default();
                *count -= 1;

                if *count == 0 {
                    enode_queue.push(reader_enode);
                }
            }
        }
        while let Some(enode) = enode_queue.pop() {
            // cost of the enode itself.
            let mut cost = 1;

            for input in enode.inputs() {
                let (eclass_cost, _) = eclass_cost[&input];
                cost += eclass_cost;
            }
            enode_cost.insert(enode, cost);

            let eclass = enode_to_eclass[&enode];
            let count = eclass_in_deg.entry(eclass).or_default();
            *count -= 1;
            if *count == 0 {
                eclass_queue.push(eclass);
            }
        }
    }

    root.map_extract(|eclass| eclass_cost.get(&eclass).map(|x| x.1))
}
