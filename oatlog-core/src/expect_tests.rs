use expect_test::expect;

struct Steps {
    strict_egglog_compat: bool,
    code: &'static str,
    expected_hir: Option<expect_test::Expect>,
    expected_tir: Option<expect_test::Expect>,
    expected_lir: Option<expect_test::Expect>,
    expected_codegen: Option<expect_test::Expect>,
}
impl Steps {
    fn check(self) {
        std::env::set_current_dir(concat!(env!("CARGO_MANIFEST_DIR"), "/..")).unwrap();

        // breaks if multiple tests are running.
        /*
        if !tracing::dispatcher::has_been_set() {
            tracing_subscriber::fmt()
                .with_max_level(tracing::Level::TRACE)
                .with_writer(std::io::stdout)
                .init();
        }
        */

        let sexps = crate::frontend::parse_str_to_sexps(self.code).unwrap();
        let config = crate::Configuration {
            egglog_compat: if self.strict_egglog_compat {
                crate::EgglogCompatibility::PostStep
            } else {
                crate::EgglogCompatibility::PostSaturation
            },
            ..Default::default()
        };

        let mut parser = crate::frontend::Parser::new();
        parser.ingest_all(sexps, config).unwrap();
        let hir = parser.emit_hir().optimize(config);
        if let Some(exp) = self.expected_hir {
            exp.assert_eq(&hir.dbg_summary());
        }

        let (_, tir, lir) = crate::query_planning::emit_lir_theory(hir.transform_into_seminaive());
        if let Some(exp) = self.expected_tir {
            exp.assert_eq(&tir.dbg_compact());
        }
        if let Some(exp) = self.expected_lir {
            exp.assert_eq(&lir.dbg_summary());
        }

        let codegen = crate::codegen::codegen(&lir);
        if let Some(exp) = self.expected_codegen {
            let formatted = crate::format_tokens(&codegen);
            exp.assert_eq(&formatted);
        }
    }
}

fn shrink_err(program: expect_test::Expect, expected_err: expect_test::Expect) {
    let mut state = crate::format_program(program.data().trim().to_string());
    let res = crate::try_compile(&state);
    let expected_err = match res {
        Ok(()) => {
            expected_err.assert_eq("DOES NOT ERROR?");
            return;
        }
        Err(err) => {
            expected_err.assert_eq(&err);
            err
        }
    };

    loop {
        let mut progress = false;
        for smaller in crate::shrink(state.clone()) {
            match crate::try_compile(&smaller) {
                Ok(()) => continue,
                Err(err) if err != expected_err => continue,
                Err(_) => {
                    state = smaller;
                    progress = true;
                    eprintln!("\nsmaller:\n\n{state}");
                    break;
                }
            }
        }
        if !progress {
            break;
        }
    }
    program.assert_eq(&state);
}

#[test]
fn shrink_cases() {
    // shrink_err(
    //     expect![[r#"
    //         (datatype Math (Sin Math) (Const i64))
    //         (rewrite (Sin x) (Const -1))"#]],
    //     expect!["PANIC: index out of bounds: the len is 0 but the index is 0"],
    // );
    // shrink_err(
    //     expect![[r#"
    //         (datatype Math (Mul Math Math))
    //         (rule ((= a (Mul zero c))) ())"#]],
    //     expect!["DOES NOT ERROR?"],
    // );

    /*
    shrink_err(
        expect![[r"
             (datatype Math (Sub Math Math) (Const i64))
             (rewrite (Sub a a) (Const 0))
             (rewrite (Sub f g) x)"]],
        expect!["DOES NOT ERROR?"],
    );

    shrink_err(
        expect![[r"
             (sort HerbieType)
             (datatype Math (Sub HerbieType Math Math))
             (rewrite (Sub ty x x) r-zero)
             (rewrite (Sub ty a b) a)"]],
        expect!["DOES NOT ERROR?"],
    );
    */

    // (datatype TypeList
    //     (TCons TypeList TypeList)
    //     (TNil)
    // )
    // (function TypeList-length (TypeList) i64 :no-merge)
    // ( rule ( ( TNil ) ) ( ( set ( TypeList-length ( TNil ) ) 0 ) ) :ruleset type-helpers )
    /*
    shrink_err(
        expect![[r#"
            (datatype TypeList (TNil ))
            (function TypeList-length (TypeList) i64 :no-merge)
            (rule ((TNil )) ((set (TypeList-length (TNil )) 0)))
            "#]],
        expect!["PANIC: must exist some atom for which all input columns are bound [Atom { is_premise: Action, relation: r1, columns: {c0: v0, c1: v1}, entry: None, incl: All }, Atom { is_premise: Action, relation: r2, columns: {c0: v1}, entry: None, incl: All }] {v0}"],
    )
    */
    shrink_err(
        expect![[r#"

(sort Expr)

(sort TypeList)

(datatype BaseType
  (IntT)
  (BoolT)
  (FloatT)
  ; a pointer to a memory region with a particular type
  (PointerT BaseType)
  (StateT))

(datatype Type
  ; a primitive type
  (Base BaseType)
  ; a typed tuple. Use an empty tuple as a unit type.
  ; state edge also has unit type
  (TupleT TypeList)
)


(datatype Assumption
  ; Assume nothing
  (InFunc String)
  ; The term is in a loop with `input` and `pred_output`.
  ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
  ;      input    pred_output
  (InLoop Expr     Expr)
  ; Branch of the switch, and what the predicate is, and what the input is
  (InSwitch i64 Expr Expr)
  ; If the predicate was true, and what the predicate is, and what the input is
  (InIf i64 Expr Expr)
)
(relation FunctionHasType (String Type Type))
(relation HasType (Expr Type))
(function hoisted-loop (Expr Expr) bool :merge (or old new) )
(function tuple-length (Expr) i64 :no-merge)
(constructor Concat (Expr        Expr)       Expr)

(relation boundary-Expr (Expr Expr))
(function Expr-size (Expr) i64 :merge (min old new) )
(constructor DoWhile (Expr    Expr)                   Expr)
(relation ContextOf (Expr Assumption))
(constructor Single (Expr) Expr)
(constructor Subst (Assumption Expr Expr) Expr :unextractable)
(constructor TLConcat (TypeList TypeList) TypeList :unextractable)
(constructor TNil () TypeList)
(constructor TCons (BaseType TypeList) TypeList) ; Head element should never be a tuple
(constructor InExtendedLoop (Expr Expr Expr) Assumption)
(constructor Get   (Expr i64) Expr)
(constructor Arg (Type Assumption) Expr)
(constructor SubTuple (Expr  i64   i64) Expr :unextractable)

(rule((boundary-Expr loop inv) (> (Expr-size inv) 1)
(= loop (DoWhile in pred_out)) (ContextOf loop loop_ctx) (HasType in in_type)
(HasType inv inv_type) (= inv_type(Base base_inv_ty))
(= in_type(TupleT tylist)) (= false (hoisted-loop in pred_out))
(= len(tuple-length in)))
((let new_input(Concat in (Single(Subst loop_ctx in inv))))
(let new_input_type(TupleT(TLConcat tylist(TCons base_inv_ty(TNil)))))
(let assum(InExtendedLoop in pred_out new_input))
(let new_out_branch(Get(Arg new_input_type assum) len))
(let
substed_pred_out(Subst assum(SubTuple(Arg new_input_type assum) 0 len)
pred_out))
(let
inv_in_new_loop(Subst assum(SubTuple(Arg new_input_type assum) 0 len) inv))
(let new_pred_out(Concat substed_pred_out(Single new_out_branch)))
(let new_loop(DoWhile new_input new_pred_out))
(union assum(InLoop new_input new_pred_out))
(union inv_in_new_loop new_out_branch) (let wrapper(SubTuple new_loop 0 len))
(union loop wrapper) (DoWhile in pred_out)
(set(hoisted-loop in pred_out) true)) :ruleset loop-inv-motion)

        "#]],
        expect!["DOES NOT ERROR?"],
    )
}

// TODO erik: This is expressible when we have custom implicit functionality rules.
//
// Premise: (Add a b c)
// Action: (Neg a b), (Neg a c)
//
// Premise: (Add a b b)
// Action: (Neg a b), (Neg a c)

#[test]
fn test_edgecase3() {
    Steps {
        strict_egglog_compat: false,
        code: r"
            (datatype TypeList (TNil ))
            (function TypeList-length (TypeList) i64 :no-merge)
            (rule ((TNil )) ((set (TypeList-length (TNil )) 0)))
            ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, TypeList]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( TNil ) ) ( ( set ( TypeList-length ( TNil ) ) 0 ) ) )",
                        atoms: [
                            Premise { relation: TNil, columns: [v0] },
                            Action { relation: TypeList-length, columns: [v0, v1] },
                            Action { relation: g0, columns: [v1], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: None, ty: t1 },
                            v1: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: TNil { columns: [TypeList], kind: Table, implicit_rules: {n0: [U]} },
                    r1: TypeList-length { columns: [TypeList, i64], kind: Table, implicit_rules: {n0: [_, !]} },
                    r2: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: Some(expect![[r#"
            Trie {
                map: {
                    Primary(r0_New(*v0*)): Trie {
                        map: {},
                    },
                },
            }"#]]),
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, TypeList]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "TNil",
                        param_types: {c0: t1},
                        kind: Table {
                            index_to_info: {ir0: =>0:union},
                        },
                    },
                    r1: RelationData {
                        name: "TypeList-length",
                        param_types: {c0: t1, c1: t0},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:panic},
                        },
                    },
                    r2: RelationData {
                        name: "g0",
                        param_types: {c0: t0},
                        kind: [Global, g0],
                    },
                },
                rule_variables: {
                    [v0, qv0]: t1,
                    [v1, qv1]: t0,
                },
                global_variable_types: {
                    g0: t0,
                },
                rule_tries: [
                    premise: [IterNew, r0(v0)]
                    meta: "( rule ( ( TNil ) ) ( ( set ( TypeList-length ( TNil ) ) 0 ) ) )"
                    actions: [
                        [Action::Entry, r2(v1) on ir_bogus],
                        [Action::Insert, r1(v0, v1)],
                    ],
                ],
                initial: [
                    ComputeGlobal {
                        global_id: g0,
                        compute: Literal(I64(0)),
                    },
                ],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(TypeList);
            #[derive(Debug, Default)]
            struct TNilRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(TypeList, TimeStamp)>,
                fd_index_: runtime::HashMap<(), (TypeList, TimeStamp)>,
                type_list_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for TNilRelation {
                type Row = (TypeList,);
                type Unification = Unification;
                const COST: u32 = 1u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((), (x0, _timestamp))) in
                        self.fd_index_.iter().map(|(k, v)| ((*k), (*v))).enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "t_nil", "type_list", x0).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "t_nil").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "t_nil", {
                        for &(mut x0,) in insertions {
                            match self.fd_index_.entry(()) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y0, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y0;
                                    let changed = changed | (old_val != uf.type_list_.union_mut(&mut x0, y0));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.type_list_.find(x0), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "t_nil", {
                        if self.type_list_num_uprooted_at_latest_retain == uf.type_list_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.type_list_num_uprooted_at_latest_retain = uf.type_list_.num_uprooted();
                        self.fd_index_.retain(|&(), &mut (x0, _timestamp)| {
                            if uf.type_list_.is_root(x0) {
                                true
                            } else {
                                insertions.push((x0,));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "t_nil", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new
                                .extend(self.fd_index_.iter().filter_map(|(&(), &(x0, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0,))
                                    } else {
                                        None
                                    }
                                }));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_
                                    .iter()
                                    .map(|(&(), &(x0, timestamp))| (x0, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0,)| {
                                assert_eq!((x0,), (uf.type_list_.find(x0),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, _timestamp)| {
                                assert_eq!((x0,), (uf.type_list_.find(x0),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self.all.iter().map(|&(x0, _timestamp)| (x0,)).collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.type_list_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl TNilRelation {
                fn iter_all__to_0(&self) -> impl Iterator<Item = (TypeList,)> + use<'_> {
                    self.fd_index_
                        .get(&())
                        .into_iter()
                        .copied()
                        .map(|(x0, _timestamp)| (x0,))
                }
                fn iter_old__to_0(
                    &self,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (TypeList,)> + use<'_> {
                    self.fd_index_
                        .get(&())
                        .into_iter()
                        .copied()
                        .filter_map(move |(x0, timestamp)| (timestamp < latest_timestamp).then_some((x0,)))
                }
                #[allow(unreachable_code)]
                fn entry__to_0(&self, delta: &mut Delta, uf: &mut Unification) -> (TypeList,) {
                    if let Some((x0,)) = self.iter_all__to_0().next() {
                        return (x0,);
                    }
                    let x0 = uf.type_list_.add_eclass();
                    delta.t_nil_.push((x0,));
                    (x0,)
                }
                fn check_(&self) -> bool {
                    self.iter_all__to_0().next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct TypeListLengthRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(TypeList, std::primitive::i64, TimeStamp)>,
                fd_index_0: runtime::HashMap<(TypeList,), (std::primitive::i64, TimeStamp)>,
                type_list_num_uprooted_at_latest_retain: usize,
                i64_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for TypeListLengthRelation {
                type Row = (TypeList, std::primitive::i64);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "type_list_length", "type_list", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "type_list_length", "i64", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "type_list_length").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "type_list_length", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((uf.type_list_.find(x0),)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    panic!("panic merge");
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((x1, latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "type_list_length", {
                        if self.type_list_num_uprooted_at_latest_retain == uf.type_list_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.type_list_num_uprooted_at_latest_retain = uf.type_list_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.type_list_.is_root(x0) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "type_list_length", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (uf.type_list_.find(x0), x1,), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (uf.type_list_.find(x0), x1,), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.type_list_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl TypeListLengthRelation {
                fn iter_all_0_to_1(
                    &self,
                    x0: TypeList,
                ) -> impl Iterator<Item = (std::primitive::i64,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: TypeList,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (std::primitive::i64,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: TypeList,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (std::primitive::i64,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = panic!("entry on value not present in database for a panic-merge implicit rule");
                    delta.type_list_length_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: TypeList) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                t_nil_: Vec<<TNilRelation as Relation>::Row>,
                type_list_length_: Vec<<TypeListLengthRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.t_nil_.is_empty();
                    has_new_inserts |= !self.type_list_length_.is_empty();
                    has_new_inserts
                }
                pub fn insert_t_nil(&mut self, x: <TNilRelation as Relation>::Row) {
                    self.t_nil_.push(x);
                }
                pub fn insert_type_list_length(&mut self, x: <TypeListLengthRelation as Relation>::Row) {
                    self.type_list_length_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub type_list_: UnionFind<TypeList>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.type_list_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.type_list_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                global_i64: GlobalVars<std::primitive::i64>,
                pub t_nil_: TNilRelation,
                pub type_list_length_: TypeListLengthRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory.global_i64.define(0usize, 0i64);
                    theory.canonicalize();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qv0,) in self.t_nil_.iter_new() {
                        #[doc = "( rule ( ( TNil ) ) ( ( set ( TypeList-length ( TNil ) ) 0 ) ) )"]
                        let qv1 = self.global_i64.get(0usize);
                        self.delta.insert_type_list_length((qv0, qv1));
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.t_nil_.emit_graphviz(&mut buf);
                    self.type_list_length_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [
                        ("TNil", self.t_nil_.len()),
                        ("TypeList-length", self.type_list_length_.len()),
                    ]
                    .into_iter()
                    .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [(
                        "TypeList",
                        (self.uf.type_list_.len(), self.uf.type_list_.num_roots()),
                    )]
                    .into_iter()
                    .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.t_nil_.clear_new();
                        self.type_list_length_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.t_nil_.update_begin(
                                &mut self.delta.t_nil_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.type_list_length_.update_begin(
                                &mut self.delta.type_list_length_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |= self.t_nil_.update(
                                    &mut self.delta.t_nil_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |= self.type_list_length_.update(
                                    &mut self.delta.type_list_length_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.t_nil_.update_finalize(
                                &mut self.delta.t_nil_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.type_list_length_.update_finalize(
                                &mut self.delta.type_list_length_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.global_i64.update_finalize();
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.t_nil_.deferred_update();
                    self.type_list_length_.deferred_update();
                }
            }
            impl EclassProvider<TypeList> for Theory {
                fn make(&mut self) -> TypeList {
                    self.uf.type_list_.add_eclass()
                }
                fn find(&mut self, t: TypeList) -> TypeList {
                    self.uf.type_list_.find(t)
                }
                fn union(&mut self, a: TypeList, b: TypeList) {
                    self.uf.type_list_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }.check()
}

#[test]
fn test_primitive_in_premise() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math
                (Const i64)
            )

            (rule (
                (Const a)
                (Const b)
                (Const (+ a b))
            ) (
                (Const (- a b))
            ))

            (rule (
                (Const a)
                (Const b)
                (!= a b)
            ) (
                (Const (- a b))
            ))
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( Const a ) ( Const b ) ( Const ( + a b ) ) ) ( ( Const ( - a b ) ) ) )",
                        atoms: [
                            Premise { relation: +, columns: [a, b, v4], entry: [_, _, !] },
                            Premise { relation: Const, columns: [a, v1] },
                            Premise { relation: Const, columns: [b, v3] },
                            Premise { relation: Const, columns: [v4, v5] },
                            Action { relation: -, columns: [a, b, v6], entry: [_, _, !] },
                            Action { relation: Const, columns: [v6, v7], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: None, ty: t1 },
                            v2: VariableMeta { name: Some("b"), ty: t0 },
                            v3: VariableMeta { name: None, ty: t1 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t1 },
                            v6: VariableMeta { name: None, ty: t0 },
                            v7: VariableMeta { name: None, ty: t1 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rule ( ( Const a ) ( Const b ) ( != a b ) ) ( ( Const ( - a b ) ) ) )",
                        atoms: [
                            Premise { relation: !=, columns: [a, b], entry: [_, _] },
                            Premise { relation: Const, columns: [a, v1] },
                            Premise { relation: Const, columns: [b, v3] },
                            Action { relation: -, columns: [a, b, v4], entry: [_, _, !] },
                            Action { relation: Const, columns: [v4, v5], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: None, ty: t1 },
                            v2: VariableMeta { name: Some("b"), ty: t0 },
                            v3: VariableMeta { name: None, ty: t1 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t1 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: + { columns: [i64, i64, i64], kind: Primitive(i64_add012), implicit_rules: {n0: [_, _, !]} },
                    r1: != { columns: [i64, i64], kind: Primitive(i64_ne01), implicit_rules: {n0: [_, _]} },
                    r2: - { columns: [i64, i64, i64], kind: Primitive(i64_sub012), implicit_rules: {n0: [_, _, !]} },
                    r3: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                },
            }"#]]),
        expected_tir: Some(expect![[r#"
            Trie {
                map: {
                    Primary(r3_New(*v0*, *v1*)): Trie {
                        map: {
                            Primary(r3_All(*v2*, *v3*)): Trie {
                                map: {
                                    Primary(r0_All(v0, v2, *v4*)): Trie {
                                        map: {
                                            Primary(r3_All(v4, *v5*)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                    Primary(r1_All(v0, v2)): Trie {
                                        map: {},
                                    },
                                    Primary(r3_Old(*v8*, *v9*)): Trie {
                                        map: {
                                            Primary(r0_All(v8, v0, v2)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                            Primary(r3_Old(*v8*, *v9*)): Trie {
                                map: {
                                    Primary(r1_All(v8, v0)): Trie {
                                        map: {},
                                    },
                                    Primary(r3_Old(*v18*, *v19*)): Trie {
                                        map: {
                                            Primary(r0_All(v8, v18, v0)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            }"#]]),
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "i64_add012",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Primitive,
                    },
                    r1: RelationData {
                        name: "i64_ne01",
                        param_types: {c0: t0, c1: t0},
                        kind: Primitive,
                    },
                    r2: RelationData {
                        name: "i64_sub012",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Primitive,
                    },
                    r3: RelationData {
                        name: "Const",
                        param_types: {c0: t0, c1: t1},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union, ir1: =>0_1},
                        },
                    },
                },
                rule_variables: {
                    [v0, qa]: t0,
                    [v1, qv1]: t1,
                    [v10, qb_2]: t0,
                    [v11, qv11]: t1,
                    [v12, qv12]: t0,
                    [v13, qv13]: t1,
                    [v14, qv14]: t0,
                    [v15, qv15]: t1,
                    [v16, qa_3]: t0,
                    [v17, qv17]: t1,
                    [v18, qb_3]: t0,
                    [v19, qv19]: t1,
                    [v2, qb]: t0,
                    [v20, qv20]: t0,
                    [v21, qv21]: t1,
                    [v22, qv22]: t0,
                    [v23, qv23]: t1,
                    [v24, qa_4]: t0,
                    [v25, qv25]: t1,
                    [v26, qb_4]: t0,
                    [v27, qv27]: t1,
                    [v28, qv28]: t0,
                    [v29, qv29]: t1,
                    [v3, qv3]: t1,
                    [v30, qa_5]: t0,
                    [v31, qv31]: t1,
                    [v32, qb_5]: t0,
                    [v33, qv33]: t1,
                    [v34, qv34]: t0,
                    [v35, qv35]: t1,
                    [v36, qb_6]: t0,
                    [v37, qa_6]: t0,
                    [v4, qv4]: t0,
                    [v5, qv5]: t1,
                    [v6, qv6]: t0,
                    [v7, qv7]: t1,
                    [v8, qa_2]: t0,
                    [v9, qv9]: t1,
                },
                global_variable_types: {},
                rule_tries: [
                    premise: [IterNew, r3(v0, v1)]
                    then: [
                        premise: [JoinAll, r3(v2, v3), ir1]
                        then: [
                            premise: [JoinAll, r0(v0, v2, v4), ir_bogus]
                            then: [
                                premise: [JoinAll, r3(v4, v5), ir0]
                                meta: "( rule ( ( Const a ) ( Const b ) ( Const ( + a b ) ) ) ( ( Const ( - a b ) ) ) )"
                                actions: [
                                    [Action::Entry, r2(v0, v2, v6) on ir_bogus],
                                    [Action::Entry, r3(v6, v7) on ir0],
                                ],
                            ],
                            premise: [JoinAll, r1(v0, v2), ir_bogus]
                            meta: "( rule ( ( Const a ) ( Const b ) ( != a b ) ) ( ( Const ( - a b ) ) ) )"
                            actions: [
                                [Action::Entry, r2(v0, v2, v28) on ir_bogus],
                                [Action::Entry, r3(v28, v29) on ir0],
                            ],
                            premise: [JoinOld, r3(v8, v9), ir1]
                            then: [
                                premise: [JoinAll, r0(v8, v0, v36), ir_bogus]
                                then: [
                                    premise: [IfEq, v2=v36]
                                    meta: "( rule ( ( Const a ) ( Const b ) ( Const ( + a b ) ) ) ( ( Const ( - a b ) ) ) )"
                                    actions: [
                                        [Action::Entry, r2(v8, v0, v14) on ir_bogus],
                                        [Action::Entry, r3(v14, v15) on ir0],
                                    ],
                                ],
                            ],
                        ],
                        premise: [JoinOld, r3(v8, v9), ir1]
                        then: [
                            premise: [JoinAll, r1(v8, v0), ir_bogus]
                            meta: "( rule ( ( Const a ) ( Const b ) ( != a b ) ) ( ( Const ( - a b ) ) ) )"
                            actions: [
                                [Action::Entry, r2(v8, v0, v34) on ir_bogus],
                                [Action::Entry, r3(v34, v35) on ir0],
                            ],
                            premise: [JoinOld, r3(v18, v19), ir1]
                            then: [
                                premise: [JoinAll, r0(v8, v18, v37), ir_bogus]
                                then: [
                                    premise: [IfEq, v0=v37]
                                    meta: "( rule ( ( Const a ) ( Const b ) ( Const ( + a b ) ) ) ( ( Const ( - a b ) ) ) )"
                                    actions: [
                                        [Action::Entry, r2(v8, v18, v22) on ir_bogus],
                                        [Action::Entry, r3(v22, v23) on ir0],
                                    ],
                                ],
                            ],
                        ],
                    ],
                ],
                initial: [],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            fn i64_add012(a: i64, b: i64) -> impl Iterator<Item = (i64,)> {
                a.checked_add(b).map(|x| (x,)).into_iter()
            }
            fn i64_ne01(a: i64, b: i64) -> impl Iterator<Item = ()> {
                (a != b).then_some(()).into_iter()
            }
            fn i64_sub012(a: i64, b: i64) -> impl Iterator<Item = (i64,)> {
                a.checked_sub(b).map(|x| (x,)).into_iter()
            }
            #[derive(Debug, Default)]
            struct ConstRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(std::primitive::i64, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(std::primitive::i64,), (Math, TimeStamp)>,
                nofd_index_: runtime::IndexedSortedList<(), (std::primitive::i64, Math, TimeStamp)>,
                i64_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ConstRelation {
                type Row = (std::primitive::i64, Math);
                type Unification = Unification;
                const COST: u32 = 4u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "i64", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "const").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "const", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "const", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "const", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                self.all.sort_unstable_by_key(|&(x0, x1, timestamp)| ());
                            });
                            unsafe {
                                self.nofd_index_.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (),
                                    |(x0, x1, timestamp)| (x0, x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl ConstRelation {
                fn iter_all_0_to_1(&self, x0: std::primitive::i64) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.const_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn iter_all__to_0_1(&self) -> impl Iterator<Item = (std::primitive::i64, Math)> + use<'_> {
                    self.nofd_index_
                        .iter(())
                        .map(|(x0, x1, _timestamp)| (x0, x1))
                }
                fn iter_old__to_0_1(
                    &self,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (std::primitive::i64, Math)> + use<'_> {
                    self.nofd_index_
                        .iter(())
                        .filter_map(move |(x0, x1, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x1))
                        })
                }
                fn check_(&self) -> bool {
                    self.iter_all__to_0_1().next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                const_: Vec<<ConstRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.const_.is_empty();
                    has_new_inserts
                }
                pub fn insert_const(&mut self, x: <ConstRelation as Relation>::Row) {
                    self.const_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub const_: ConstRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qa, qv1) in self.const_.iter_new() {
                        for (qb, qv3) in self.const_.iter_all__to_0_1() {
                            for (qv4,) in i64_add012(qa, qb) {
                                for (qv5,) in self.const_.iter_all_0_to_1(qv4) {
                                    #[doc = "( rule ( ( Const a ) ( Const b ) ( Const ( + a b ) ) ) ( ( Const ( - a b ) ) ) )"]
                                    let (qv6,) = i64_sub012(qa, qb).next().unwrap();
                                    let (qv7,) = self.const_.entry_0_to_1(qv6, &mut self.delta, &mut self.uf);
                                }
                            }
                            for () in i64_ne01(qa, qb) {
                                #[doc = "( rule ( ( Const a ) ( Const b ) ( != a b ) ) ( ( Const ( - a b ) ) ) )"]
                                let (qv28,) = i64_sub012(qa, qb).next().unwrap();
                                let (qv29,) = self
                                    .const_
                                    .entry_0_to_1(qv28, &mut self.delta, &mut self.uf);
                            }
                            for (qa_2, qv9) in self.const_.iter_old__to_0_1(self.latest_timestamp) {
                                for (qb_6,) in i64_add012(qa_2, qa) {
                                    if qb == qb_6 {
                                        #[doc = "( rule ( ( Const a ) ( Const b ) ( Const ( + a b ) ) ) ( ( Const ( - a b ) ) ) )"]
                                        let (qv14,) = i64_sub012(qa_2, qa).next().unwrap();
                                        let (qv15,) =
                                            self.const_
                                                .entry_0_to_1(qv14, &mut self.delta, &mut self.uf);
                                    }
                                }
                            }
                        }
                        for (qa_2, qv9) in self.const_.iter_old__to_0_1(self.latest_timestamp) {
                            for () in i64_ne01(qa_2, qa) {
                                #[doc = "( rule ( ( Const a ) ( Const b ) ( != a b ) ) ( ( Const ( - a b ) ) ) )"]
                                let (qv34,) = i64_sub012(qa_2, qa).next().unwrap();
                                let (qv35,) = self
                                    .const_
                                    .entry_0_to_1(qv34, &mut self.delta, &mut self.uf);
                            }
                            for (qb_3, qv19) in self.const_.iter_old__to_0_1(self.latest_timestamp) {
                                for (qa_6,) in i64_add012(qa_2, qb_3) {
                                    if qa == qa_6 {
                                        #[doc = "( rule ( ( Const a ) ( Const b ) ( Const ( + a b ) ) ) ( ( Const ( - a b ) ) ) )"]
                                        let (qv22,) = i64_sub012(qa_2, qb_3).next().unwrap();
                                        let (qv23,) =
                                            self.const_
                                                .entry_0_to_1(qv22, &mut self.delta, &mut self.uf);
                                    }
                                }
                            }
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.const_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Const", self.const_.len())].into_iter().collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.const_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.const_.update_begin(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |= self.const_.update(
                                    &mut self.delta.const_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.const_.update_finalize(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.const_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check()
}

#[test]
fn test_multi_insert_lattice() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math
                (Const i64)
            )
            (function foo (Math) i64 :merge (max old new))

            (rule (
                (= (foo eclass) val)
            ) (
                (set (foo eclass) (+ 1 val))
                (set (foo eclass) (+ 2 val))
            ):name "hard case" )

            (rule (
                (= (Const val) eclass)
            ) (
                (set (foo eclass) (+ 1 val))
                (set (foo eclass) (+ 2 val))
            ):name "easier case" )
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        name: "hard case",
                        src: "( rule ( ( = ( foo eclass ) val ) ) ( ( set ( foo eclass ) ( + 1 val ) ) ( set ( foo eclass ) ( + 2 val ) ) ) :name \"hard case\" )",
                        atoms: [
                            Premise { relation: foo, columns: [eclass, val] },
                            Action { relation: +, columns: [v3, val, v2], entry: [_, _, !] },
                            Action { relation: +, columns: [v5, val, v4], entry: [_, _, !] },
                            Action { relation: foo, columns: [eclass, v2] },
                            Action { relation: foo, columns: [eclass, v4] },
                            Action { relation: g0, columns: [v3], entry: [!] },
                            Action { relation: g1, columns: [v5], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("eclass"), ty: t1 },
                            v1: VariableMeta { name: Some("val"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: None, ty: t0 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        name: "easier case",
                        src: "( rule ( ( = ( Const val ) eclass ) ) ( ( set ( foo eclass ) ( + 1 val ) ) ( set ( foo eclass ) ( + 2 val ) ) ) :name \"easier case\" )",
                        atoms: [
                            Premise { relation: Const, columns: [val, eclass] },
                            Action { relation: +, columns: [v3, val, v2], entry: [_, _, !] },
                            Action { relation: +, columns: [v5, val, v4], entry: [_, _, !] },
                            Action { relation: foo, columns: [eclass, v2] },
                            Action { relation: foo, columns: [eclass, v4] },
                            Action { relation: g0, columns: [v3], entry: [!] },
                            Action { relation: g1, columns: [v5], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("val"), ty: t0 },
                            v1: VariableMeta { name: Some("eclass"), ty: t1 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: None, ty: t0 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: + { columns: [i64, i64, i64], kind: Primitive(i64_add012), implicit_rules: {n0: [_, _, !]} },
                    r1: max { columns: [i64, i64, i64], kind: Primitive(i64_max012), implicit_rules: {n0: [_, _, !]} },
                    r2: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r3: foo { columns: [Math, i64], kind: Table, implicit_rules: {n0: [_, +r1]} },
                    r4: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r5: g1 { columns: [i64], kind: Global(g1), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check()
}

#[test]
fn test_lattice_function() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math
                (Const i64)
            )
            (function lower-bound (Math) i64 :merge (max old new))
            (function upper-bound (Math) i64 :merge (min old new))

            (rule (
                (= eclass (Const val))
            ) (
                (set (lower-bound eclass) val)
                (set (upper-bound eclass) val)
            ))
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = eclass ( Const val ) ) ) ( ( set ( lower-bound eclass ) val ) ( set ( upper-bound eclass ) val ) ) )",
                        atoms: [
                            Premise { relation: Const, columns: [val, eclass] },
                            Action { relation: lower-bound, columns: [eclass, val] },
                            Action { relation: upper-bound, columns: [eclass, val] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("eclass"), ty: t1 },
                            v1: VariableMeta { name: Some("val"), ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: max { columns: [i64, i64, i64], kind: Primitive(i64_max012), implicit_rules: {n0: [_, _, !]} },
                    r1: min { columns: [i64, i64, i64], kind: Primitive(i64_min012), implicit_rules: {n0: [_, _, !]} },
                    r2: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r3: lower-bound { columns: [Math, i64], kind: Table, implicit_rules: {n0: [_, +r0]} },
                    r4: upper-bound { columns: [Math, i64], kind: Table, implicit_rules: {n0: [_, +r1]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check()
}

#[test]
fn test_frontend_function() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math (Const i64) (Add Math Math))

            (function evals-to (Math) i64 :no-merge)

            (rule ((= value (evals-to eclass))) ((union eclass (Const value))))
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = value ( evals-to eclass ) ) ) ( ( union eclass ( Const value ) ) ) )",
                        atoms: [
                            Premise { relation: evals-to, columns: [eclass, value] },
                            Action { relation: Const, columns: [value, eclass], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("value"), ty: t0 },
                            v1: VariableMeta { name: Some("eclass"), ty: t1 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r1: evals-to { columns: [Math, i64], kind: Table, implicit_rules: {n0: [_, !]} },
                },
            }"#]]),
        expected_tir: Some(expect![[r#"
            Trie {
                map: {
                    Primary(r1_New(*v1*, *v0*)): Trie {
                        map: {},
                    },
                },
            }"#]]),
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Const",
                        param_types: {c0: t0, c1: t1},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union},
                        },
                    },
                    r1: RelationData {
                        name: "evals-to",
                        param_types: {c0: t1, c1: t0},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:panic},
                        },
                    },
                },
                rule_variables: {
                    [v0, qvalue]: t0,
                    [v1, qeclass]: t1,
                },
                global_variable_types: {},
                rule_tries: [
                    premise: [IterNew, r1(v1, v0)]
                    meta: "( rule ( ( = value ( evals-to eclass ) ) ) ( ( union eclass ( Const value ) ) ) )"
                    actions: [
                        [Action::Insert, r0(v0, v1)],
                    ],
                ],
                initial: [],
            }"#]]),
        expected_codegen: None,
    }
    .check()
}

#[test]
fn redundant_premise_simplify() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math (Const i64) (Add Math Math))
            (rule
                (
                    (Const 1)
                    (Const 1)
                    (Add (Const 1) (Const 1))
                    (Add (Const 1) (Const 1))
                )
                (
                )
                :name "complicated"
            )
            (rule
                (
                    (= one (Const 1))
                    (= two (Add one one))
                )
                (
                )
                :name "expected simplified"
            )
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        name: "complicated",
                        src: "( rule ( ( Const 1 ) ( Const 1 ) ( Add ( Const 1 ) ( Const 1 ) ) ( Add ( Const 1 ) ( Const 1 ) ) ) ( ) :name \"complicated\" )",
                        atoms: [
                            Premise { relation: Const, columns: [v0, v1] },
                            Premise { relation: Add, columns: [v1, v1, v2] },
                            Premise { relation: g0, columns: [v0] },
                        ],
                        variables: {
                            v0: VariableMeta { name: None, ty: t0 },
                            v1: VariableMeta { name: None, ty: t1 },
                            v2: VariableMeta { name: None, ty: t1 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        name: "expected simplified",
                        src: "( rule ( ( = one ( Const 1 ) ) ( = two ( Add one one ) ) ) ( ) :name \"expected simplified\" )",
                        atoms: [
                            Premise { relation: Const, columns: [v1, one] },
                            Premise { relation: Add, columns: [one, one, two] },
                            Premise { relation: g0, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("one"), ty: t1 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: Some("two"), ty: t1 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r1: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r2: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn redundant_action_simplify() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math (Const i64) (Add Math Math))
            (rule
                (
                    (Const 1)
                    (Const 2)
                    (Add (Const 1) (Const 2))
                    (Add (Const 1) (Const 2))
                    (Add (Const 1) (Const 2))
                )
                (
                    (Const 1)
                    (Const 2)
                    (Add (Const 1) (Const 2))
                )
                :name "complicated"
            )
            (rule
                (
                    (= one (Const 1))
                    (= two (Const 2))
                    (= three (Add one two))
                )
                (
                )
                :name "expected simplified"
            )
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        name: "complicated",
                        src: "( rule ( ( Const 1 ) ( Const 2 ) ( Add ( Const 1 ) ( Const 2 ) ) ( Add ( Const 1 ) ( Const 2 ) ) ( Add ( Const 1 ) ( Const 2 ) ) ) ( ( Const 1 ) ( Const 2 ) ( Add ( Const 1 ) ( Const 2 ) ) ) :name \"complicated\" )",
                        atoms: [
                            Premise { relation: Const, columns: [v0, v1] },
                            Premise { relation: Const, columns: [v2, v3] },
                            Premise { relation: Add, columns: [v1, v3, v4] },
                            Premise { relation: g0, columns: [v0] },
                            Premise { relation: g1, columns: [v2] },
                        ],
                        variables: {
                            v0: VariableMeta { name: None, ty: t0 },
                            v1: VariableMeta { name: None, ty: t1 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: None, ty: t1 },
                            v4: VariableMeta { name: None, ty: t1 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        name: "expected simplified",
                        src: "( rule ( ( = one ( Const 1 ) ) ( = two ( Const 2 ) ) ( = three ( Add one two ) ) ) ( ) :name \"expected simplified\" )",
                        atoms: [
                            Premise { relation: Const, columns: [v1, one] },
                            Premise { relation: Const, columns: [v3, two] },
                            Premise { relation: Add, columns: [one, two, three] },
                            Premise { relation: g0, columns: [v1] },
                            Premise { relation: g1, columns: [v3] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("one"), ty: t1 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: Some("two"), ty: t1 },
                            v3: VariableMeta { name: None, ty: t0 },
                            v4: VariableMeta { name: Some("three"), ty: t1 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r1: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r2: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r3: g1 { columns: [i64], kind: Global(g1), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn weird_premise_equality() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (rule ((= x 1) (= y x) (= z y)) ())
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = x 1 ) ( = y x ) ( = z y ) ) ( ) )",
                        atoms: [
                            Premise { relation: g0, columns: [xyz] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("xyz"), ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn hir_commutative() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math
                (Add Math Math)
            )
            (rule ((= e (Add a b) )) ((union e (Add b a))))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = e ( Add a b ) ) ) ( ( union e ( Add b a ) ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, b, e] },
                            Action { relation: Add, columns: [b, a, e], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("e"), ty: t0 },
                            v1: VariableMeta { name: Some("a"), ty: t0 },
                            v2: VariableMeta { name: Some("b"), ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn hir_distributive() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math
                (Add Math Math)
                (Mul Math Math)
            )
            (rewrite (Mul (Add a b) c) (Add (Mul a c) (Mul b c)))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Mul ( Add a b ) c ) ( Add ( Mul a c ) ( Mul b c ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, b, v2] },
                            Premise { relation: Mul, columns: [v2, c, v4] },
                            Action { relation: Add, columns: [v5, v6, v4], entry: [_, _, U] },
                            Action { relation: Mul, columns: [a, c, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [b, c, v6], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: Some("c"), ty: t0 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t0 },
                            v6: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn hir_userspace_implicit_functionality() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (sort Math)
            (relation Add (Math Math Math))

            (rule ((Add a b c) (Add a b d)) ((union c d)))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( Add a b c ) ( Add a b d ) ) ( ( union c d ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, b, c] },
                            Premise { relation: Add, columns: [a, b, d] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                            v2: VariableMeta { name: Some("c"), ty: t0 },
                            v3: VariableMeta { name: Some("d"), ty: t0 },
                        },
                        unify: [
                            [c, d],
                        ],
                    },
                ],
                relations: {
                    r0: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn hir_global() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math
                (Mul Math Math)
                (Add Math Math)
                (Const i64)
                (Var String)
            )
            (let one 1)
            (rewrite (Const one) (Add (Var "a") (Var "b")))
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, String]: runtime::IString,
                    [t2, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Const one ) ( Add ( Var \"a\" ) ( Var \"b\" ) ) )",
                        atoms: [
                            Premise { relation: Const, columns: [one, v1] },
                            Premise { relation: one, columns: [one] },
                            Action { relation: Add, columns: [v3, v5, v1], entry: [_, _, U] },
                            Action { relation: Var, columns: [v2, v3], entry: [_, U] },
                            Action { relation: Var, columns: [v4, v5], entry: [_, U] },
                            Action { relation: g1, columns: [v2], entry: [!] },
                            Action { relation: g2, columns: [v4], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("one"), ty: t0 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: None, ty: t1 },
                            v3: VariableMeta { name: None, ty: t2 },
                            v4: VariableMeta { name: None, ty: t1 },
                            v5: VariableMeta { name: None, ty: t2 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r2: Var { columns: [String, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r3: one { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r4: g1 { columns: [String], kind: Global(g1), implicit_rules: {n0: [!]} },
                    r5: g2 { columns: [String], kind: Global(g2), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, String]: runtime::IString,
                    [t2, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Add",
                        param_types: {c0: t2, c1: t2, c2: t2},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union},
                        },
                    },
                    r1: RelationData {
                        name: "Const",
                        param_types: {c0: t0, c1: t2},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union},
                        },
                    },
                    r2: RelationData {
                        name: "Var",
                        param_types: {c0: t1, c1: t2},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union},
                        },
                    },
                    r3: RelationData {
                        name: "g0",
                        param_types: {c0: t0},
                        kind: [Global, g0],
                    },
                    r4: RelationData {
                        name: "g1",
                        param_types: {c0: t1},
                        kind: [Global, g1],
                    },
                    r5: RelationData {
                        name: "g2",
                        param_types: {c0: t1},
                        kind: [Global, g2],
                    },
                },
                rule_variables: {
                    [v0, qone]: t0,
                    [v1, qv1]: t2,
                    [v10, qv10]: t1,
                    [v11, qv11]: t2,
                    [v2, qv2]: t1,
                    [v3, qv3]: t2,
                    [v4, qv4]: t1,
                    [v5, qv5]: t2,
                    [v6, qone_2]: t0,
                    [v7, qv7]: t2,
                    [v8, qv8]: t1,
                    [v9, qv9]: t2,
                },
                global_variable_types: {
                    g0: t0,
                    g1: t1,
                    g2: t1,
                },
                rule_tries: [
                    premise: [IterNew, r1(v0, v1)]
                    then: [
                        premise: [SemiJoin, r3(v0), ir_bogus]
                        meta: "( rewrite ( Const one ) ( Add ( Var \"a\" ) ( Var \"b\" ) ) )"
                        actions: [
                            [Action::Entry, r5(v4) on ir_bogus],
                            [Action::Entry, r4(v2) on ir_bogus],
                            [Action::Entry, r2(v4, v5) on ir0],
                            [Action::Entry, r2(v2, v3) on ir0],
                            [Action::Insert, r0(v3, v5, v1)],
                        ],
                    ],
                    premise: [IterNew, r3(v6)]
                    then: [
                        premise: [JoinOld, r1(v6, v7), ir0]
                        meta: "( rewrite ( Const one ) ( Add ( Var \"a\" ) ( Var \"b\" ) ) )"
                        actions: [
                            [Action::Entry, r5(v10) on ir_bogus],
                            [Action::Entry, r4(v8) on ir_bogus],
                            [Action::Entry, r2(v10, v11) on ir0],
                            [Action::Entry, r2(v8, v9) on ir0],
                            [Action::Insert, r0(v9, v11, v7)],
                        ],
                    ],
                ],
                initial: [
                    ComputeGlobal {
                        global_id: g0,
                        compute: Literal(I64(1)),
                    },
                    ComputeGlobal {
                        global_id: g1,
                        compute: Literal(String(IString(0))),
                    },
                    ComputeGlobal {
                        global_id: g2,
                        compute: Literal(String(IString(1))),
                    },
                ],
            }"#]]),
        expected_codegen: None,
    }
    .check();
}

#[test]
fn regression_tir2() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math (Mul Math Math) (Pow Math Math) (Const i64))
            (rewrite (Pow x (Const 2)) (Mul x x))
            (Pow (Const 5) (Const 3))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )",
                        atoms: [
                            Premise { relation: Pow, columns: [x, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g0, columns: [v1] },
                            Action { relation: Mul, columns: [x, x, v3], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t1 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t1 },
                            v3: VariableMeta { name: None, ty: t1 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Pow { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r2: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r3: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r4: g1 { columns: [i64], kind: Global(g1), implicit_rules: {n0: [!]} },
                    r5: g2 { columns: [Math], kind: Global(g2), implicit_rules: {n0: [!]} },
                    r6: g3 { columns: [i64], kind: Global(g3), implicit_rules: {n0: [!]} },
                    r7: g4 { columns: [Math], kind: Global(g4), implicit_rules: {n0: [!]} },
                    r8: g5 { columns: [Math], kind: Global(g5), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Mul",
                        param_types: {c0: t1, c1: t1, c2: t1},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union},
                        },
                    },
                    r1: RelationData {
                        name: "Pow",
                        param_types: {c0: t1, c1: t1, c2: t1},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 1=>0_2},
                        },
                    },
                    r2: RelationData {
                        name: "Const",
                        param_types: {c0: t0, c1: t1},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union (check: {{0, 1}})},
                        },
                    },
                    r3: RelationData {
                        name: "g0",
                        param_types: {c0: t0},
                        kind: [Global, g0],
                    },
                    r4: RelationData {
                        name: "g1",
                        param_types: {c0: t0},
                        kind: [Global, g1],
                    },
                    r5: RelationData {
                        name: "g2",
                        param_types: {c0: t1},
                        kind: [Global, g2],
                    },
                    r6: RelationData {
                        name: "g3",
                        param_types: {c0: t0},
                        kind: [Global, g3],
                    },
                    r7: RelationData {
                        name: "g4",
                        param_types: {c0: t1},
                        kind: [Global, g4],
                    },
                    r8: RelationData {
                        name: "g5",
                        param_types: {c0: t1},
                        kind: [Global, g5],
                    },
                },
                rule_variables: {
                    [v0, qx]: t1,
                    [v1, qv1]: t0,
                    [v10, qv10]: t1,
                    [v11, qv11]: t1,
                    [v2, qv2]: t1,
                    [v3, qv3]: t1,
                    [v4, qx_2]: t1,
                    [v5, qv5]: t0,
                    [v6, qv6]: t1,
                    [v7, qv7]: t1,
                    [v8, qx_3]: t1,
                    [v9, qv9]: t0,
                },
                global_variable_types: {
                    g0: t0,
                    g1: t0,
                    g2: t1,
                    g3: t0,
                    g4: t1,
                    g5: t1,
                },
                rule_tries: [
                    premise: [IterNew, r1(v0, v2, v3)]
                    then: [
                        premise: [JoinAll, r3(v1), ir_bogus]
                        then: [
                            premise: [SemiJoin, r2(v1, v2), ir0]
                            meta: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"
                            actions: [
                                [Action::Insert, r0(v0, v0, v3)],
                            ],
                        ],
                    ],
                    premise: [IterNew, r2(v5, v6)]
                    then: [
                        premise: [SemiJoin, r3(v5), ir_bogus]
                        then: [
                            premise: [JoinOld, r1(v4, v6, v7), ir1]
                            meta: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"
                            actions: [
                                [Action::Insert, r0(v4, v4, v7)],
                            ],
                        ],
                    ],
                    premise: [IterNew, r3(v9)]
                    then: [
                        premise: [JoinOld, r2(v9, v10), ir0]
                        then: [
                            premise: [JoinOld, r1(v8, v10, v11), ir1]
                            meta: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"
                            actions: [
                                [Action::Insert, r0(v8, v8, v11)],
                            ],
                        ],
                    ],
                ],
                initial: [
                    ComputeGlobal {
                        global_id: g0,
                        compute: Literal(I64(2)),
                    },
                    ComputeGlobal {
                        global_id: g1,
                        compute: Literal(I64(5)),
                    },
                    ComputeGlobal {
                        global_id: g2,
                        compute: Compute { relation: r2, args: [g1] },
                    },
                    ComputeGlobal {
                        global_id: g3,
                        compute: Literal(I64(3)),
                    },
                    ComputeGlobal {
                        global_id: g4,
                        compute: Compute { relation: r2, args: [g3] },
                    },
                    ComputeGlobal {
                        global_id: g5,
                        compute: Compute { relation: r1, args: [g2, g4] },
                    },
                ],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct MulRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for MulRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "mul").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "mul", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "mul", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "mul", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl MulRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.mul_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct PowRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for PowRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "pow", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "pow", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "pow", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "pow").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "pow", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "pow", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "pow", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort010::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x1,),
                                    |(x0, x1, x2, timestamp)| (x0, x2, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl PowRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.pow_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_1_to_0_2(&self, x1: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .map(|(x0, x2, _timestamp)| (x0, x2))
                }
                fn iter_old_1_to_0_2(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x2))
                        })
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0_2(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct ConstRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(std::primitive::i64, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(std::primitive::i64,), (Math, TimeStamp)>,
                i64_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ConstRelation {
                type Row = (std::primitive::i64, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "i64", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "const").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "const", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "const", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "const", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl ConstRelation {
                fn iter_all_0_to_1(&self, x0: std::primitive::i64) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.const_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn check_0_1(&self, x0: std::primitive::i64, x1: Math) -> bool {
                    self.iter_all_0_to_1(x0)
                        .next()
                        .is_some_and(|(y1,)| true && x1 == y1)
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                mul_: Vec<<MulRelation as Relation>::Row>,
                pow_: Vec<<PowRelation as Relation>::Row>,
                const_: Vec<<ConstRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.mul_.is_empty();
                    has_new_inserts |= !self.pow_.is_empty();
                    has_new_inserts |= !self.const_.is_empty();
                    has_new_inserts
                }
                pub fn insert_mul(&mut self, x: <MulRelation as Relation>::Row) {
                    self.mul_.push(x);
                }
                pub fn insert_pow(&mut self, x: <PowRelation as Relation>::Row) {
                    self.pow_.push(x);
                }
                pub fn insert_const(&mut self, x: <ConstRelation as Relation>::Row) {
                    self.const_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                global_i64: GlobalVars<std::primitive::i64>,
                global_math: GlobalVars<Math>,
                pub mul_: MulRelation,
                pub pow_: PowRelation,
                pub const_: ConstRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory.global_i64.define(0usize, 2i64);
                    theory.global_i64.define(1usize, 5i64);
                    theory.global_math.define(0usize, {
                        let tmp0 = theory.global_i64.get(1usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_i64.define(2usize, 3i64);
                    theory.global_math.define(1usize, {
                        let tmp0 = theory.global_i64.get(2usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(2usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(1usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_pow((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.canonicalize();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qx, qv2, qv3) in self.pow_.iter_new() {
                        if let qv1 = self.global_i64.get(0usize) {
                            if self.const_.check_0_1(qv1, qv2) {
                                #[doc = "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"]
                                self.delta.insert_mul((qx, qx, qv3));
                            }
                        }
                    }
                    for (qv5, qv6) in self.const_.iter_new() {
                        if qv5 == self.global_i64.get(0usize) {
                            for (qx_2, qv7) in self.pow_.iter_old_1_to_0_2(qv6, self.latest_timestamp) {
                                #[doc = "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"]
                                self.delta.insert_mul((qx_2, qx_2, qv7));
                            }
                        }
                    }
                    if let Some(qv9) = self.global_i64.get_new(0usize) {
                        for (qv10,) in self.const_.iter_old_0_to_1(qv9, self.latest_timestamp) {
                            for (qx_3, qv11) in self.pow_.iter_old_1_to_0_2(qv10, self.latest_timestamp) {
                                #[doc = "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"]
                                self.delta.insert_mul((qx_3, qx_3, qv11));
                            }
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.mul_.emit_graphviz(&mut buf);
                    self.pow_.emit_graphviz(&mut buf);
                    self.const_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [
                        ("Mul", self.mul_.len()),
                        ("Pow", self.pow_.len()),
                        ("Const", self.const_.len()),
                    ]
                    .into_iter()
                    .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.mul_.clear_new();
                        self.pow_.clear_new();
                        self.const_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.mul_
                                .update_begin(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                            self.pow_
                                .update_begin(&mut self.delta.pow_, &mut self.uf, self.latest_timestamp);
                            self.const_.update_begin(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.mul_
                                        .update(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.pow_
                                        .update(&mut self.delta.pow_, &mut self.uf, self.latest_timestamp);
                                progress |= self.const_.update(
                                    &mut self.delta.const_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.mul_.update_finalize(
                                &mut self.delta.mul_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.pow_.update_finalize(
                                &mut self.delta.pow_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.const_.update_finalize(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.global_math.update(&mut self.uf.math_);
                            self.global_i64.update_finalize();
                            self.global_math.update_finalize();
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.mul_.deferred_update();
                    self.pow_.deferred_update();
                    self.const_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn regression_tir1() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math (Sub Math Math) (Const i64))
            (rewrite (Sub a a) (Const 0))
            (rewrite (Sub f g) g)
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Sub a a ) ( Const 0 ) )",
                        atoms: [
                            Premise { relation: Sub, columns: [a, a, v1] },
                            Action { relation: Const, columns: [v2, v1], entry: [_, U] },
                            Action { relation: g0, columns: [v2], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t1 },
                            v1: VariableMeta { name: None, ty: t1 },
                            v2: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Sub f g ) g )",
                        atoms: [
                            Premise { relation: Sub, columns: [f, g, v2] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("f"), ty: t1 },
                            v1: VariableMeta { name: Some("g"), ty: t1 },
                            v2: VariableMeta { name: None, ty: t1 },
                        },
                        unify: [
                            [v2, g],
                        ],
                    },
                ],
                relations: {
                    r0: Sub { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r2: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Sub",
                        param_types: {c0: t1, c1: t1, c2: t1},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union},
                        },
                    },
                    r1: RelationData {
                        name: "Const",
                        param_types: {c0: t0, c1: t1},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union},
                        },
                    },
                    r2: RelationData {
                        name: "g0",
                        param_types: {c0: t0},
                        kind: [Global, g0],
                    },
                },
                rule_variables: {
                    [v0, qa]: t1,
                    [v1, qv1]: t1,
                    [v2, qv2]: t0,
                    [v3, qf]: t1,
                    [v4, qg]: t1,
                    [v5, qv5]: t1,
                    [v6, qa_2]: t1,
                },
                global_variable_types: {
                    g0: t0,
                },
                rule_tries: [
                    premise: [IterNew, r0(v0, v6, v1)]
                    then: [
                        premise: [IfEq, v0=v6]
                        meta: "( rewrite ( Sub a a ) ( Const 0 ) )"
                        actions: [
                            [Action::Entry, r2(v2) on ir_bogus],
                            [Action::Insert, r1(v2, v1)],
                        ],
                    ],
                    premise: [IterNew, r0(v3, v4, v5)]
                    meta: "( rewrite ( Sub f g ) g )"
                    actions: [
                        [Action::Equate, v4=v5],
                    ],
                ],
                initial: [
                    ComputeGlobal {
                        global_id: g0,
                        compute: Literal(I64(0)),
                    },
                ],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct SubRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for SubRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "sub").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "sub", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "sub", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "sub", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl SubRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.sub_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct ConstRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(std::primitive::i64, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(std::primitive::i64,), (Math, TimeStamp)>,
                i64_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ConstRelation {
                type Row = (std::primitive::i64, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "i64", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "const").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "const", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "const", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "const", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl ConstRelation {
                fn iter_all_0_to_1(&self, x0: std::primitive::i64) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.const_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                sub_: Vec<<SubRelation as Relation>::Row>,
                const_: Vec<<ConstRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.sub_.is_empty();
                    has_new_inserts |= !self.const_.is_empty();
                    has_new_inserts
                }
                pub fn insert_sub(&mut self, x: <SubRelation as Relation>::Row) {
                    self.sub_.push(x);
                }
                pub fn insert_const(&mut self, x: <ConstRelation as Relation>::Row) {
                    self.const_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                global_i64: GlobalVars<std::primitive::i64>,
                pub sub_: SubRelation,
                pub const_: ConstRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory.global_i64.define(0usize, 0i64);
                    theory.canonicalize();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qa, qa_2, qv1) in self.sub_.iter_new() {
                        if qa == qa_2 {
                            #[doc = "( rewrite ( Sub a a ) ( Const 0 ) )"]
                            let qv2 = self.global_i64.get(0usize);
                            self.delta.insert_const((qv2, qv1));
                        }
                    }
                    for (qf, qg, qv5) in self.sub_.iter_new() {
                        #[doc = "( rewrite ( Sub f g ) g )"]
                        self.uf.math_.union(qg, qv5);
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.sub_.emit_graphviz(&mut buf);
                    self.const_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Sub", self.sub_.len()), ("Const", self.const_.len())]
                        .into_iter()
                        .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.sub_.clear_new();
                        self.const_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.sub_
                                .update_begin(&mut self.delta.sub_, &mut self.uf, self.latest_timestamp);
                            self.const_.update_begin(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.sub_
                                        .update(&mut self.delta.sub_, &mut self.uf, self.latest_timestamp);
                                progress |= self.const_.update(
                                    &mut self.delta.const_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.sub_.update_finalize(
                                &mut self.delta.sub_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.const_.update_finalize(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.global_i64.update_finalize();
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.sub_.deferred_update();
                    self.const_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn regression_elim_problematic() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math (Mul Math Math) (Zero ))
            (let zero (Zero ))
            (rule ((= a (Mul zero c))) ((union a zero)))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = a ( Mul zero c ) ) ) ( ( union a zero ) ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [zero, c, azero] },
                            Premise { relation: zero, columns: [zero] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("azero"), ty: t0 },
                            v1: VariableMeta { name: Some("zero"), ty: t0 },
                            v2: VariableMeta { name: Some("c"), ty: t0 },
                        },
                        unify: [
                            [azero, zero],
                        ],
                    },
                ],
                relations: {
                    r0: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Zero { columns: [Math], kind: Table, implicit_rules: {n0: [U]} },
                    r2: zero { columns: [Math], kind: Global(g0), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn fuel3_benchmark_hir() {
    Steps {
        strict_egglog_compat: false,
        code: r#"(include "oatlog-bench/input/fuel3_math.egg") (run 100)"#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, String]: runtime::IString,
                    [t2, FuelUnit]: [symbolic],
                    [t3, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Integral fuel ( Sin x ) x ) ( Mul ( Const -1 ) ( Cos x ) ) )",
                        atoms: [
                            Premise { relation: Integral, columns: [fuel, v2, x, v3] },
                            Premise { relation: Sin, columns: [x, v2] },
                            Action { relation: Mul, columns: [v5, v6, v3], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v6, v5, v3] },
                            Action { relation: Cos, columns: [x, v6], entry: [_, U] },
                            Action { relation: Const, columns: [v4, v5], entry: [_, U] },
                            Action { relation: g0, columns: [v4], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: Some("x"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Sub a b ) ( Add a ( Mul ( Const -1 ) b ) ) )",
                        atoms: [
                            Premise { relation: Sub, columns: [a, b, v2] },
                            Action { relation: Add, columns: [a, v5, v2], entry: [_, _, U] },
                            Action { relation: Add, columns: [v5, a, v2] },
                            Action { relation: Mul, columns: [b, v4, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v4, b, v5] },
                            Action { relation: Const, columns: [v3, v4], entry: [_, U] },
                            Action { relation: g0, columns: [v3], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t0 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Diff x ( Cos x ) ) ( Mul ( Const -1 ) ( Sin x ) ) )",
                        atoms: [
                            Premise { relation: Diff, columns: [x, v1, v2] },
                            Premise { relation: Cos, columns: [x, v1] },
                            Action { relation: Mul, columns: [v4, v5, v2], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v5, v4, v2] },
                            Action { relation: Sin, columns: [x, v5], entry: [_, U] },
                            Action { relation: Const, columns: [v3, v4], entry: [_, U] },
                            Action { relation: g0, columns: [v3], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t0 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add a b ) ( Add b a ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, b, v2] },
                            Action { relation: Add, columns: [b, a, v2], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a b ) ( Mul b a ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, b, v2] },
                            Action { relation: Mul, columns: [b, a, v2], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add a ( Add b c ) ) ( Add ( Add a b ) c ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, v3, v4] },
                            Premise { relation: Add, columns: [b, c, v3] },
                            Action { relation: Add, columns: [a, b, v5], entry: [_, _, U] },
                            Action { relation: Add, columns: [b, a, v5] },
                            Action { relation: Add, columns: [c, v5, v4], entry: [_, _, U] },
                            Action { relation: Add, columns: [v5, c, v4] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: Some("c"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Mul b c ) ) ( Mul ( Mul a b ) c ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, v3, v4] },
                            Premise { relation: Mul, columns: [b, c, v3] },
                            Action { relation: Mul, columns: [a, b, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [b, a, v5] },
                            Action { relation: Mul, columns: [c, v5, v4], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v5, c, v4] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: Some("c"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add a ( Const 0 ) ) a )",
                        atoms: [
                            Premise { relation: Add, columns: [a, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g1, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v3, a],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g1, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v3, v2],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Const 1 ) ) a )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g2, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v3, a],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Add b c ) ) ( Add ( Mul a b ) ( Mul a c ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [b, c, v3] },
                            Premise { relation: Mul, columns: [a, v3, v4] },
                            Action { relation: Add, columns: [v5, v6, v4], entry: [_, _, U] },
                            Action { relation: Add, columns: [v6, v5, v4] },
                            Action { relation: Mul, columns: [a, b, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [a, c, v6], entry: [_, _, U] },
                            Action { relation: Mul, columns: [b, a, v5] },
                            Action { relation: Mul, columns: [c, a, v6] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: Some("c"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [v2, v4, v5] },
                            Premise { relation: Mul, columns: [a, b, v2] },
                            Premise { relation: Mul, columns: [a, c, v4] },
                            Action { relation: Add, columns: [b, c, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [c, b, v6] },
                            Action { relation: Mul, columns: [a, v6, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v6, a, v5] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: Some("c"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul ( Pow a b ) ( Pow a c ) ) ( Pow a ( Add b c ) ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [v2, v4, v5] },
                            Premise { relation: Pow, columns: [a, b, v2] },
                            Premise { relation: Pow, columns: [a, c, v4] },
                            Action { relation: Add, columns: [b, c, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [c, b, v6] },
                            Action { relation: Pow, columns: [a, v6, v5], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: Some("c"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Pow x ( Const 1 ) ) x )",
                        atoms: [
                            Premise { relation: Pow, columns: [x, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g2, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v3, x],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )",
                        atoms: [
                            Premise { relation: Pow, columns: [x, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g3, columns: [v1] },
                            Action { relation: Mul, columns: [x, x, v3], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Diff x ( Add a b ) ) ( Add ( Diff x a ) ( Diff x b ) ) )",
                        atoms: [
                            Premise { relation: Diff, columns: [x, v3, v4] },
                            Premise { relation: Add, columns: [a, b, v3] },
                            Action { relation: Diff, columns: [x, a, v5], entry: [_, _, U] },
                            Action { relation: Diff, columns: [x, b, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [v5, v6, v4], entry: [_, _, U] },
                            Action { relation: Add, columns: [v6, v5, v4] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: Some("a"), ty: t3 },
                            v2: VariableMeta { name: Some("b"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Diff x ( Mul a b ) ) ( Add ( Mul a ( Diff x b ) ) ( Mul b ( Diff x a ) ) ) )",
                        atoms: [
                            Premise { relation: Diff, columns: [x, v3, v4] },
                            Premise { relation: Mul, columns: [a, b, v3] },
                            Action { relation: Diff, columns: [x, a, v7], entry: [_, _, U] },
                            Action { relation: Diff, columns: [x, b, v5], entry: [_, _, U] },
                            Action { relation: Add, columns: [v6, v8, v4], entry: [_, _, U] },
                            Action { relation: Add, columns: [v8, v6, v4] },
                            Action { relation: Mul, columns: [a, v5, v6], entry: [_, _, U] },
                            Action { relation: Mul, columns: [b, v7, v8], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v5, a, v6] },
                            Action { relation: Mul, columns: [v7, b, v8] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: Some("a"), ty: t3 },
                            v2: VariableMeta { name: Some("b"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                            v7: VariableMeta { name: None, ty: t3 },
                            v8: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Diff x ( Sin x ) ) ( Cos x ) )",
                        atoms: [
                            Premise { relation: Diff, columns: [x, v1, v2] },
                            Premise { relation: Sin, columns: [x, v1] },
                            Action { relation: Cos, columns: [x, v2], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v3, x, v5] },
                            Premise { relation: Const, columns: [v2, v3] },
                            Premise { relation: g2, columns: [v2] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: Some("x"), ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v5, x],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Cos x ) x ) ( Sin x ) )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v3, x, v4] },
                            Premise { relation: Cos, columns: [x, v3] },
                            Action { relation: Sin, columns: [x, v4], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: Some("x"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Add f g ) x ) ( Add ( Integral fuel f x ) ( Integral fuel g x ) ) )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v4, x, v6] },
                            Premise { relation: Add, columns: [f, g, v4] },
                            Action { relation: Integral, columns: [fuel, f, x, v7], entry: [_, _, _, U] },
                            Action { relation: Integral, columns: [fuel, g, x, v8], entry: [_, _, _, U] },
                            Action { relation: Add, columns: [v7, v8, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [v8, v7, v6] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: Some("f"), ty: t3 },
                            v3: VariableMeta { name: Some("g"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: Some("x"), ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                            v7: VariableMeta { name: None, ty: t3 },
                            v8: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Sub f g ) x ) ( Sub ( Integral fuel f x ) ( Integral fuel g x ) ) )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v4, x, v6] },
                            Premise { relation: Sub, columns: [f, g, v4] },
                            Action { relation: Integral, columns: [fuel, f, x, v7], entry: [_, _, _, U] },
                            Action { relation: Integral, columns: [fuel, g, x, v8], entry: [_, _, _, U] },
                            Action { relation: Sub, columns: [v7, v8, v6], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: Some("f"), ty: t3 },
                            v3: VariableMeta { name: Some("g"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: Some("x"), ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                            v7: VariableMeta { name: None, ty: t3 },
                            v8: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Mul a b ) x ) ( Sub ( Mul a ( Integral fuel b x ) ) ( Integral fuel ( Mul ( Diff x a ) ( Integral fuel b x ) ) x ) ) )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v4, x, v6] },
                            Premise { relation: Mul, columns: [a, b, v4] },
                            Action { relation: Diff, columns: [x, a, v9], entry: [_, _, U] },
                            Action { relation: Integral, columns: [fuel, b, x, v7], entry: [_, _, _, U] },
                            Action { relation: Integral, columns: [fuel, v10, x, v11], entry: [_, _, _, U] },
                            Action { relation: Sub, columns: [v8, v11, v6], entry: [_, _, U] },
                            Action { relation: Mul, columns: [a, v7, v8], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v7, a, v8] },
                            Action { relation: Mul, columns: [v7, v9, v10], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v9, v7, v10] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: Some("a"), ty: t3 },
                            v3: VariableMeta { name: Some("b"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: Some("x"), ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                            v7: VariableMeta { name: None, ty: t3 },
                            v8: VariableMeta { name: None, ty: t3 },
                            v9: VariableMeta { name: None, ty: t3 },
                            v10: VariableMeta { name: None, ty: t3 },
                            v11: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Fuel { columns: [FuelUnit, FuelUnit], kind: Table, implicit_rules: {n0: [_, U]} },
                    r1: ZeroFuel { columns: [FuelUnit], kind: Table, implicit_rules: {n0: [U]} },
                    r2: Diff { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r3: Integral { columns: [FuelUnit, Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, _, U]} },
                    r4: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]}, invariant_permutations: {[0, 1, 2], [1, 0, 2]} },
                    r5: Sub { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r6: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]}, invariant_permutations: {[0, 1, 2], [1, 0, 2]} },
                    r7: Div { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r8: Pow { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r9: Ln { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r10: Sqrt { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r11: Sin { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r12: Cos { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r13: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r14: Var { columns: [String, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r15: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r16: g1 { columns: [i64], kind: Global(g1), implicit_rules: {n0: [!]} },
                    r17: g2 { columns: [i64], kind: Global(g2), implicit_rules: {n0: [!]} },
                    r18: g3 { columns: [i64], kind: Global(g3), implicit_rules: {n0: [!]} },
                    r19: g4 { columns: [FuelUnit], kind: Global(g4), implicit_rules: {n0: [!]} },
                    r20: g5 { columns: [FuelUnit], kind: Global(g5), implicit_rules: {n0: [!]} },
                    r21: g6 { columns: [FuelUnit], kind: Global(g6), implicit_rules: {n0: [!]} },
                    r22: fuel3 { columns: [FuelUnit], kind: Global(g7), implicit_rules: {n0: [!]} },
                    r23: g8 { columns: [String], kind: Global(g8), implicit_rules: {n0: [!]} },
                    r24: g9 { columns: [Math], kind: Global(g9), implicit_rules: {n0: [!]} },
                    r25: g10 { columns: [Math], kind: Global(g10), implicit_rules: {n0: [!]} },
                    r26: g11 { columns: [Math], kind: Global(g11), implicit_rules: {n0: [!]} },
                    r27: g12 { columns: [Math], kind: Global(g12), implicit_rules: {n0: [!]} },
                    r28: g13 { columns: [Math], kind: Global(g13), implicit_rules: {n0: [!]} },
                    r29: g14 { columns: [Math], kind: Global(g14), implicit_rules: {n0: [!]} },
                    r30: g15 { columns: [Math], kind: Global(g15), implicit_rules: {n0: [!]} },
                    r31: g16 { columns: [Math], kind: Global(g16), implicit_rules: {n0: [!]} },
                    r32: g17 { columns: [Math], kind: Global(g17), implicit_rules: {n0: [!]} },
                    r33: g18 { columns: [Math], kind: Global(g18), implicit_rules: {n0: [!]} },
                    r34: g19 { columns: [Math], kind: Global(g19), implicit_rules: {n0: [!]} },
                    r35: g20 { columns: [Math], kind: Global(g20), implicit_rules: {n0: [!]} },
                    r36: g21 { columns: [Math], kind: Global(g21), implicit_rules: {n0: [!]} },
                    r37: g22 { columns: [i64], kind: Global(g22), implicit_rules: {n0: [!]} },
                    r38: g23 { columns: [Math], kind: Global(g23), implicit_rules: {n0: [!]} },
                    r39: g24 { columns: [Math], kind: Global(g24), implicit_rules: {n0: [!]} },
                    r40: g25 { columns: [i64], kind: Global(g25), implicit_rules: {n0: [!]} },
                    r41: g26 { columns: [Math], kind: Global(g26), implicit_rules: {n0: [!]} },
                    r42: g27 { columns: [Math], kind: Global(g27), implicit_rules: {n0: [!]} },
                    r43: g28 { columns: [Math], kind: Global(g28), implicit_rules: {n0: [!]} },
                    r44: g29 { columns: [Math], kind: Global(g29), implicit_rules: {n0: [!]} },
                    r45: g30 { columns: [Math], kind: Global(g30), implicit_rules: {n0: [!]} },
                    r46: g31 { columns: [String], kind: Global(g31), implicit_rules: {n0: [!]} },
                    r47: g32 { columns: [Math], kind: Global(g32), implicit_rules: {n0: [!]} },
                    r48: g33 { columns: [Math], kind: Global(g33), implicit_rules: {n0: [!]} },
                    r49: g34 { columns: [Math], kind: Global(g34), implicit_rules: {n0: [!]} },
                    r50: g35 { columns: [Math], kind: Global(g35), implicit_rules: {n0: [!]} },
                    r51: g36 { columns: [Math], kind: Global(g36), implicit_rules: {n0: [!]} },
                    r52: g37 { columns: [Math], kind: Global(g37), implicit_rules: {n0: [!]} },
                    r53: g38 { columns: [Math], kind: Global(g38), implicit_rules: {n0: [!]} },
                    r54: g39 { columns: [String], kind: Global(g39), implicit_rules: {n0: [!]} },
                    r55: g40 { columns: [Math], kind: Global(g40), implicit_rules: {n0: [!]} },
                    r56: g41 { columns: [Math], kind: Global(g41), implicit_rules: {n0: [!]} },
                    r57: g42 { columns: [Math], kind: Global(g42), implicit_rules: {n0: [!]} },
                    r58: g43 { columns: [Math], kind: Global(g43), implicit_rules: {n0: [!]} },
                    r59: g44 { columns: [Math], kind: Global(g44), implicit_rules: {n0: [!]} },
                    r60: g45 { columns: [Math], kind: Global(g45), implicit_rules: {n0: [!]} },
                    r61: g46 { columns: [Math], kind: Global(g46), implicit_rules: {n0: [!]} },
                    r62: g47 { columns: [Math], kind: Global(g47), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn fixpoint_hir_opt() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math
                (Foo Math)
            )

            (rule (
                (= a (Foo b))
            ) (
                (union a (Foo b))
            ))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = a ( Foo b ) ) ) ( ( union a ( Foo b ) ) ) )",
                        atoms: [
                            Premise { relation: Foo, columns: [b, a] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Foo { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn pathproof_hir() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Proof
              (Trans i64 Proof)
              (Edge_x i64 i64))

            (relation path (i64 i64 Proof))
            (relation edge (i64 i64))

            (edge 2 1)
            (edge 3 2)
            (edge 1 3)

            (rule ((edge x y))  
                  ((path x y (Edge_x x y))))
            (rule ((edge x y) (path y z p))  
                  ((path x z (Trans x p))))

            (rule ((path x y p1) (path x y p2))  
                  ((union p1 p2)))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, ()]: std::primitive::unit,
                    [t1, i64]: std::primitive::i64,
                    [t2, Proof]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( edge x y ) ) ( ( path x y ( Edge_x x y ) ) ) )",
                        atoms: [
                            Premise { relation: edge, columns: [x, y] },
                            Action { relation: Edge_x, columns: [x, y, v2], entry: [_, _, U] },
                            Action { relation: path, columns: [x, y, v2] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t1 },
                            v1: VariableMeta { name: Some("y"), ty: t1 },
                            v2: VariableMeta { name: None, ty: t2 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rule ( ( edge x y ) ( path y z p ) ) ( ( path x z ( Trans x p ) ) ) )",
                        atoms: [
                            Premise { relation: path, columns: [y, z, p] },
                            Premise { relation: edge, columns: [x, y] },
                            Action { relation: Trans, columns: [x, p, v4], entry: [_, _, U] },
                            Action { relation: path, columns: [x, z, v4] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t1 },
                            v1: VariableMeta { name: Some("y"), ty: t1 },
                            v2: VariableMeta { name: Some("z"), ty: t1 },
                            v3: VariableMeta { name: Some("p"), ty: t2 },
                            v4: VariableMeta { name: None, ty: t2 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rule ( ( path x y p1 ) ( path x y p2 ) ) ( ( union p1 p2 ) ) )",
                        atoms: [
                            Premise { relation: path, columns: [x, y, p1] },
                            Premise { relation: path, columns: [x, y, p2] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t1 },
                            v1: VariableMeta { name: Some("y"), ty: t1 },
                            v2: VariableMeta { name: Some("p1"), ty: t2 },
                            v3: VariableMeta { name: Some("p2"), ty: t2 },
                        },
                        unify: [
                            [p1, p2],
                        ],
                    },
                ],
                relations: {
                    r0: Trans { columns: [i64, Proof, Proof], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Edge_x { columns: [i64, i64, Proof], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r2: path { columns: [i64, i64, Proof], kind: Table, implicit_rules: {} },
                    r3: edge { columns: [i64, i64], kind: Table, implicit_rules: {} },
                    r4: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r5: g1 { columns: [i64], kind: Global(g1), implicit_rules: {n0: [!]} },
                    r6: g2 { columns: [()], kind: Global(g2), implicit_rules: {n0: [!]} },
                    r7: g3 { columns: [i64], kind: Global(g3), implicit_rules: {n0: [!]} },
                    r8: g4 { columns: [()], kind: Global(g4), implicit_rules: {n0: [!]} },
                    r9: g5 { columns: [()], kind: Global(g5), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[ignore = "template"]
#[test]
fn codegen_template() {
    Steps {
        strict_egglog_compat: true,
        code: r"
        ",
        expected_hir: Some(expect![[r""]]),
        expected_tir: None,
        expected_lir: Some(expect![[r""]]),
        expected_codegen: Some(expect![[r""]]),
    }
    .check();
}

#[test]
fn codegen_constant_propagation() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math
                (Add Math Math)
                (Mul Math Math)
                (Const i64)
            )
            (rule ((= e (Add (Const a) (Const b)))) ((union e (Const (+ a b)))))
            (rule ((= e (Mul (Const a) (Const b)))) ((union e (Const (* a b)))))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = e ( Add ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( + a b ) ) ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [v2, v4, e] },
                            Premise { relation: Const, columns: [a, v2] },
                            Premise { relation: Const, columns: [b, v4] },
                            Action { relation: +, columns: [a, b, v5], entry: [_, _, !] },
                            Action { relation: Const, columns: [v5, e], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("e"), ty: t1 },
                            v1: VariableMeta { name: Some("a"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t1 },
                            v3: VariableMeta { name: Some("b"), ty: t0 },
                            v4: VariableMeta { name: None, ty: t1 },
                            v5: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rule ( ( = e ( Mul ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( * a b ) ) ) ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [v2, v4, e] },
                            Premise { relation: Const, columns: [a, v2] },
                            Premise { relation: Const, columns: [b, v4] },
                            Action { relation: *, columns: [a, b, v5], entry: [_, _, !] },
                            Action { relation: Const, columns: [v5, e], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("e"), ty: t1 },
                            v1: VariableMeta { name: Some("a"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t1 },
                            v3: VariableMeta { name: Some("b"), ty: t0 },
                            v4: VariableMeta { name: None, ty: t1 },
                            v5: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: + { columns: [i64, i64, i64], kind: Primitive(i64_add012), implicit_rules: {n0: [_, _, !]} },
                    r1: * { columns: [i64, i64, i64], kind: Primitive(i64_mul012), implicit_rules: {n0: [_, _, !]} },
                    r2: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r3: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r4: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "i64_add012",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Primitive,
                    },
                    r1: RelationData {
                        name: "i64_mul012",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Primitive,
                    },
                    r2: RelationData {
                        name: "Add",
                        param_types: {c0: t1, c1: t1, c2: t1},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2, ir2: 1=>0_2},
                        },
                    },
                    r3: RelationData {
                        name: "Mul",
                        param_types: {c0: t1, c1: t1, c2: t1},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2, ir2: 1=>0_2},
                        },
                    },
                    r4: RelationData {
                        name: "Const",
                        param_types: {c0: t0, c1: t1},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union, ir1: 1=>0},
                        },
                    },
                },
                rule_variables: {
                    [v0, qe]: t1,
                    [v1, qa]: t0,
                    [v10, qv10]: t1,
                    [v11, qv11]: t0,
                    [v12, qe_3]: t1,
                    [v13, qa_3]: t0,
                    [v14, qv14]: t1,
                    [v15, qb_3]: t0,
                    [v16, qv16]: t1,
                    [v17, qv17]: t0,
                    [v18, qe_4]: t1,
                    [v19, qa_4]: t0,
                    [v2, qv2]: t1,
                    [v20, qv20]: t1,
                    [v21, qb_4]: t0,
                    [v22, qv22]: t1,
                    [v23, qv23]: t0,
                    [v24, qe_5]: t1,
                    [v25, qa_5]: t0,
                    [v26, qv26]: t1,
                    [v27, qb_5]: t0,
                    [v28, qv28]: t1,
                    [v29, qv29]: t0,
                    [v3, qb]: t0,
                    [v30, qe_6]: t1,
                    [v31, qa_6]: t0,
                    [v32, qv32]: t1,
                    [v33, qb_6]: t0,
                    [v34, qv34]: t1,
                    [v35, qv35]: t0,
                    [v4, qv4]: t1,
                    [v5, qv5]: t0,
                    [v6, qe_2]: t1,
                    [v7, qa_2]: t0,
                    [v8, qv8]: t1,
                    [v9, qb_2]: t0,
                },
                global_variable_types: {},
                rule_tries: [
                    premise: [IterNew, r2(v2, v4, v0)]
                    then: [
                        premise: [SemiJoin, r4(v1, v2), ir1]
                        then: [
                            premise: [JoinAll, r4(v3, v4), ir1]
                            then: [
                                premise: [JoinAll, r4(v1, v2), ir1]
                                meta: "( rule ( ( = e ( Add ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( + a b ) ) ) ) )"
                                actions: [
                                    [Action::Entry, r0(v1, v3, v5) on ir_bogus],
                                    [Action::Insert, r4(v5, v0)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r3(v20, v22, v18)]
                    then: [
                        premise: [SemiJoin, r4(v19, v20), ir1]
                        then: [
                            premise: [JoinAll, r4(v21, v22), ir1]
                            then: [
                                premise: [JoinAll, r4(v19, v20), ir1]
                                meta: "( rule ( ( = e ( Mul ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( * a b ) ) ) ) )"
                                actions: [
                                    [Action::Entry, r1(v19, v21, v23) on ir_bogus],
                                    [Action::Insert, r4(v23, v18)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r4(v7, v8)]
                    then: [
                        premise: [JoinOld, r2(v8, v10, v6), ir1]
                        then: [
                            premise: [JoinAll, r4(v9, v10), ir1]
                            meta: "( rule ( ( = e ( Add ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( + a b ) ) ) ) )"
                            actions: [
                                [Action::Entry, r0(v7, v9, v11) on ir_bogus],
                                [Action::Insert, r4(v11, v6)],
                            ],
                        ],
                        premise: [JoinOld, r2(v14, v8, v12), ir2]
                        then: [
                            premise: [JoinOld, r4(v13, v14), ir1]
                            meta: "( rule ( ( = e ( Add ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( + a b ) ) ) ) )"
                            actions: [
                                [Action::Entry, r0(v13, v7, v17) on ir_bogus],
                                [Action::Insert, r4(v17, v12)],
                            ],
                        ],
                        premise: [JoinOld, r3(v8, v28, v24), ir1]
                        then: [
                            premise: [JoinAll, r4(v27, v28), ir1]
                            meta: "( rule ( ( = e ( Mul ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( * a b ) ) ) ) )"
                            actions: [
                                [Action::Entry, r1(v7, v27, v29) on ir_bogus],
                                [Action::Insert, r4(v29, v24)],
                            ],
                        ],
                        premise: [JoinOld, r3(v32, v8, v30), ir2]
                        then: [
                            premise: [JoinOld, r4(v31, v32), ir1]
                            meta: "( rule ( ( = e ( Mul ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( * a b ) ) ) ) )"
                            actions: [
                                [Action::Entry, r1(v31, v7, v35) on ir_bogus],
                                [Action::Insert, r4(v35, v30)],
                            ],
                        ],
                    ],
                ],
                initial: [],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            fn i64_add012(a: i64, b: i64) -> impl Iterator<Item = (i64,)> {
                a.checked_add(b).map(|x| (x,)).into_iter()
            }
            fn i64_mul012(a: i64, b: i64) -> impl Iterator<Item = (i64,)> {
                a.checked_mul(b).map(|x| (x,)).into_iter()
            }
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 9u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort010::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x1,),
                                    |(x0, x1, x2, timestamp)| (x0, x2, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
                fn iter_all_1_to_0_2(&self, x1: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .map(|(x0, x2, _timestamp)| (x0, x2))
                }
                fn iter_old_1_to_0_2(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x2))
                        })
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0_2(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct MulRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for MulRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 9u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "mul").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "mul", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "mul", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "mul", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort010::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x1,),
                                    |(x0, x1, x2, timestamp)| (x0, x2, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl MulRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.mul_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
                fn iter_all_1_to_0_2(&self, x1: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .map(|(x0, x2, _timestamp)| (x0, x2))
                }
                fn iter_old_1_to_0_2(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x2))
                        })
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0_2(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct ConstRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(std::primitive::i64, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(std::primitive::i64,), (Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (std::primitive::i64, TimeStamp)>,
                i64_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ConstRelation {
                type Row = (std::primitive::i64, Math);
                type Unification = Unification;
                const COST: u32 = 4u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "i64", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "const").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "const", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "const", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "const", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                self.all.sort_unstable_by_key(|&(x0, x1, timestamp)| (x1,));
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x1,),
                                    |(x0, x1, timestamp)| (x0, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl ConstRelation {
                fn iter_all_0_to_1(&self, x0: std::primitive::i64) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.const_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn iter_all_1_to_0(&self, x1: Math) -> impl Iterator<Item = (std::primitive::i64,)> + use<'_> {
                    self.nofd_index_1.iter((x1,)).map(|(x0, _timestamp)| (x0,))
                }
                fn iter_old_1_to_0(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (std::primitive::i64,)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, timestamp)| (timestamp < latest_timestamp).then_some((x0,)))
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                add_: Vec<<AddRelation as Relation>::Row>,
                mul_: Vec<<MulRelation as Relation>::Row>,
                const_: Vec<<ConstRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts |= !self.mul_.is_empty();
                    has_new_inserts |= !self.const_.is_empty();
                    has_new_inserts
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
                pub fn insert_mul(&mut self, x: <MulRelation as Relation>::Row) {
                    self.mul_.push(x);
                }
                pub fn insert_const(&mut self, x: <ConstRelation as Relation>::Row) {
                    self.const_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub add_: AddRelation,
                pub mul_: MulRelation,
                pub const_: ConstRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qv2, qv4, qe) in self.add_.iter_new() {
                        if self.const_.check_1(qv2) {
                            for (qb,) in self.const_.iter_all_1_to_0(qv4) {
                                for (qa,) in self.const_.iter_all_1_to_0(qv2) {
                                    #[doc = "( rule ( ( = e ( Add ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( + a b ) ) ) ) )"]
                                    let (qv5,) = i64_add012(qa, qb).next().unwrap();
                                    self.delta.insert_const((qv5, qe));
                                }
                            }
                        }
                    }
                    for (qv20, qv22, qe_4) in self.mul_.iter_new() {
                        if self.const_.check_1(qv20) {
                            for (qb_4,) in self.const_.iter_all_1_to_0(qv22) {
                                for (qa_4,) in self.const_.iter_all_1_to_0(qv20) {
                                    #[doc = "( rule ( ( = e ( Mul ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( * a b ) ) ) ) )"]
                                    let (qv23,) = i64_mul012(qa_4, qb_4).next().unwrap();
                                    self.delta.insert_const((qv23, qe_4));
                                }
                            }
                        }
                    }
                    for (qa_2, qv8) in self.const_.iter_new() {
                        for (qv10, qe_2) in self.add_.iter_old_0_to_1_2(qv8, self.latest_timestamp) {
                            for (qb_2,) in self.const_.iter_all_1_to_0(qv10) {
                                #[doc = "( rule ( ( = e ( Add ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( + a b ) ) ) ) )"]
                                let (qv11,) = i64_add012(qa_2, qb_2).next().unwrap();
                                self.delta.insert_const((qv11, qe_2));
                            }
                        }
                        for (qv14, qe_3) in self.add_.iter_old_1_to_0_2(qv8, self.latest_timestamp) {
                            for (qa_3,) in self.const_.iter_old_1_to_0(qv14, self.latest_timestamp) {
                                #[doc = "( rule ( ( = e ( Add ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( + a b ) ) ) ) )"]
                                let (qv17,) = i64_add012(qa_3, qa_2).next().unwrap();
                                self.delta.insert_const((qv17, qe_3));
                            }
                        }
                        for (qv28, qe_5) in self.mul_.iter_old_0_to_1_2(qv8, self.latest_timestamp) {
                            for (qb_5,) in self.const_.iter_all_1_to_0(qv28) {
                                #[doc = "( rule ( ( = e ( Mul ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( * a b ) ) ) ) )"]
                                let (qv29,) = i64_mul012(qa_2, qb_5).next().unwrap();
                                self.delta.insert_const((qv29, qe_5));
                            }
                        }
                        for (qv32, qe_6) in self.mul_.iter_old_1_to_0_2(qv8, self.latest_timestamp) {
                            for (qa_6,) in self.const_.iter_old_1_to_0(qv32, self.latest_timestamp) {
                                #[doc = "( rule ( ( = e ( Mul ( Const a ) ( Const b ) ) ) ) ( ( union e ( Const ( * a b ) ) ) ) )"]
                                let (qv35,) = i64_mul012(qa_6, qa_2).next().unwrap();
                                self.delta.insert_const((qv35, qe_6));
                            }
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.add_.emit_graphviz(&mut buf);
                    self.mul_.emit_graphviz(&mut buf);
                    self.const_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [
                        ("Add", self.add_.len()),
                        ("Mul", self.mul_.len()),
                        ("Const", self.const_.len()),
                    ]
                    .into_iter()
                    .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.add_.clear_new();
                        self.mul_.clear_new();
                        self.const_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                            self.mul_
                                .update_begin(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                            self.const_.update_begin(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.mul_
                                        .update(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                                progress |= self.const_.update(
                                    &mut self.delta.const_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.mul_.update_finalize(
                                &mut self.delta.mul_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.const_.update_finalize(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.add_.deferred_update();
                    self.mul_.deferred_update();
                    self.const_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn codegen_commutative() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math
                (Add Math Math)
            )
            (rule ((= e (Add a b) )) ((union e (Add b a))))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = e ( Add a b ) ) ) ( ( union e ( Add b a ) ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, b, e] },
                            Action { relation: Add, columns: [b, a, e], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("e"), ty: t0 },
                            v1: VariableMeta { name: Some("a"), ty: t0 },
                            v2: VariableMeta { name: Some("b"), ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                add_: Vec<<AddRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub add_: AddRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qa, qb, qe) in self.add_.iter_new() {
                        #[doc = "( rule ( ( = e ( Add a b ) ) ) ( ( union e ( Add b a ) ) ) )"]
                        self.delta.insert_add((qb, qa, qe));
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.add_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Add", self.add_.len())].into_iter().collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.add_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.add_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn regression_entry2() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math (Sub Math Math) (Const i64))
            (rewrite (Sub a b) (Const -1))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Sub a b ) ( Const -1 ) )",
                        atoms: [
                            Premise { relation: Sub, columns: [a, b, v2] },
                            Action { relation: Const, columns: [v3, v2], entry: [_, U] },
                            Action { relation: g0, columns: [v3], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t1 },
                            v1: VariableMeta { name: Some("b"), ty: t1 },
                            v2: VariableMeta { name: None, ty: t1 },
                            v3: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Sub { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r2: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Sub",
                        param_types: {c0: t1, c1: t1, c2: t1},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union},
                        },
                    },
                    r1: RelationData {
                        name: "Const",
                        param_types: {c0: t0, c1: t1},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union},
                        },
                    },
                    r2: RelationData {
                        name: "g0",
                        param_types: {c0: t0},
                        kind: [Global, g0],
                    },
                },
                rule_variables: {
                    [v0, qa]: t1,
                    [v1, qb]: t1,
                    [v2, qv2]: t1,
                    [v3, qv3]: t0,
                },
                global_variable_types: {
                    g0: t0,
                },
                rule_tries: [
                    premise: [IterNew, r0(v0, v1, v2)]
                    meta: "( rewrite ( Sub a b ) ( Const -1 ) )"
                    actions: [
                        [Action::Entry, r2(v3) on ir_bogus],
                        [Action::Insert, r1(v3, v2)],
                    ],
                ],
                initial: [
                    ComputeGlobal {
                        global_id: g0,
                        compute: Literal(I64(-1)),
                    },
                ],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct SubRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for SubRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "sub").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "sub", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "sub", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "sub", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl SubRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.sub_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct ConstRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(std::primitive::i64, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(std::primitive::i64,), (Math, TimeStamp)>,
                i64_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ConstRelation {
                type Row = (std::primitive::i64, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "i64", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "const").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "const", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "const", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "const", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl ConstRelation {
                fn iter_all_0_to_1(&self, x0: std::primitive::i64) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.const_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                sub_: Vec<<SubRelation as Relation>::Row>,
                const_: Vec<<ConstRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.sub_.is_empty();
                    has_new_inserts |= !self.const_.is_empty();
                    has_new_inserts
                }
                pub fn insert_sub(&mut self, x: <SubRelation as Relation>::Row) {
                    self.sub_.push(x);
                }
                pub fn insert_const(&mut self, x: <ConstRelation as Relation>::Row) {
                    self.const_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                global_i64: GlobalVars<std::primitive::i64>,
                pub sub_: SubRelation,
                pub const_: ConstRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory.global_i64.define(0usize, -1i64);
                    theory.canonicalize();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qa, qb, qv2) in self.sub_.iter_new() {
                        #[doc = "( rewrite ( Sub a b ) ( Const -1 ) )"]
                        let qv3 = self.global_i64.get(0usize);
                        self.delta.insert_const((qv3, qv2));
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.sub_.emit_graphviz(&mut buf);
                    self.const_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Sub", self.sub_.len()), ("Const", self.const_.len())]
                        .into_iter()
                        .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.sub_.clear_new();
                        self.const_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.sub_
                                .update_begin(&mut self.delta.sub_, &mut self.uf, self.latest_timestamp);
                            self.const_.update_begin(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.sub_
                                        .update(&mut self.delta.sub_, &mut self.uf, self.latest_timestamp);
                                progress |= self.const_.update(
                                    &mut self.delta.const_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.sub_.update_finalize(
                                &mut self.delta.sub_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.const_.update_finalize(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.global_i64.update_finalize();
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.sub_.deferred_update();
                    self.const_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn regression_entry() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math (Integral Math Math) (Add Math Math))
            (rewrite (Add f g) (Add (Integral f f) g))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Add f g ) ( Add ( Integral f f ) g ) )",
                        atoms: [
                            Premise { relation: Add, columns: [f, g, v2] },
                            Action { relation: Integral, columns: [f, f, v3], entry: [_, _, U] },
                            Action { relation: Add, columns: [v3, g, v2], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("f"), ty: t0 },
                            v1: VariableMeta { name: Some("g"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Integral { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Integral",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union},
                        },
                    },
                    r1: RelationData {
                        name: "Add",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union},
                        },
                    },
                },
                rule_variables: {
                    [v0, qf]: t0,
                    [v1, qg]: t0,
                    [v2, qv2]: t0,
                    [v3, qv3]: t0,
                },
                global_variable_types: {},
                rule_tries: [
                    premise: [IterNew, r1(v0, v1, v2)]
                    meta: "( rewrite ( Add f g ) ( Add ( Integral f f ) g ) )"
                    actions: [
                        [Action::Entry, r0(v0, v0, v3) on ir0],
                        [Action::Insert, r1(v3, v1, v2)],
                    ],
                ],
                initial: [],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct IntegralRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for IntegralRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "integral", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "integral", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "integral", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "integral").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "integral", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "integral", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "integral", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl IntegralRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.integral_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                integral_: Vec<<IntegralRelation as Relation>::Row>,
                add_: Vec<<AddRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.integral_.is_empty();
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts
                }
                pub fn insert_integral(&mut self, x: <IntegralRelation as Relation>::Row) {
                    self.integral_.push(x);
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub integral_: IntegralRelation,
                pub add_: AddRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qf, qg, qv2) in self.add_.iter_new() {
                        #[doc = "( rewrite ( Add f g ) ( Add ( Integral f f ) g ) )"]
                        let (qv3,) = self
                            .integral_
                            .entry_0_1_to_2(qf, qf, &mut self.delta, &mut self.uf);
                        self.delta.insert_add((qv3, qg, qv2));
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.integral_.emit_graphviz(&mut buf);
                    self.add_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Integral", self.integral_.len()), ("Add", self.add_.len())]
                        .into_iter()
                        .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.integral_.clear_new();
                        self.add_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.integral_.update_begin(
                                &mut self.delta.integral_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |= self.integral_.update(
                                    &mut self.delta.integral_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.integral_.update_finalize(
                                &mut self.delta.integral_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.integral_.deferred_update();
                    self.add_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn test_bind_variable_multiple_times() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Foo
                (Same Foo Foo)
            )
            (rewrite (Same x x) x)
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Foo]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Same x x ) x )",
                        atoms: [
                            Premise { relation: Same, columns: [x, x, v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t0 },
                            v1: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [
                            [v1, x],
                        ],
                    },
                ],
                relations: {
                    r0: Same { columns: [Foo, Foo, Foo], kind: Table, implicit_rules: {n0: [_, _, U]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, Foo]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Same",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union},
                        },
                    },
                },
                rule_variables: {
                    [v0, qx]: t0,
                    [v1, qv1]: t0,
                    [v2, qx_2]: t0,
                },
                global_variable_types: {},
                rule_tries: [
                    premise: [IterNew, r0(v0, v2, v1)]
                    then: [
                        premise: [IfEq, v0=v2]
                        meta: "( rewrite ( Same x x ) x )"
                        actions: [
                            [Action::Equate, v0=v1],
                        ],
                    ],
                ],
                initial: [],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Foo);
            #[derive(Debug, Default)]
            struct SameRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Foo, Foo, Foo, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Foo, Foo), (Foo, TimeStamp)>,
                foo_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for SameRelation {
                type Row = (Foo, Foo, Foo);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "same", "foo", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "same", "foo", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "same", "foo", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "same").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "same", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.foo_.find(x0), uf.foo_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.foo_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.foo_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "same", {
                        if self.foo_num_uprooted_at_latest_retain == uf.foo_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.foo_num_uprooted_at_latest_retain = uf.foo_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.foo_.is_root(x0) & uf.foo_.is_root(x1) & uf.foo_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "same", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.foo_.find(x0), uf.foo_.find(x1), uf.foo_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.foo_.find(x0), uf.foo_.find(x1), uf.foo_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.foo_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl SameRelation {
                fn iter_all_0_1_to_2(&self, x0: Foo, x1: Foo) -> impl Iterator<Item = (Foo,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Foo,
                    x1: Foo,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Foo,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(&self, x0: Foo, x1: Foo, delta: &mut Delta, uf: &mut Unification) -> (Foo,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.foo_.add_eclass();
                    delta.same_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Foo, x1: Foo) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                same_: Vec<<SameRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.same_.is_empty();
                    has_new_inserts
                }
                pub fn insert_same(&mut self, x: <SameRelation as Relation>::Row) {
                    self.same_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub foo_: UnionFind<Foo>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.foo_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.foo_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub same_: SameRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qx, qx_2, qv1) in self.same_.iter_new() {
                        if qx == qx_2 {
                            #[doc = "( rewrite ( Same x x ) x )"]
                            self.uf.foo_.union(qx, qv1);
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.same_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Same", self.same_.len())].into_iter().collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Foo", (self.uf.foo_.len(), self.uf.foo_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.same_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.same_
                                .update_begin(&mut self.delta.same_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |= self.same_.update(
                                    &mut self.delta.same_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.same_.update_finalize(
                                &mut self.delta.same_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.same_.deferred_update();
                }
            }
            impl EclassProvider<Foo> for Theory {
                fn make(&mut self) -> Foo {
                    self.uf.foo_.add_eclass()
                }
                fn find(&mut self, t: Foo) -> Foo {
                    self.uf.foo_.find(t)
                }
                fn union(&mut self, a: Foo, b: Foo) {
                    self.uf.foo_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn test_negative_i64_tokens() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math
                (Mul Math Math)
                (Add Math Math)
                (Sub Math Math)
                (Const i64)
            )
            (let neg_two (Const -2))
            (rewrite (Const -1) (Const -1))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Const -1 ) ( Const -1 ) )",
                        atoms: [
                            Premise { relation: Const, columns: [v0, v1] },
                            Premise { relation: g2, columns: [v0] },
                        ],
                        variables: {
                            v0: VariableMeta { name: None, ty: t0 },
                            v1: VariableMeta { name: None, ty: t1 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r1: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r2: neg_two { columns: [Math], kind: Global(g1), implicit_rules: {n0: [!]} },
                    r3: g2 { columns: [i64], kind: Global(g2), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: None,
    }
    .check();
}

#[test]
fn codegen_variable_reuse_bug() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math (Add Math Math) (Zero))
            (let zero (Zero))

            (rule ((= zero (Add zero x))) ((union x (Zero))))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( = zero ( Add zero x ) ) ) ( ( union x ( Zero ) ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [zerozero, x, zerozero] },
                            Premise { relation: zero, columns: [zerozero] },
                            Action { relation: Zero, columns: [x], entry: [U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("zerozero"), ty: t0 },
                            v1: VariableMeta { name: Some("x"), ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Zero { columns: [Math], kind: Table, implicit_rules: {n0: [U]} },
                    r2: zero { columns: [Math], kind: Global(g0), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Add",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0_2=>1},
                        },
                    },
                    r1: RelationData {
                        name: "Zero",
                        param_types: {c0: t0},
                        kind: Table {
                            index_to_info: {ir0: =>0:union},
                        },
                    },
                    r2: RelationData {
                        name: "g0",
                        param_types: {c0: t0},
                        kind: [Global, g0],
                    },
                },
                rule_variables: {
                    [v0, qzerozero]: t0,
                    [v1, qx]: t0,
                    [v2, qzerozero_2]: t0,
                    [v3, qx_2]: t0,
                    [v4, qzerozero_3]: t0,
                },
                global_variable_types: {
                    g0: t0,
                },
                rule_tries: [
                    premise: [IterNew, r0(v0, v1, v4)]
                    then: [
                        premise: [IfEq, v0=v4]
                        then: [
                            premise: [SemiJoin, r2(v0), ir_bogus]
                            meta: "( rule ( ( = zero ( Add zero x ) ) ) ( ( union x ( Zero ) ) ) )"
                            actions: [
                                [Action::Insert, r1(v1)],
                            ],
                        ],
                    ],
                    premise: [IterNew, r2(v2)]
                    then: [
                        premise: [JoinOld, r0(v2, v3, v2), ir1]
                        meta: "( rule ( ( = zero ( Add zero x ) ) ) ( ( union x ( Zero ) ) ) )"
                        actions: [
                            [Action::Insert, r1(v3)],
                        ],
                    ],
                ],
                initial: [
                    ComputeGlobal {
                        global_id: g0,
                        compute: Compute { relation: r1, args: [] },
                    },
                ],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0_2: runtime::IndexedSortedList<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort101::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0, x2),
                                    |(x0, x1, x2, timestamp)| (x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_2_to_1(&self, x0: Math, x2: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_2_to_1(
                    &self,
                    x0: Math,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                fn check_0_2(&self, x0: Math, x2: Math) -> bool {
                    self.iter_all_0_2_to_1(x0, x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct ZeroRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, TimeStamp)>,
                fd_index_: runtime::HashMap<(), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ZeroRelation {
                type Row = (Math,);
                type Unification = Unification;
                const COST: u32 = 1u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((), (x0, _timestamp))) in
                        self.fd_index_.iter().map(|(k, v)| ((*k), (*v))).enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "zero", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "zero").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "zero", {
                        for &(mut x0,) in insertions {
                            match self.fd_index_.entry(()) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y0, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y0;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x0, y0));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x0), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "zero", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_.retain(|&(), &mut (x0, _timestamp)| {
                            if uf.math_.is_root(x0) {
                                true
                            } else {
                                insertions.push((x0,));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "zero", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new
                                .extend(self.fd_index_.iter().filter_map(|(&(), &(x0, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0,))
                                    } else {
                                        None
                                    }
                                }));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_
                                    .iter()
                                    .map(|(&(), &(x0, timestamp))| (x0, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0,)| {
                                assert_eq!((x0,), (uf.math_.find(x0),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, _timestamp)| {
                                assert_eq!((x0,), (uf.math_.find(x0),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self.all.iter().map(|&(x0, _timestamp)| (x0,)).collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl ZeroRelation {
                fn iter_all__to_0(&self) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_
                        .get(&())
                        .into_iter()
                        .copied()
                        .map(|(x0, _timestamp)| (x0,))
                }
                fn iter_old__to_0(
                    &self,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_
                        .get(&())
                        .into_iter()
                        .copied()
                        .filter_map(move |(x0, timestamp)| (timestamp < latest_timestamp).then_some((x0,)))
                }
                #[allow(unreachable_code)]
                fn entry__to_0(&self, delta: &mut Delta, uf: &mut Unification) -> (Math,) {
                    if let Some((x0,)) = self.iter_all__to_0().next() {
                        return (x0,);
                    }
                    let x0 = uf.math_.add_eclass();
                    delta.zero_.push((x0,));
                    (x0,)
                }
                fn check_(&self) -> bool {
                    self.iter_all__to_0().next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                add_: Vec<<AddRelation as Relation>::Row>,
                zero_: Vec<<ZeroRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts |= !self.zero_.is_empty();
                    has_new_inserts
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
                pub fn insert_zero(&mut self, x: <ZeroRelation as Relation>::Row) {
                    self.zero_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                global_math: GlobalVars<Math>,
                pub add_: AddRelation,
                pub zero_: ZeroRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory.global_math.define(0usize, {
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_zero((tmp_res,));
                        tmp_res
                    });
                    theory.canonicalize();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qzerozero, qx, qzerozero_3) in self.add_.iter_new() {
                        if qzerozero == qzerozero_3 {
                            if qzerozero == self.global_math.get(0usize) {
                                #[doc = "( rule ( ( = zero ( Add zero x ) ) ) ( ( union x ( Zero ) ) ) )"]
                                self.delta.insert_zero((qx,));
                            }
                        }
                    }
                    if let Some(qzerozero_2) = self.global_math.get_new(0usize) {
                        for (qx_2,) in
                            self.add_
                                .iter_old_0_2_to_1(qzerozero_2, qzerozero_2, self.latest_timestamp)
                        {
                            #[doc = "( rule ( ( = zero ( Add zero x ) ) ) ( ( union x ( Zero ) ) ) )"]
                            self.delta.insert_zero((qx_2,));
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.add_.emit_graphviz(&mut buf);
                    self.zero_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Add", self.add_.len()), ("Zero", self.zero_.len())]
                        .into_iter()
                        .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.add_.clear_new();
                        self.zero_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                            self.zero_
                                .update_begin(&mut self.delta.zero_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                progress |= self.zero_.update(
                                    &mut self.delta.zero_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.zero_.update_finalize(
                                &mut self.delta.zero_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.global_math.update(&mut self.uf.math_);
                            self.global_math.update_finalize();
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.add_.deferred_update();
                    self.zero_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn initial_exprs() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math (Add Math Math) (Mul Math Math) (Const i64) (Var String))

            (Add (Const 2) (Const 3))

            (Mul (Var "x") (Var "y"))
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, String]: runtime::IString,
                    [t2, Math]: [symbolic],
                },
                symbolic_rules: [],
                relations: {
                    r0: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r2: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r3: Var { columns: [String, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r4: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r5: g1 { columns: [Math], kind: Global(g1), implicit_rules: {n0: [!]} },
                    r6: g2 { columns: [i64], kind: Global(g2), implicit_rules: {n0: [!]} },
                    r7: g3 { columns: [Math], kind: Global(g3), implicit_rules: {n0: [!]} },
                    r8: g4 { columns: [Math], kind: Global(g4), implicit_rules: {n0: [!]} },
                    r9: g5 { columns: [String], kind: Global(g5), implicit_rules: {n0: [!]} },
                    r10: g6 { columns: [Math], kind: Global(g6), implicit_rules: {n0: [!]} },
                    r11: g7 { columns: [String], kind: Global(g7), implicit_rules: {n0: [!]} },
                    r12: g8 { columns: [Math], kind: Global(g8), implicit_rules: {n0: [!]} },
                    r13: g9 { columns: [Math], kind: Global(g9), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct MulRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for MulRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "mul").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "mul", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "mul", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "mul", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl MulRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.mul_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct ConstRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(std::primitive::i64, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(std::primitive::i64,), (Math, TimeStamp)>,
                i64_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ConstRelation {
                type Row = (std::primitive::i64, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "i64", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "const").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "const", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "const", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "const", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl ConstRelation {
                fn iter_all_0_to_1(&self, x0: std::primitive::i64) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.const_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct VarRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(runtime::IString, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(runtime::IString,), (Math, TimeStamp)>,
                string_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for VarRelation {
                type Row = (runtime::IString, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "var", "string", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "var", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "var").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "var", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "var", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "var", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl VarRelation {
                fn iter_all_0_to_1(&self, x0: runtime::IString) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: runtime::IString,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: runtime::IString,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.var_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: runtime::IString) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                add_: Vec<<AddRelation as Relation>::Row>,
                mul_: Vec<<MulRelation as Relation>::Row>,
                const_: Vec<<ConstRelation as Relation>::Row>,
                var_: Vec<<VarRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts |= !self.mul_.is_empty();
                    has_new_inserts |= !self.const_.is_empty();
                    has_new_inserts |= !self.var_.is_empty();
                    has_new_inserts
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
                pub fn insert_mul(&mut self, x: <MulRelation as Relation>::Row) {
                    self.mul_.push(x);
                }
                pub fn insert_const(&mut self, x: <ConstRelation as Relation>::Row) {
                    self.const_.push(x);
                }
                pub fn insert_var(&mut self, x: <VarRelation as Relation>::Row) {
                    self.var_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                global_i64: GlobalVars<std::primitive::i64>,
                global_string: GlobalVars<runtime::IString>,
                global_math: GlobalVars<Math>,
                pub add_: AddRelation,
                pub mul_: MulRelation,
                pub const_: ConstRelation,
                pub var_: VarRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory.global_i64.define(0usize, 2i64);
                    theory.global_math.define(0usize, {
                        let tmp0 = theory.global_i64.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_i64.define(1usize, 3i64);
                    theory.global_math.define(1usize, {
                        let tmp0 = theory.global_i64.get(1usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(2usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(1usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_add((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_string.define(0usize, IString(0u32));
                    theory.global_math.define(3usize, {
                        let tmp0 = theory.global_string.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_var((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_string.define(1usize, IString(1u32));
                    theory.global_math.define(4usize, {
                        let tmp0 = theory.global_string.get(1usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_var((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(5usize, {
                        let tmp0 = theory.global_math.get(3usize);
                        let tmp1 = theory.global_math.get(4usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_mul((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.canonicalize();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {}
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.add_.emit_graphviz(&mut buf);
                    self.mul_.emit_graphviz(&mut buf);
                    self.const_.emit_graphviz(&mut buf);
                    self.var_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [
                        ("Add", self.add_.len()),
                        ("Mul", self.mul_.len()),
                        ("Const", self.const_.len()),
                        ("Var", self.var_.len()),
                    ]
                    .into_iter()
                    .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.add_.clear_new();
                        self.mul_.clear_new();
                        self.const_.clear_new();
                        self.var_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                            self.mul_
                                .update_begin(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                            self.const_.update_begin(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.var_
                                .update_begin(&mut self.delta.var_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.mul_
                                        .update(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                                progress |= self.const_.update(
                                    &mut self.delta.const_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |=
                                    self.var_
                                        .update(&mut self.delta.var_, &mut self.uf, self.latest_timestamp);
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.mul_.update_finalize(
                                &mut self.delta.mul_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.const_.update_finalize(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.var_.update_finalize(
                                &mut self.delta.var_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.global_math.update(&mut self.uf.math_);
                            self.global_i64.update_finalize();
                            self.global_string.update_finalize();
                            self.global_math.update_finalize();
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.add_.deferred_update();
                    self.mul_.deferred_update();
                    self.const_.deferred_update();
                    self.var_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }.check();
}

#[test]
#[ignore = "set not implemented yet"]
fn codegen_panic_merge() {
    Steps {
        strict_egglog_compat: true,
        // (let x (f))
        //
        // (function g () i64 :no-merge)
        // (fail (let y (g)))
        code: r"
            (function f () i64 :no-merge)
            (set (f) 0)
        ",
        expected_hir: Some(expect![[r#"
            Theory "":

            f(i64)

        "#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            decl_row ! (Row1 < T0 first > () (0) () (T0) fc = (0) (T0));
            #[derive(Debug, Default)]
            struct FRelation {
                new: Vec<<Self as Relation>::Row>,
                all_index_0: IndexImpl<Row1<std::primitive::i64>>,
            }
            impl Relation for FRelation {
                type Row = (std::primitive::i64,);
            }
            impl FRelation {
                const COST: u32 = 1u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl Iterator<Item = <Self as Relation>::Row> + use<'_> {
                    self.new.iter().copied()
                }
                fn iter1_0(&self, x0: std::primitive::i64) -> impl Iterator<Item = ()> + use<'_> {
                    self.all_index_0.range((x0,)..=(x0,)).map(|(x0,)| ())
                }
                fn check1_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter1_0(x0).next().is_some()
                }
                fn update(&mut self, uprooted: &Uprooted, uf: &mut Unification, delta: &mut Delta) {
                    let mut inserts = take(&mut delta.f_relation_delta);
                    let orig_inserts = inserts.len();
                    inserts[orig_inserts..].sort_unstable();
                    runtime::dedup_suffix(&mut inserts, orig_inserts);
                    self.all_index_0.delete_many(&mut inserts[orig_inserts..]);
                    inserts
                        .iter_mut()
                        .enumerate()
                        .for_each(|(i, old @ &mut (x0,))| {});
                    self.all_index_0
                        .insert_many(&mut inserts, |mut old, mut new| {
                            let (x0,) = old.value_mut();
                            let (y0,) = new.value_mut();
                            panic!("panicking merge action")
                        });
                    self.new.extend_from_slice(&inserts);
                }
                fn update_finalize(&mut self, uf: &mut Unification) {
                    self.new.sort_unstable();
                    self.new.dedup();
                    self.new.retain(|(x0,)| true);
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, (x0,)) in self.all_index_0.iter().enumerate() {
                        write!(buf, "{}{i} -> {}{};", "f", "i64", x0).unwrap();
                    }
                }
                fn len(&self) -> usize {
                    self.all_index_0.len()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                f_relation_delta: Vec<<FRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    let mut has_new = false;
                    has_new |= !self.f_relation_delta.is_empty();
                    has_new
                }
                pub fn insert_f(&mut self, x: <FRelation as Relation>::Row) {
                    self.f_relation_delta.push(x);
                }
            }
            #[derive(Default, Debug)]
            struct GlobalVariables {
                new: bool,
            }
            impl GlobalVariables {
                fn initialize(&mut self, delta: &mut Delta, uf: &mut Unification) {
                    self.new = true;
                }
            }
            #[derive(Debug, Default)]
            struct Uprooted {}
            impl Uprooted {
                fn take_dirt(&mut self, uf: &mut Unification) {}
            }
            #[derive(Debug, Default)]
            struct Unification {}
            impl Unification {
                fn has_new(&mut self) -> bool {
                    let mut has_new = false;
                    has_new
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub delta: Delta,
                pub uf: Unification,
                uprooted: Uprooted,
                global_variables: GlobalVariables,
                f_relation: FRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                        .global_variables
                        .initialize(&mut theory.delta, &mut theory.uf);
                    theory.clear_transient();
                    theory.global_variables.new = true;
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    [
                        {
                            let start = std::time::Instant::now();
                            self.apply_rules();
                            start.elapsed()
                        },
                        {
                            let start = std::time::Instant::now();
                            self.clear_transient();
                            start.elapsed()
                        },
                    ]
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {}
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {");
                    self.f_relation.emit_graphviz(&mut buf);
                    buf.push_str("}");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    [self.f_relation.len()].into_iter().sum::<usize>()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("f", self.f_relation.len())].into_iter().collect()
                }
                #[inline(never)]
                pub fn clear_transient(&mut self) {
                    self.global_variables.new = false;
                    self.f_relation.clear_new();
                    loop {
                        self.uprooted.take_dirt(&mut self.uf);
                        self.f_relation
                            .update(&self.uprooted, &mut self.uf, &mut self.delta);
                        if !(self.uf.has_new() || self.delta.has_new()) {
                            break;
                        }
                    }
                    self.f_relation.update_finalize(&mut self.uf);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn codegen_bug1() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (sort T0)
            (sort T1)
            (sort T2)
            (relation Foo (T0 T1 T2))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {},
                symbolic_rules: [],
                relations: {},
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            #[derive(Debug, Default)]
            pub struct Delta {}
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts
                }
            }
            #[derive(Debug, Default)]
            struct Unification {}
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret
                }
                fn reset_num_uprooted(&mut self) {}
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {}
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [].into_iter().collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [].into_iter().collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {});
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {}
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn initial() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math
                (Const i64)
            )
            (run 42)
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {},
                symbolic_rules: [],
                relations: {},
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            #[derive(Debug, Default)]
            pub struct Delta {}
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts
                }
            }
            #[derive(Debug, Default)]
            struct Unification {}
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret
                }
                fn reset_num_uprooted(&mut self) {}
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    for _ in 0..42u64 {
                        theory.step();
                    }
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {}
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [].into_iter().collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [].into_iter().collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {});
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {}
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn test_primitives_simple() {
    Steps {
        strict_egglog_compat: true,
        code: r#"
            (datatype Math
                (Mul Math Math)
                (Add Math Math)
                (Const i64)
                (Var String)
            )

            (let two (Const 2))
            (let one 1)
            (rewrite (Const one) (Add (Var "q") (Var "q")))
            (rewrite (Const 2) (Add (Var "z") (Var "z")))
            (rewrite (Var "x") (Var "y"))

            (rewrite (Mul a (Const 0)) (Const 0))
        "#,
        expected_hir :Some( expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, String]: runtime::IString,
                    [t2, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Const one ) ( Add ( Var \"q\" ) ( Var \"q\" ) ) )",
                        atoms: [
                            Premise { relation: Const, columns: [one, v1] },
                            Premise { relation: one, columns: [one] },
                            Action { relation: Add, columns: [v3, v3, v1], entry: [_, _, U] },
                            Action { relation: Var, columns: [v2, v3], entry: [_, U] },
                            Action { relation: g3, columns: [v2], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("one"), ty: t0 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: None, ty: t1 },
                            v3: VariableMeta { name: None, ty: t2 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Const 2 ) ( Add ( Var \"z\" ) ( Var \"z\" ) ) )",
                        atoms: [
                            Premise { relation: Const, columns: [v0, v1] },
                            Premise { relation: g0, columns: [v0] },
                            Action { relation: Add, columns: [v3, v3, v1], entry: [_, _, U] },
                            Action { relation: Var, columns: [v2, v3], entry: [_, U] },
                            Action { relation: g4, columns: [v2], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: None, ty: t0 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: None, ty: t1 },
                            v3: VariableMeta { name: None, ty: t2 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Var \"x\" ) ( Var \"y\" ) )",
                        atoms: [
                            Premise { relation: Var, columns: [v0, v1] },
                            Premise { relation: g5, columns: [v0] },
                            Action { relation: Var, columns: [v2, v1], entry: [_, U] },
                            Action { relation: g6, columns: [v2], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: None, ty: t1 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: None, ty: t1 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g7, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t2 },
                            v3: VariableMeta { name: None, ty: t2 },
                        },
                        unify: [
                            [v3, v2],
                        ],
                    },
                ],
                relations: {
                    r0: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r2: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r3: Var { columns: [String, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r4: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r5: two { columns: [Math], kind: Global(g1), implicit_rules: {n0: [!]} },
                    r6: one { columns: [i64], kind: Global(g2), implicit_rules: {n0: [!]} },
                    r7: g3 { columns: [String], kind: Global(g3), implicit_rules: {n0: [!]} },
                    r8: g4 { columns: [String], kind: Global(g4), implicit_rules: {n0: [!]} },
                    r9: g5 { columns: [String], kind: Global(g5), implicit_rules: {n0: [!]} },
                    r10: g6 { columns: [String], kind: Global(g6), implicit_rules: {n0: [!]} },
                    r11: g7 { columns: [i64], kind: Global(g7), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen : Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct MulRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for MulRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "mul").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "mul", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "mul", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "mul", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort010::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x1,),
                                    |(x0, x1, x2, timestamp)| (x0, x2, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl MulRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.mul_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_1_to_0_2(&self, x1: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .map(|(x0, x2, _timestamp)| (x0, x2))
                }
                fn iter_old_1_to_0_2(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x2))
                        })
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0_2(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct ConstRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(std::primitive::i64, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(std::primitive::i64,), (Math, TimeStamp)>,
                i64_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ConstRelation {
                type Row = (std::primitive::i64, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "i64", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "const").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "const", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "const", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "const", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl ConstRelation {
                fn iter_all_0_to_1(&self, x0: std::primitive::i64) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.const_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn check_0_1(&self, x0: std::primitive::i64, x1: Math) -> bool {
                    self.iter_all_0_to_1(x0)
                        .next()
                        .is_some_and(|(y1,)| true && x1 == y1)
                }
            }
            #[derive(Debug, Default)]
            struct VarRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(runtime::IString, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(runtime::IString,), (Math, TimeStamp)>,
                string_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for VarRelation {
                type Row = (runtime::IString, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "var", "string", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "var", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "var").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "var", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "var", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "var", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl VarRelation {
                fn iter_all_0_to_1(&self, x0: runtime::IString) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: runtime::IString,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: runtime::IString,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.var_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: runtime::IString) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                mul_: Vec<<MulRelation as Relation>::Row>,
                add_: Vec<<AddRelation as Relation>::Row>,
                const_: Vec<<ConstRelation as Relation>::Row>,
                var_: Vec<<VarRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.mul_.is_empty();
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts |= !self.const_.is_empty();
                    has_new_inserts |= !self.var_.is_empty();
                    has_new_inserts
                }
                pub fn insert_mul(&mut self, x: <MulRelation as Relation>::Row) {
                    self.mul_.push(x);
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
                pub fn insert_const(&mut self, x: <ConstRelation as Relation>::Row) {
                    self.const_.push(x);
                }
                pub fn insert_var(&mut self, x: <VarRelation as Relation>::Row) {
                    self.var_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                global_i64: GlobalVars<std::primitive::i64>,
                global_string: GlobalVars<runtime::IString>,
                global_math: GlobalVars<Math>,
                pub mul_: MulRelation,
                pub add_: AddRelation,
                pub const_: ConstRelation,
                pub var_: VarRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory.global_i64.define(0usize, 2i64);
                    theory.global_math.define(0usize, {
                        let tmp0 = theory.global_i64.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_i64.define(1usize, 1i64);
                    theory.global_string.define(0usize, IString(0u32));
                    theory.global_string.define(1usize, IString(1u32));
                    theory.global_string.define(2usize, IString(2u32));
                    theory.global_string.define(3usize, IString(3u32));
                    theory.global_i64.define(2usize, 0i64);
                    theory.canonicalize();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qa, qv24, qv25) in self.mul_.iter_new() {
                        if let qv23 = self.global_i64.get(2usize) {
                            if self.const_.check_0_1(qv23, qv24) {
                                #[doc = "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"]
                                self.uf.math_.union(qv24, qv25);
                            }
                        }
                    }
                    for (qone, qv1) in self.const_.iter_new() {
                        if qone == self.global_i64.get(0usize) {
                            #[doc = "( rewrite ( Const 2 ) ( Add ( Var \"z\" ) ( Var \"z\" ) ) )"]
                            let qv10 = self.global_string.get(1usize);
                            let (qv11,) = self.var_.entry_0_to_1(qv10, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv11, qv11, qv1));
                        }
                        if qone == self.global_i64.get(1usize) {
                            #[doc = "( rewrite ( Const one ) ( Add ( Var \"q\" ) ( Var \"q\" ) ) )"]
                            let qv2 = self.global_string.get(0usize);
                            let (qv3,) = self.var_.entry_0_to_1(qv2, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv3, qv3, qv1));
                        }
                        if qone == self.global_i64.get(2usize) {
                            for (qa_2, qv29) in self.mul_.iter_old_1_to_0_2(qv1, self.latest_timestamp) {
                                #[doc = "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"]
                                self.uf.math_.union(qv1, qv29);
                            }
                        }
                    }
                    for (qv16, qv17) in self.var_.iter_new() {
                        if qv16 == self.global_string.get(2usize) {
                            #[doc = "( rewrite ( Var \"x\" ) ( Var \"y\" ) )"]
                            let qv18 = self.global_string.get(3usize);
                            self.delta.insert_var((qv18, qv17));
                        }
                    }
                    if let Some(qv12) = self.global_i64.get_new(0usize) {
                        for (qv13,) in self.const_.iter_old_0_to_1(qv12, self.latest_timestamp) {
                            #[doc = "( rewrite ( Const 2 ) ( Add ( Var \"z\" ) ( Var \"z\" ) ) )"]
                            let qv14 = self.global_string.get(1usize);
                            let (qv15,) = self.var_.entry_0_to_1(qv14, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv15, qv15, qv13));
                        }
                    }
                    if let Some(qone_2) = self.global_i64.get_new(1usize) {
                        for (qv5,) in self.const_.iter_old_0_to_1(qone_2, self.latest_timestamp) {
                            #[doc = "( rewrite ( Const one ) ( Add ( Var \"q\" ) ( Var \"q\" ) ) )"]
                            let qv6 = self.global_string.get(0usize);
                            let (qv7,) = self.var_.entry_0_to_1(qv6, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv7, qv7, qv5));
                        }
                    }
                    if let Some(qv19) = self.global_string.get_new(2usize) {
                        for (qv20,) in self.var_.iter_old_0_to_1(qv19, self.latest_timestamp) {
                            #[doc = "( rewrite ( Var \"x\" ) ( Var \"y\" ) )"]
                            let qv21 = self.global_string.get(3usize);
                            self.delta.insert_var((qv21, qv20));
                        }
                    }
                    if let Some(qv31) = self.global_i64.get_new(2usize) {
                        for (qv32,) in self.const_.iter_old_0_to_1(qv31, self.latest_timestamp) {
                            for (qa_3, qv33) in self.mul_.iter_old_1_to_0_2(qv32, self.latest_timestamp) {
                                #[doc = "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"]
                                self.uf.math_.union(qv32, qv33);
                            }
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.mul_.emit_graphviz(&mut buf);
                    self.add_.emit_graphviz(&mut buf);
                    self.const_.emit_graphviz(&mut buf);
                    self.var_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [
                        ("Mul", self.mul_.len()),
                        ("Add", self.add_.len()),
                        ("Const", self.const_.len()),
                        ("Var", self.var_.len()),
                    ]
                    .into_iter()
                    .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.mul_.clear_new();
                        self.add_.clear_new();
                        self.const_.clear_new();
                        self.var_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.mul_
                                .update_begin(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                            self.const_.update_begin(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.var_
                                .update_begin(&mut self.delta.var_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.mul_
                                        .update(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                progress |= self.const_.update(
                                    &mut self.delta.const_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |=
                                    self.var_
                                        .update(&mut self.delta.var_, &mut self.uf, self.latest_timestamp);
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.mul_.update_finalize(
                                &mut self.delta.mul_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.const_.update_finalize(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.var_.update_finalize(
                                &mut self.delta.var_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.global_math.update(&mut self.uf.math_);
                            self.global_i64.update_finalize();
                            self.global_string.update_finalize();
                            self.global_math.update_finalize();
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.mul_.deferred_update();
                    self.add_.deferred_update();
                    self.const_.deferred_update();
                    self.var_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]])
    }
    .check();
}

#[test]
fn triangle_join() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (sort Math)
            (relation Foo (Math Math))
            (relation Bar (Math Math))
            (relation Baz (Math Math))

            (relation Triangle (Math Math Math))

            (rule ((Foo a b) (Bar b c) (Baz c a)) ((Triangle a b c)))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rule ( ( Foo a b ) ( Bar b c ) ( Baz c a ) ) ( ( Triangle a b c ) ) )",
                        atoms: [
                            Premise { relation: Foo, columns: [a, b] },
                            Premise { relation: Bar, columns: [b, c] },
                            Premise { relation: Baz, columns: [c, a] },
                            Action { relation: Triangle, columns: [a, b, c] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                            v2: VariableMeta { name: Some("c"), ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Foo { columns: [Math, Math], kind: Table, implicit_rules: {} },
                    r1: Bar { columns: [Math, Math], kind: Table, implicit_rules: {} },
                    r2: Baz { columns: [Math, Math], kind: Table, implicit_rules: {} },
                    r3: Triangle { columns: [Math, Math, Math], kind: Table, implicit_rules: {} },
                },
            }"#]]),
        expected_tir: Some(expect![[r#"
            Trie {
                map: {
                    Primary(r0_New(*v0*, *v1*)): Trie {
                        map: {
                            Semi(r1_All(v1, *v2*)): Trie {
                                map: {
                                    Primary(r2_All(*v2*, v0)): Trie {
                                        map: {
                                            Primary(r1_All(v1, v2)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    Primary(r1_New(*v4*, *v5*)): Trie {
                        map: {
                            Semi(r2_All(v5, *v3*)): Trie {
                                map: {
                                    Primary(r0_Old(*v3*, v4)): Trie {
                                        map: {
                                            Primary(r2_All(v5, v3)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    Primary(r2_New(*v8*, *v6*)): Trie {
                        map: {
                            Semi(r0_Old(v6, *v7*)): Trie {
                                map: {
                                    Primary(r1_Old(*v7*, v8)): Trie {
                                        map: {
                                            Primary(r0_Old(v6, v7)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            }"#]]),
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Foo",
                        param_types: {c0: t0, c1: t0},
                        kind: Table {
                            index_to_info: {ir0: 0=>1, ir1: 0_1=>, ir2: 1=>0},
                        },
                    },
                    r1: RelationData {
                        name: "Bar",
                        param_types: {c0: t0, c1: t0},
                        kind: Table {
                            index_to_info: {ir0: 0=>1, ir1: 0_1=>, ir2: 1=>0},
                        },
                    },
                    r2: RelationData {
                        name: "Baz",
                        param_types: {c0: t0, c1: t0},
                        kind: Table {
                            index_to_info: {ir0: 0=>1, ir1: 0_1=>, ir2: 1=>0},
                        },
                    },
                    r3: RelationData {
                        name: "Triangle",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1_2=>},
                        },
                    },
                },
                rule_variables: {
                    [v0, qa]: t0,
                    [v1, qb]: t0,
                    [v2, qc]: t0,
                    [v3, qa_2]: t0,
                    [v4, qb_2]: t0,
                    [v5, qc_2]: t0,
                    [v6, qa_3]: t0,
                    [v7, qb_3]: t0,
                    [v8, qc_3]: t0,
                },
                global_variable_types: {},
                rule_tries: [
                    premise: [IterNew, r0(v0, v1)]
                    then: [
                        premise: [SemiJoin, r1(v1, v2), ir0]
                        then: [
                            premise: [JoinAll, r2(v2, v0), ir2]
                            then: [
                                premise: [SemiJoin, r1(v1, v2), ir1]
                                meta: "( rule ( ( Foo a b ) ( Bar b c ) ( Baz c a ) ) ( ( Triangle a b c ) ) )"
                                actions: [
                                    [Action::Insert, r3(v0, v1, v2)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r1(v4, v5)]
                    then: [
                        premise: [SemiJoin, r2(v5, v3), ir0]
                        then: [
                            premise: [JoinOld, r0(v3, v4), ir2]
                            then: [
                                premise: [SemiJoin, r2(v5, v3), ir1]
                                meta: "( rule ( ( Foo a b ) ( Bar b c ) ( Baz c a ) ) ( ( Triangle a b c ) ) )"
                                actions: [
                                    [Action::Insert, r3(v3, v4, v5)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r2(v8, v6)]
                    then: [
                        premise: [SemiJoin, r0(v6, v7), ir0]
                        then: [
                            premise: [JoinOld, r1(v7, v8), ir2]
                            then: [
                                premise: [SemiJoin, r0(v6, v7), ir1]
                                meta: "( rule ( ( Foo a b ) ( Bar b c ) ( Baz c a ) ) ( ( Triangle a b c ) ) )"
                                actions: [
                                    [Action::Insert, r3(v6, v7, v8)],
                                ],
                            ],
                        ],
                    ],
                ],
                initial: [],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct FooRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, TimeStamp)>,
                nofd_index_0_1: runtime::IndexedSortedList<(Math, Math), (TimeStamp,)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for FooRelation {
                type Row = (Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self.nofd_index_0.iter_key_value().enumerate() {
                        writeln!(buf, "{}_{i} -> {}_{};", "foo", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "foo", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "foo").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "foo", {});
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "foo", {
                        return false;
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "foo", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            assert_eq!(self.new.len(), 0);
                            self.new.extend(
                                insertions
                                    .iter()
                                    .map(|&(x0, x1)| (uf.math_.find(x0), uf.math_.find(x1)))
                                    .filter(|&(x0, x1)| !self.nofd_index_0_1.contains_key(&(x0, x1))),
                            );
                            #[cfg(debug_assertions)]
                            {
                                let mut old: Vec<_> = self
                                    .nofd_index_0_1
                                    .iter_key_value()
                                    .map(|((x0, x1), _)| (x0, x1))
                                    .collect();
                                let n = old.len();
                                old.sort();
                                old.dedup();
                                assert_eq!(n, old.len(), "old contains only unique elements");
                            }
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.new.dedup();
                            self.all.clear();
                            self.all.extend(self.nofd_index_0_1.iter_key_value().map(
                                |((x0, x1), (timestamp,))| (uf.math_.find(x0), uf.math_.find(x1), timestamp),
                            ));
                            self.all.sort();
                            self.all.dedup_by_key(|&mut (x0, x1, _timestamp)| (x0, x1));
                            self.all.extend(
                                self.new
                                    .iter()
                                    .copied()
                                    .map(|(x0, x1)| (x0, x1, latest_timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort10::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x0,),
                                    |(x0, x1, timestamp)| (x1, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort11::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x0, x1),
                                    |(x0, x1, timestamp)| (timestamp,),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort01::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x1,),
                                    |(x0, x1, timestamp)| (x0, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl FooRelation {
                fn iter_all_0_to_1(&self, x0: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0.iter((x0,)).map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn iter_all_0_1_to_(&self, x0: Math, x1: Math) -> impl Iterator<Item = ()> + use<'_> {
                    self.nofd_index_0_1.iter((x0, x1)).map(|(_timestamp)| ())
                }
                fn iter_old_0_1_to_(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = ()> + use<'_> {
                    self.nofd_index_0_1
                        .iter((x0, x1))
                        .filter_map(move |(timestamp,)| (timestamp < latest_timestamp).then_some(()))
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_(x0, x1).next().is_some()
                }
                fn iter_all_1_to_0(&self, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_1.iter((x1,)).map(|(x0, _timestamp)| (x0,))
                }
                fn iter_old_1_to_0(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, timestamp)| (timestamp < latest_timestamp).then_some((x0,)))
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct BarRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, TimeStamp)>,
                nofd_index_0_1: runtime::IndexedSortedList<(Math, Math), (TimeStamp,)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for BarRelation {
                type Row = (Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self.nofd_index_0.iter_key_value().enumerate() {
                        writeln!(buf, "{}_{i} -> {}_{};", "bar", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "bar", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "bar").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "bar", {});
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "bar", {
                        return false;
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "bar", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            assert_eq!(self.new.len(), 0);
                            self.new.extend(
                                insertions
                                    .iter()
                                    .map(|&(x0, x1)| (uf.math_.find(x0), uf.math_.find(x1)))
                                    .filter(|&(x0, x1)| !self.nofd_index_0_1.contains_key(&(x0, x1))),
                            );
                            #[cfg(debug_assertions)]
                            {
                                let mut old: Vec<_> = self
                                    .nofd_index_0_1
                                    .iter_key_value()
                                    .map(|((x0, x1), _)| (x0, x1))
                                    .collect();
                                let n = old.len();
                                old.sort();
                                old.dedup();
                                assert_eq!(n, old.len(), "old contains only unique elements");
                            }
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.new.dedup();
                            self.all.clear();
                            self.all.extend(self.nofd_index_0_1.iter_key_value().map(
                                |((x0, x1), (timestamp,))| (uf.math_.find(x0), uf.math_.find(x1), timestamp),
                            ));
                            self.all.sort();
                            self.all.dedup_by_key(|&mut (x0, x1, _timestamp)| (x0, x1));
                            self.all.extend(
                                self.new
                                    .iter()
                                    .copied()
                                    .map(|(x0, x1)| (x0, x1, latest_timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort10::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x0,),
                                    |(x0, x1, timestamp)| (x1, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort11::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x0, x1),
                                    |(x0, x1, timestamp)| (timestamp,),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort01::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x1,),
                                    |(x0, x1, timestamp)| (x0, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl BarRelation {
                fn iter_all_0_to_1(&self, x0: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0.iter((x0,)).map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn iter_all_0_1_to_(&self, x0: Math, x1: Math) -> impl Iterator<Item = ()> + use<'_> {
                    self.nofd_index_0_1.iter((x0, x1)).map(|(_timestamp)| ())
                }
                fn iter_old_0_1_to_(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = ()> + use<'_> {
                    self.nofd_index_0_1
                        .iter((x0, x1))
                        .filter_map(move |(timestamp,)| (timestamp < latest_timestamp).then_some(()))
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_(x0, x1).next().is_some()
                }
                fn iter_all_1_to_0(&self, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_1.iter((x1,)).map(|(x0, _timestamp)| (x0,))
                }
                fn iter_old_1_to_0(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, timestamp)| (timestamp < latest_timestamp).then_some((x0,)))
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct BazRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, TimeStamp)>,
                nofd_index_0_1: runtime::IndexedSortedList<(Math, Math), (TimeStamp,)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for BazRelation {
                type Row = (Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self.nofd_index_0.iter_key_value().enumerate() {
                        writeln!(buf, "{}_{i} -> {}_{};", "baz", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "baz", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "baz").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "baz", {});
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "baz", {
                        return false;
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "baz", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            assert_eq!(self.new.len(), 0);
                            self.new.extend(
                                insertions
                                    .iter()
                                    .map(|&(x0, x1)| (uf.math_.find(x0), uf.math_.find(x1)))
                                    .filter(|&(x0, x1)| !self.nofd_index_0_1.contains_key(&(x0, x1))),
                            );
                            #[cfg(debug_assertions)]
                            {
                                let mut old: Vec<_> = self
                                    .nofd_index_0_1
                                    .iter_key_value()
                                    .map(|((x0, x1), _)| (x0, x1))
                                    .collect();
                                let n = old.len();
                                old.sort();
                                old.dedup();
                                assert_eq!(n, old.len(), "old contains only unique elements");
                            }
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.new.dedup();
                            self.all.clear();
                            self.all.extend(self.nofd_index_0_1.iter_key_value().map(
                                |((x0, x1), (timestamp,))| (uf.math_.find(x0), uf.math_.find(x1), timestamp),
                            ));
                            self.all.sort();
                            self.all.dedup_by_key(|&mut (x0, x1, _timestamp)| (x0, x1));
                            self.all.extend(
                                self.new
                                    .iter()
                                    .copied()
                                    .map(|(x0, x1)| (x0, x1, latest_timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort10::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x0,),
                                    |(x0, x1, timestamp)| (x1, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort11::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x0, x1),
                                    |(x0, x1, timestamp)| (timestamp,),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort01::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x1,),
                                    |(x0, x1, timestamp)| (x0, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl BazRelation {
                fn iter_all_0_to_1(&self, x0: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0.iter((x0,)).map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn iter_all_0_1_to_(&self, x0: Math, x1: Math) -> impl Iterator<Item = ()> + use<'_> {
                    self.nofd_index_0_1.iter((x0, x1)).map(|(_timestamp)| ())
                }
                fn iter_old_0_1_to_(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = ()> + use<'_> {
                    self.nofd_index_0_1
                        .iter((x0, x1))
                        .filter_map(move |(timestamp,)| (timestamp < latest_timestamp).then_some(()))
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_(x0, x1).next().is_some()
                }
                fn iter_all_1_to_0(&self, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_1.iter((x1,)).map(|(x0, _timestamp)| (x0,))
                }
                fn iter_old_1_to_0(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, timestamp)| (timestamp < latest_timestamp).then_some((x0,)))
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct TriangleRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                nofd_index_0_1_2: runtime::IndexedSortedList<(Math, Math, Math), (TimeStamp,)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for TriangleRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1, x2), (_timestamp,))) in self.nofd_index_0_1_2.iter_key_value().enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "triangle", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "triangle", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "triangle", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "triangle").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "triangle", {});
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "triangle", {
                        return false;
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "triangle", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            assert_eq!(self.new.len(), 0);
                            self.new.extend(
                                insertions
                                    .iter()
                                    .map(|&(x0, x1, x2)| {
                                        (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2))
                                    })
                                    .filter(|&(x0, x1, x2)| !self.nofd_index_0_1_2.contains_key(&(x0, x1, x2))),
                            );
                            #[cfg(debug_assertions)]
                            {
                                let mut old: Vec<_> = self
                                    .nofd_index_0_1_2
                                    .iter_key_value()
                                    .map(|((x0, x1, x2), _)| (x0, x1, x2))
                                    .collect();
                                let n = old.len();
                                old.sort();
                                old.dedup();
                                assert_eq!(n, old.len(), "old contains only unique elements");
                            }
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.new.dedup();
                            self.all.clear();
                            self.all.extend(self.nofd_index_0_1_2.iter_key_value().map(
                                |((x0, x1, x2), (timestamp,))| {
                                    (
                                        uf.math_.find(x0),
                                        uf.math_.find(x1),
                                        uf.math_.find(x2),
                                        timestamp,
                                    )
                                },
                            ));
                            self.all.sort();
                            self.all
                                .dedup_by_key(|&mut (x0, x1, x2, _timestamp)| (x0, x1, x2));
                            self.all.extend(
                                self.new
                                    .iter()
                                    .copied()
                                    .map(|(x0, x1, x2)| (x0, x1, x2, latest_timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort111::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_1_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0, x1, x2),
                                    |(x0, x1, x2, timestamp)| (timestamp,),
                                );
                            }
                        });
                    }
                }
            }
            impl TriangleRelation {
                fn iter_all_0_1_2_to_(
                    &self,
                    x0: Math,
                    x1: Math,
                    x2: Math,
                ) -> impl Iterator<Item = ()> + use<'_> {
                    self.nofd_index_0_1_2
                        .iter((x0, x1, x2))
                        .map(|(_timestamp)| ())
                }
                fn iter_old_0_1_2_to_(
                    &self,
                    x0: Math,
                    x1: Math,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = ()> + use<'_> {
                    self.nofd_index_0_1_2
                        .iter((x0, x1, x2))
                        .filter_map(move |(timestamp,)| (timestamp < latest_timestamp).then_some(()))
                }
                fn check_0_1_2(&self, x0: Math, x1: Math, x2: Math) -> bool {
                    self.iter_all_0_1_2_to_(x0, x1, x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                foo_: Vec<<FooRelation as Relation>::Row>,
                bar_: Vec<<BarRelation as Relation>::Row>,
                baz_: Vec<<BazRelation as Relation>::Row>,
                triangle_: Vec<<TriangleRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.foo_.is_empty();
                    has_new_inserts |= !self.bar_.is_empty();
                    has_new_inserts |= !self.baz_.is_empty();
                    has_new_inserts |= !self.triangle_.is_empty();
                    has_new_inserts
                }
                pub fn insert_foo(&mut self, x: <FooRelation as Relation>::Row) {
                    self.foo_.push(x);
                }
                pub fn insert_bar(&mut self, x: <BarRelation as Relation>::Row) {
                    self.bar_.push(x);
                }
                pub fn insert_baz(&mut self, x: <BazRelation as Relation>::Row) {
                    self.baz_.push(x);
                }
                pub fn insert_triangle(&mut self, x: <TriangleRelation as Relation>::Row) {
                    self.triangle_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub foo_: FooRelation,
                pub bar_: BarRelation,
                pub baz_: BazRelation,
                pub triangle_: TriangleRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qa, qb) in self.foo_.iter_new() {
                        if self.bar_.check_0(qb) {
                            for (qc,) in self.baz_.iter_all_1_to_0(qa) {
                                if self.bar_.check_0_1(qb, qc) {
                                    #[doc = "( rule ( ( Foo a b ) ( Bar b c ) ( Baz c a ) ) ( ( Triangle a b c ) ) )"]
                                    self.delta.insert_triangle((qa, qb, qc));
                                }
                            }
                        }
                    }
                    for (qb_2, qc_2) in self.bar_.iter_new() {
                        if self.baz_.check_0(qc_2) {
                            for (qa_2,) in self.foo_.iter_old_1_to_0(qb_2, self.latest_timestamp) {
                                if self.baz_.check_0_1(qc_2, qa_2) {
                                    #[doc = "( rule ( ( Foo a b ) ( Bar b c ) ( Baz c a ) ) ( ( Triangle a b c ) ) )"]
                                    self.delta.insert_triangle((qa_2, qb_2, qc_2));
                                }
                            }
                        }
                    }
                    for (qc_3, qa_3) in self.baz_.iter_new() {
                        if self.foo_.check_0(qa_3) {
                            for (qb_3,) in self.bar_.iter_old_1_to_0(qc_3, self.latest_timestamp) {
                                if self.foo_.check_0_1(qa_3, qb_3) {
                                    #[doc = "( rule ( ( Foo a b ) ( Bar b c ) ( Baz c a ) ) ( ( Triangle a b c ) ) )"]
                                    self.delta.insert_triangle((qa_3, qb_3, qc_3));
                                }
                            }
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.foo_.emit_graphviz(&mut buf);
                    self.bar_.emit_graphviz(&mut buf);
                    self.baz_.emit_graphviz(&mut buf);
                    self.triangle_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [
                        ("Foo", self.foo_.len()),
                        ("Bar", self.bar_.len()),
                        ("Baz", self.baz_.len()),
                        ("Triangle", self.triangle_.len()),
                    ]
                    .into_iter()
                    .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.foo_.clear_new();
                        self.bar_.clear_new();
                        self.baz_.clear_new();
                        self.triangle_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.foo_
                                .update_begin(&mut self.delta.foo_, &mut self.uf, self.latest_timestamp);
                            self.bar_
                                .update_begin(&mut self.delta.bar_, &mut self.uf, self.latest_timestamp);
                            self.baz_
                                .update_begin(&mut self.delta.baz_, &mut self.uf, self.latest_timestamp);
                            self.triangle_.update_begin(
                                &mut self.delta.triangle_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.foo_
                                        .update(&mut self.delta.foo_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.bar_
                                        .update(&mut self.delta.bar_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.baz_
                                        .update(&mut self.delta.baz_, &mut self.uf, self.latest_timestamp);
                                progress |= self.triangle_.update(
                                    &mut self.delta.triangle_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.foo_.update_finalize(
                                &mut self.delta.foo_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.bar_.update_finalize(
                                &mut self.delta.bar_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.baz_.update_finalize(
                                &mut self.delta.baz_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.triangle_.update_finalize(
                                &mut self.delta.triangle_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.foo_.deferred_update();
                    self.bar_.deferred_update();
                    self.baz_.deferred_update();
                    self.triangle_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

// NOTE: this is a actually a triangle join.
//
// (Add t0 t1 _)
// (Mul a _ t0)
// (Mul a _ t1)
//
// which is essentially the same as:
//
// (Foo a b)
// (Bar b c)
// (Baz c a)
//
#[test]
fn edgecase0() {
    // needed a "PremiseAny"
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math
                (Mul Math Math)
                (Add Math Math)
            )
            (rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, b, v2] },
                            Premise { relation: Mul, columns: [a, c, v4] },
                            Premise { relation: Add, columns: [v2, v4, v5] },
                            Action { relation: Mul, columns: [a, v6, v5], entry: [_, _, U] },
                            Action { relation: Add, columns: [b, c, v6], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: Some("c"), ty: t0 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t0 },
                            v6: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                },
            }"#]]),
        expected_tir: Some(expect![[r#"
            Trie {
                map: {
                    Primary(r0_New(*v0*, *v1*, *v2*)): Trie {
                        map: {
                            Semi(r0_All(v0, *v3*, *v4*)): Trie {
                                map: {
                                    Primary(r1_All(v2, *v4*, *v5*)): Trie {
                                        map: {
                                            Primary(r0_All(v0, *v3*, v4)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                            Semi(r1_All(*v9*, v2, *v12*)): Trie {
                                map: {
                                    Primary(r0_Old(v0, *v8*, *v9*)): Trie {
                                        map: {
                                            Primary(r1_All(v9, v2, *v12*)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    Primary(r1_New(*v16*, *v18*, *v19*)): Trie {
                        map: {
                            Semi(r0_Old(*v14*, *v15*, v16)): Trie {
                                map: {
                                    Primary(r0_Old(*v14*, *v17*, v18)): Trie {
                                        map: {
                                            Primary(r0_Old(v14, *v15*, v16)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            }"#]]),
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Mul",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2, ir2: 0_2=>1, ir3: 2=>0_1},
                        },
                    },
                    r1: RelationData {
                        name: "Add",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2, ir2: 1=>0_2},
                        },
                    },
                },
                rule_variables: {
                    [v0, qa]: t0,
                    [v1, qb]: t0,
                    [v10, qc_2]: t0,
                    [v11, qv11]: t0,
                    [v12, qv12]: t0,
                    [v13, qv13]: t0,
                    [v14, qa_3]: t0,
                    [v15, qb_3]: t0,
                    [v16, qv16]: t0,
                    [v17, qc_3]: t0,
                    [v18, qv18]: t0,
                    [v19, qv19]: t0,
                    [v2, qv2]: t0,
                    [v20, qv20]: t0,
                    [v3, qc]: t0,
                    [v4, qv4]: t0,
                    [v5, qv5]: t0,
                    [v6, qv6]: t0,
                    [v7, qa_2]: t0,
                    [v8, qb_2]: t0,
                    [v9, qv9]: t0,
                },
                global_variable_types: {},
                rule_tries: [
                    premise: [IterNew, r0(v0, v1, v2)]
                    then: [
                        premise: [SemiJoin, r0(v0, v3, v4), ir1]
                        then: [
                            premise: [JoinAll, r1(v2, v4, v5), ir1]
                            then: [
                                premise: [JoinAll, r0(v0, v3, v4), ir2]
                                meta: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r1(v1, v3, v6) on ir0],
                                    [Action::Insert, r0(v0, v6, v5)],
                                ],
                            ],
                        ],
                        premise: [SemiJoin, r1(v9, v2, v12), ir2]
                        then: [
                            premise: [JoinOld, r0(v0, v8, v9), ir1]
                            then: [
                                premise: [JoinAll, r1(v9, v2, v12), ir0]
                                meta: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r1(v8, v1, v13) on ir0],
                                    [Action::Insert, r0(v0, v13, v12)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r1(v16, v18, v19)]
                    then: [
                        premise: [SemiJoin, r0(v14, v15, v16), ir3]
                        then: [
                            premise: [JoinOld, r0(v14, v17, v18), ir3]
                            then: [
                                premise: [JoinOld, r0(v14, v15, v16), ir2]
                                meta: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r1(v15, v17, v20) on ir0],
                                    [Action::Insert, r0(v14, v20, v19)],
                                ],
                            ],
                        ],
                    ],
                ],
                initial: [],
            }"#]]),
        expected_codegen : Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct MulRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_0_2: runtime::IndexedSortedList<(Math, Math), (Math, TimeStamp)>,
                nofd_index_2: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for MulRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 12u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "mul").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "mul", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "mul", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "mul", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort101::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0, x2),
                                    |(x0, x1, x2, timestamp)| (x1, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort001::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x2,),
                                    |(x0, x1, x2, timestamp)| (x0, x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl MulRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.mul_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
                fn iter_all_0_2_to_1(&self, x0: Math, x2: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_2_to_1(
                    &self,
                    x0: Math,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                fn check_0_2(&self, x0: Math, x2: Math) -> bool {
                    self.iter_all_0_2_to_1(x0, x2).next().is_some()
                }
                fn iter_all_2_to_0_1(&self, x2: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .map(|(x0, x1, _timestamp)| (x0, x1))
                }
                fn iter_old_2_to_0_1(
                    &self,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .filter_map(move |(x0, x1, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x1))
                        })
                }
                fn check_2(&self, x2: Math) -> bool {
                    self.iter_all_2_to_0_1(x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 9u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort010::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x1,),
                                    |(x0, x1, x2, timestamp)| (x0, x2, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
                fn iter_all_1_to_0_2(&self, x1: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .map(|(x0, x2, _timestamp)| (x0, x2))
                }
                fn iter_old_1_to_0_2(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x2))
                        })
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0_2(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                mul_: Vec<<MulRelation as Relation>::Row>,
                add_: Vec<<AddRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.mul_.is_empty();
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts
                }
                pub fn insert_mul(&mut self, x: <MulRelation as Relation>::Row) {
                    self.mul_.push(x);
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub mul_: MulRelation,
                pub add_: AddRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qa, qb, qv2) in self.mul_.iter_new() {
                        if self.mul_.check_0(qa) {
                            for (qv4, qv5) in self.add_.iter_all_0_to_1_2(qv2) {
                                for (qc,) in self.mul_.iter_all_0_2_to_1(qa, qv4) {
                                    #[doc = "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"]
                                    let (qv6,) =
                                        self.add_
                                            .entry_0_1_to_2(qb, qc, &mut self.delta, &mut self.uf);
                                    self.delta.insert_mul((qa, qv6, qv5));
                                }
                            }
                        }
                        if self.add_.check_1(qv2) {
                            for (qb_2, qv9) in self.mul_.iter_old_0_to_1_2(qa, self.latest_timestamp) {
                                for (qv12,) in self.add_.iter_all_0_1_to_2(qv9, qv2) {
                                    #[doc = "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"]
                                    let (qv13,) =
                                        self.add_
                                            .entry_0_1_to_2(qb_2, qb, &mut self.delta, &mut self.uf);
                                    self.delta.insert_mul((qa, qv13, qv12));
                                }
                            }
                        }
                    }
                    for (qv16, qv18, qv19) in self.add_.iter_new() {
                        if self.mul_.check_2(qv16) {
                            for (qa_3, qc_3) in self.mul_.iter_old_2_to_0_1(qv18, self.latest_timestamp) {
                                for (qb_3,) in self
                                    .mul_
                                    .iter_old_0_2_to_1(qa_3, qv16, self.latest_timestamp)
                                {
                                    #[doc = "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"]
                                    let (qv20,) =
                                        self.add_
                                            .entry_0_1_to_2(qb_3, qc_3, &mut self.delta, &mut self.uf);
                                    self.delta.insert_mul((qa_3, qv20, qv19));
                                }
                            }
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.mul_.emit_graphviz(&mut buf);
                    self.add_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Mul", self.mul_.len()), ("Add", self.add_.len())]
                        .into_iter()
                        .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.mul_.clear_new();
                        self.add_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.mul_
                                .update_begin(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.mul_
                                        .update(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.mul_.update_finalize(
                                &mut self.delta.mul_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.mul_.deferred_update();
                    self.add_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]])
    }
    .check();
}

#[test]
fn edgecase0_no_egglog_compat() {
    // needed a "PremiseAny"
    Steps {
        strict_egglog_compat: false,
        code: r"
            (datatype Math
                (Mul Math Math)
                (Add Math Math)
            )
            (rewrite (Add a b) (Add b a))
            (rewrite (Mul a b) (Mul b a))
            (rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Add a b ) ( Add b a ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, b, v2] },
                            Action { relation: Add, columns: [b, a, v2], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a b ) ( Mul b a ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, b, v2] },
                            Action { relation: Mul, columns: [b, a, v2], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, b, v2] },
                            Premise { relation: Mul, columns: [a, c, v4] },
                            Premise { relation: Add, columns: [v2, v4, v5] },
                            Action { relation: Mul, columns: [a, v6, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v6, a, v5] },
                            Action { relation: Add, columns: [b, c, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [c, b, v6] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: Some("c"), ty: t0 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t0 },
                            v6: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]}, invariant_permutations: {[0, 1, 2], [1, 0, 2]} },
                    r1: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]}, invariant_permutations: {[0, 1, 2], [1, 0, 2]} },
                },
            }"#]]),
        expected_tir: Some(expect![[r#"
            Trie {
                map: {
                    Primary(r0_New(*v3*, *v4*, *v5*)): Trie {
                        map: {
                            Semi(r0_All(v3, *v9*, *v10*)): Trie {
                                map: {
                                    Primary(r1_All(v5, *v10*, *v11*)): Trie {
                                        map: {
                                            Primary(r0_All(v3, *v9*, v10)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    Primary(r1_New(*v0*, *v1*, *v2*)): Trie {
                        map: {
                            Semi(r0_Old(*v13*, *v14*, v0)): Trie {
                                map: {
                                    Primary(r0_Old(*v13*, *v16*, v1)): Trie {
                                        map: {
                                            Primary(r0_Old(v13, *v14*, v0)): Trie {
                                                map: {},
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            }"#]]),
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Mul",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2, ir2: 0_2=>1, ir3: 2=>0_1},
                        },
                    },
                    r1: RelationData {
                        name: "Add",
                        param_types: {c0: t0, c1: t0, c2: t0},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2},
                        },
                    },
                },
                rule_variables: {
                    [v0, qa]: t0,
                    [v1, qb]: t0,
                    [v10, qv10]: t0,
                    [v11, qv11]: t0,
                    [v12, qv12]: t0,
                    [v13, qa_4]: t0,
                    [v14, qb_4]: t0,
                    [v15, qv15]: t0,
                    [v16, qc_2]: t0,
                    [v17, qv17]: t0,
                    [v18, qv18]: t0,
                    [v19, qv19]: t0,
                    [v2, qv2]: t0,
                    [v3, qa_2]: t0,
                    [v4, qb_2]: t0,
                    [v5, qv5]: t0,
                    [v6, qa_3]: t0,
                    [v7, qb_3]: t0,
                    [v8, qv8]: t0,
                    [v9, qc]: t0,
                },
                global_variable_types: {},
                rule_tries: [
                    premise: [IterNew, r0(v3, v4, v5)]
                    actions: [
                        [Action::Insert, r0(v3, v4, v5)],
                        [Action::Insert, r0(v4, v3, v5)],
                    ]
                    then: [
                        premise: [SemiJoin, r0(v3, v9, v10), ir1]
                        then: [
                            premise: [JoinAll, r1(v5, v10, v11), ir1]
                            then: [
                                premise: [JoinAll, r0(v3, v9, v10), ir2]
                                meta: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r1(v4, v9, v12) on ir0],
                                    [Action::Insert, r0(v3, v12, v11)],
                                    [Action::Insert, r0(v12, v3, v11)],
                                    [Action::Insert, r1(v9, v4, v12)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r1(v0, v1, v2)]
                    actions: [
                        [Action::Insert, r1(v0, v1, v2)],
                        [Action::Insert, r1(v1, v0, v2)],
                    ]
                    then: [
                        premise: [SemiJoin, r0(v13, v14, v0), ir3]
                        then: [
                            premise: [JoinOld, r0(v13, v16, v1), ir3]
                            then: [
                                premise: [JoinOld, r0(v13, v14, v0), ir2]
                                meta: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r1(v14, v16, v19) on ir0],
                                    [Action::Insert, r0(v13, v19, v2)],
                                    [Action::Insert, r0(v19, v13, v2)],
                                    [Action::Insert, r1(v16, v14, v19)],
                                ],
                            ],
                        ],
                    ],
                ],
                initial: [],
            }"#]]),
        expected_codegen : Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct MulRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_0_2: runtime::IndexedSortedList<(Math, Math), (Math, TimeStamp)>,
                nofd_index_2: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for MulRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 12u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "mul").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "mul", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "mul", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "mul", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort101::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0, x2),
                                    |(x0, x1, x2, timestamp)| (x1, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort001::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x2,),
                                    |(x0, x1, x2, timestamp)| (x0, x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl MulRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.mul_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
                fn iter_all_0_2_to_1(&self, x0: Math, x2: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_2_to_1(
                    &self,
                    x0: Math,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                fn check_0_2(&self, x0: Math, x2: Math) -> bool {
                    self.iter_all_0_2_to_1(x0, x2).next().is_some()
                }
                fn iter_all_2_to_0_1(&self, x2: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .map(|(x0, x1, _timestamp)| (x0, x1))
                }
                fn iter_old_2_to_0_1(
                    &self,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .filter_map(move |(x0, x1, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x1))
                        })
                }
                fn check_2(&self, x2: Math) -> bool {
                    self.iter_all_2_to_0_1(x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                mul_: Vec<<MulRelation as Relation>::Row>,
                add_: Vec<<AddRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.mul_.is_empty();
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts
                }
                pub fn insert_mul(&mut self, x: <MulRelation as Relation>::Row) {
                    self.mul_.push(x);
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub mul_: MulRelation,
                pub add_: AddRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qa_2, qb_2, qv5) in self.mul_.iter_new() {
                        {
                            self.delta.insert_mul((qa_2, qb_2, qv5));
                            self.delta.insert_mul((qb_2, qa_2, qv5));
                        }
                        if self.mul_.check_0(qa_2) {
                            for (qv10, qv11) in self.add_.iter_all_0_to_1_2(qv5) {
                                for (qc,) in self.mul_.iter_all_0_2_to_1(qa_2, qv10) {
                                    #[doc = "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"]
                                    let (qv12,) =
                                        self.add_
                                            .entry_0_1_to_2(qb_2, qc, &mut self.delta, &mut self.uf);
                                    self.delta.insert_mul((qa_2, qv12, qv11));
                                    self.delta.insert_mul((qv12, qa_2, qv11));
                                    self.delta.insert_add((qc, qb_2, qv12));
                                }
                            }
                        }
                    }
                    for (qa, qb, qv2) in self.add_.iter_new() {
                        {
                            self.delta.insert_add((qa, qb, qv2));
                            self.delta.insert_add((qb, qa, qv2));
                        }
                        if self.mul_.check_2(qa) {
                            for (qa_4, qc_2) in self.mul_.iter_old_2_to_0_1(qb, self.latest_timestamp) {
                                for (qb_4,) in self.mul_.iter_old_0_2_to_1(qa_4, qa, self.latest_timestamp) {
                                    #[doc = "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"]
                                    let (qv19,) =
                                        self.add_
                                            .entry_0_1_to_2(qb_4, qc_2, &mut self.delta, &mut self.uf);
                                    self.delta.insert_mul((qa_4, qv19, qv2));
                                    self.delta.insert_mul((qv19, qa_4, qv2));
                                    self.delta.insert_add((qc_2, qb_4, qv19));
                                }
                            }
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.mul_.emit_graphviz(&mut buf);
                    self.add_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Mul", self.mul_.len()), ("Add", self.add_.len())]
                        .into_iter()
                        .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.mul_.clear_new();
                        self.add_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.mul_
                                .update_begin(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.mul_
                                        .update(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.mul_.update_finalize(
                                &mut self.delta.mul_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.mul_.deferred_update();
                    self.add_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]])
    }
    .check();
}

#[test]
fn test_into_codegen() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (datatype Math (Mul Math Math) (Add Math Math))
            (rewrite (Mul (Add a b) c) (Add (Mul a c) (Mul b c)))
        ",
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Mul ( Add a b ) c ) ( Add ( Mul a c ) ( Mul b c ) ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [v2, c, v4] },
                            Premise { relation: Add, columns: [a, b, v2] },
                            Action { relation: Mul, columns: [a, c, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [b, c, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [v5, v6, v4], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t0 },
                            v1: VariableMeta { name: Some("b"), ty: t0 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: Some("c"), ty: t0 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t0 },
                            v6: VariableMeta { name: None, ty: t0 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r1: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: None,
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct MulRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for MulRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "mul").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "mul", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "mul", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "mul", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl MulRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.mul_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_2: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort001::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x2,),
                                    |(x0, x1, x2, timestamp)| (x0, x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_2_to_0_1(&self, x2: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .map(|(x0, x1, _timestamp)| (x0, x1))
                }
                fn iter_old_2_to_0_1(
                    &self,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .filter_map(move |(x0, x1, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x1))
                        })
                }
                fn check_2(&self, x2: Math) -> bool {
                    self.iter_all_2_to_0_1(x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                mul_: Vec<<MulRelation as Relation>::Row>,
                add_: Vec<<AddRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.mul_.is_empty();
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts
                }
                pub fn insert_mul(&mut self, x: <MulRelation as Relation>::Row) {
                    self.mul_.push(x);
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                pub mul_: MulRelation,
                pub add_: AddRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qv2, qc, qv4) in self.mul_.iter_new() {
                        for (qa, qb) in self.add_.iter_all_2_to_0_1(qv2) {
                            #[doc = "( rewrite ( Mul ( Add a b ) c ) ( Add ( Mul a c ) ( Mul b c ) ) )"]
                            let (qv6,) = self
                                .mul_
                                .entry_0_1_to_2(qb, qc, &mut self.delta, &mut self.uf);
                            let (qv5,) = self
                                .mul_
                                .entry_0_1_to_2(qa, qc, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv5, qv6, qv4));
                        }
                    }
                    for (qa_2, qb_2, qv9) in self.add_.iter_new() {
                        for (qc_2, qv11) in self.mul_.iter_old_0_to_1_2(qv9, self.latest_timestamp) {
                            #[doc = "( rewrite ( Mul ( Add a b ) c ) ( Add ( Mul a c ) ( Mul b c ) ) )"]
                            let (qv13,) = self
                                .mul_
                                .entry_0_1_to_2(qb_2, qc_2, &mut self.delta, &mut self.uf);
                            let (qv12,) = self
                                .mul_
                                .entry_0_1_to_2(qa_2, qc_2, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv12, qv13, qv11));
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.mul_.emit_graphviz(&mut buf);
                    self.add_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Mul", self.mul_.len()), ("Add", self.add_.len())]
                        .into_iter()
                        .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [("Math", (self.uf.math_.len(), self.uf.math_.num_roots()))]
                        .into_iter()
                        .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.mul_.clear_new();
                        self.add_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.mul_
                                .update_begin(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |=
                                    self.mul_
                                        .update(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.mul_.update_finalize(
                                &mut self.delta.mul_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.mul_.deferred_update();
                    self.add_.deferred_update();
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[should_panic = "assertion `left != right` failed: forall not yet supported, breaks because it is implicitly represented by unbound premise variables which cannot be semi-naive-ified.\n  left: 0\n right: 0"]
#[test]
#[ignore = "forall is not yet implemented (interacts badly with semi-naive)"]
fn simple_forall() {
    Steps {
        strict_egglog_compat: true,
        code: r"
            (sort Math)
            (relation Le (Math Math))
            (rule ((forall x)) ((define (Le x x))))
        ",
        expected_hir: Some(expect![[r#"
            Theory "":

            Math(Math)
            Le(Math, Math)

            Rule "":
            Premise:
            x: x
            Insert: Le(x, x)

        "#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: "",
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, String]: oatlog::runtime::IString,
                    [t2, unit]: THIS_STRING_SHOULD_NOT_APPEAR_IN_GENERATED_CODE,
                    [t3, Math]: [symbolic],
                },
                relations: {
                    r0: (hir-only relation),
                    r1: RelationData {
                        name: "Le",
                        param_types: {c0: t3, c1: t3},
                        kind: Table {
                            index_to_info: {ir0: 0_1, ir1: 1_0},
                            usage_to_info: {
                                iu0: ir0[..1],
                                iu1: ir1[..1],
                            },
                            column_back_reference: {c0: iu0, c1: iu1},
                        },
                    },
                },
                rule_variables: {},
                global_compute: {},
                global_types: {},
                rule_tries: [],
                initial: [],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            decl_row ! (Row2_0_1 < T0 first , T1 > (0 , 1) () (T0 , T1) () fc = (0) (T0) where u64 = s => ((s . 0 . inner () as u64) << 32) + ((s . 1 . inner () as u64) << 0));
            decl_row ! (Row2_1_0 < T0 , T1 first > (1 , 0) () (T1 , T0) () fc = (1) (T1) where u64 = s => ((s . 1 . inner () as u64) << 32) + ((s . 0 . inner () as u64) << 0));
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct LeRelation {
                new: Vec<<Self as Relation>::Row>,
                all_index_0_1: IndexImpl<RadixSortCtx<Row2_0_1<Math, Math>, u64>>,
                all_index_1_0: IndexImpl<RadixSortCtx<Row2_1_0<Math, Math>, u64>>,
            }
            impl Relation for LeRelation {
                type Row = (Math, Math);
            }
            impl LeRelation {
                const COST: u32 = 4u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl Iterator<Item = <Self as Relation>::Row> + use<'_> {
                    self.new.iter().copied()
                }
                fn iter1_0_1(&self, x0: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.all_index_0_1
                        .range((x0, Math::MIN_ID)..=(x0, Math::MAX_ID))
                        .map(|(x0, x1)| (x1,))
                }
                fn iter1_1_0(&self, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.all_index_1_0
                        .range((Math::MIN_ID, x1)..=(Math::MAX_ID, x1))
                        .map(|(x0, x1)| (x0,))
                }
                fn check1_0_1(&self, x0: Math) -> bool {
                    self.iter1_0_1(x0).next().is_some()
                }
                fn check1_1_0(&self, x1: Math) -> bool {
                    self.iter1_1_0(x1).next().is_some()
                }
                fn update(&mut self, uf: &mut Unification, delta: &mut Delta) {
                    let mut inserts = take(&mut delta.le_relation_delta);
                    let orig_inserts = inserts.len();
                    self.all_index_0_1
                        .first_column_uproots(uf.math_uf.get_uprooted_snapshot(), |deleted_rows| {
                            inserts.extend(deleted_rows)
                        });
                    self.all_index_1_0
                        .first_column_uproots(uf.math_uf.get_uprooted_snapshot(), |deleted_rows| {
                            inserts.extend(deleted_rows)
                        });
                    inserts[orig_inserts..].sort_unstable();
                    runtime::dedup_suffix(&mut inserts, orig_inserts);
                    self.all_index_0_1.delete_many(&mut inserts[orig_inserts..]);
                    self.all_index_1_0.delete_many(&mut inserts[orig_inserts..]);
                    inserts.iter_mut().for_each(|row| {
                        row.0 = uf.math_uf.find(row.0);
                        row.1 = uf.math_uf.find(row.1);
                    });
                    self.all_index_0_1
                        .insert_many(&mut inserts, |mut old, mut new| {
                            let () = old.value_mut();
                            let () = new.value_mut();
                            panic!("panicking merge action")
                        });
                    self.all_index_1_0
                        .insert_many(&mut inserts, |mut old, mut new| {
                            let () = old.value_mut();
                            let () = new.value_mut();
                            panic!("panicking merge action")
                        });
                    self.new.extend_from_slice(&inserts);
                }
                fn update_finalize(&mut self, uf: &mut Unification) {
                    self.new.sort_unstable();
                    self.new.dedup();
                    self.new.retain(|(x0, x1)| {
                        if *x0 != uf.math_uf.find(*x0) {
                            return false;
                        }
                        if *x1 != uf.math_uf.find(*x1) {
                            return false;
                        }
                        true
                    });
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, (x0, x1)) in self.all_index_0_1.iter().enumerate() {
                        write!(buf, "{}{i} -> {}{};", "le", "math", x0).unwrap();
                        write!(buf, "{}{i} -> {}{};", "le", "math", x1).unwrap();
                    }
                }
                fn len(&self) -> usize {
                    self.all_index_0_1.len()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                le_relation_delta: Vec<<LeRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.le_relation_delta.is_empty();
                    has_new_inserts
                }
                pub fn insert_le(&mut self, x: <LeRelation as Relation>::Row) {
                    self.le_relation_delta.push(x);
                }
            }
            #[derive(Default, Debug)]
            struct GlobalVariables {
                new: bool,
            }
            impl GlobalVariables {
                fn initialize(&mut self, delta: &mut Delta, uf: &mut Unification) {
                    self.new = true;
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub math_uf: UnionFind<Math>,
            }
            impl Unification {
                fn has_new_uproots(&mut self) -> bool {
                    let mut ret = false;
                    ret |= self.math_uf.has_new_uproots();
                    ret
                }
                fn snapshot_all_uprooted(&mut self) {
                    self.math_uf.create_uprooted_snapshot();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub delta: Delta,
                pub uf: Unification,
                global_variables: GlobalVariables,
                pub le_relation: LeRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory
                        .global_variables
                        .initialize(&mut theory.delta, &mut theory.uf);
                    theory.canonicalize();
                    theory.global_variables.new = true;
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    [
                        {
                            let start = std::time::Instant::now();
                            self.apply_rules();
                            start.elapsed()
                        },
                        {
                            let start = std::time::Instant::now();
                            self.canonicalize();
                            start.elapsed()
                        },
                    ]
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {}
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {");
                    self.le_relation.emit_graphviz(&mut buf);
                    buf.push_str("}");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    [self.le_relation.len()].into_iter().sum::<usize>()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [("Le", self.le_relation.len())].into_iter().collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.global_variables.new = false;
                    self.le_relation.clear_new();
                    while self.uf.has_new_uproots() || self.delta.has_new_inserts() {
                        self.uf.snapshot_all_uprooted();
                        self.le_relation.update(&mut self.uf, &mut self.delta);
                    }
                    self.uf.snapshot_all_uprooted();
                    self.le_relation.update_finalize(&mut self.uf);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}

#[test]
fn lir_math() {
    Steps {
        strict_egglog_compat: false,
        code: r#"
            (datatype FuelUnit
                (Fuel FuelUnit)
                (ZeroFuel)
            )

            (datatype Math
                (Diff Math Math)
                (Integral FuelUnit Math Math)

                (Add Math Math)
                (Sub Math Math)
                (Mul Math Math)
                (Div Math Math)
                (Pow Math Math)
                (Ln Math)
                (Sqrt Math)

                (Sin Math)
                (Cos Math)

                (Const i64)
                (Var String)
            )

            (rewrite (Integral fuel (Sin x) x) (Mul (Const -1) (Cos x)))
            (rewrite (Sub a b) (Add a (Mul (Const -1) b)))
            (rewrite (Diff x (Cos x)) (Mul (Const -1) (Sin x)))

            (rewrite (Add a b) (Add b a))
            (rewrite (Mul a b) (Mul b a))
            (rewrite (Add a (Add b c)) (Add (Add a b) c))
            (rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))
            (rewrite (Add a (Const 0)) a)
            (rewrite (Mul a (Const 0)) (Const 0))
            (rewrite (Mul a (Const 1)) a)
            (rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))
            (rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))

            (rewrite (Mul (Pow a b) (Pow a c)) (Pow a (Add b c)))
            (rewrite (Pow x (Const 1)) x)

            (rewrite (Pow x (Const 2)) (Mul x x))
            (rewrite (Diff x (Add a b)) (Add (Diff x a) (Diff x b)))
            (rewrite (Diff x (Mul a b)) (Add (Mul a (Diff x b)) (Mul b (Diff x a))))
            (rewrite (Diff x (Sin x)) (Cos x))
            (rewrite (Integral (Fuel fuel) (Const 1) x) x)
            (rewrite (Integral (Fuel fuel) (Cos x) x) (Sin x))
            (rewrite (Integral (Fuel fuel) (Add f g) x) (Add (Integral fuel f x) (Integral fuel g x)))
            (rewrite (Integral (Fuel fuel) (Sub f g) x) (Sub (Integral fuel f x) (Integral fuel g x)))
            (rewrite (Integral (Fuel fuel) (Mul a b) x) (Sub (Mul a (Integral fuel b x)) (Integral fuel (Mul (Diff x a) (Integral fuel b x)) x)))

            (let fuel3 (Fuel (Fuel (Fuel (ZeroFuel)))))

            (Integral fuel3 (Ln (Var "x")) (Var "x"))
            (Integral fuel3 (Add (Var "x") (Cos (Var "x"))) (Var "x"))
            (Integral fuel3 (Mul (Cos (Var "x")) (Var "x")) (Var "x"))
            (Diff (Var "x") (Add (Const 1) (Mul (Const 2) (Var "x"))))
            (Diff (Var "x") (Sub (Pow (Var "x") (Const 3)) (Mul (Const 7) (Pow (Var "x") (Const 2)))))
            (Add (Mul (Var "y") (Add (Var "x") (Var "y"))) (Sub (Add (Var "x") (Const 2)) (Add (Var "x") (Var "x"))))
            (Div (Const 1) (Sub (Div (Add (Const 1) (Sqrt (Var "z"))) (Const 2)) (Div (Sub (Const 1) (Sqrt (Var "z"))) (Const 2))))
        "#,
        expected_hir: Some(expect![[r#"
            Theory {
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, String]: runtime::IString,
                    [t2, FuelUnit]: [symbolic],
                    [t3, Math]: [symbolic],
                },
                symbolic_rules: [
                    SymbolicRule {
                        src: "( rewrite ( Integral fuel ( Sin x ) x ) ( Mul ( Const -1 ) ( Cos x ) ) )",
                        atoms: [
                            Premise { relation: Integral, columns: [fuel, v2, x, v3] },
                            Premise { relation: Sin, columns: [x, v2] },
                            Action { relation: Mul, columns: [v5, v6, v3], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v6, v5, v3] },
                            Action { relation: Cos, columns: [x, v6], entry: [_, U] },
                            Action { relation: Const, columns: [v4, v5], entry: [_, U] },
                            Action { relation: g0, columns: [v4], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: Some("x"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t0 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Sub a b ) ( Add a ( Mul ( Const -1 ) b ) ) )",
                        atoms: [
                            Premise { relation: Sub, columns: [a, b, v2] },
                            Action { relation: Add, columns: [a, v5, v2], entry: [_, _, U] },
                            Action { relation: Add, columns: [v5, a, v2] },
                            Action { relation: Mul, columns: [b, v4, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v4, b, v5] },
                            Action { relation: Const, columns: [v3, v4], entry: [_, U] },
                            Action { relation: g0, columns: [v3], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t0 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Diff x ( Cos x ) ) ( Mul ( Const -1 ) ( Sin x ) ) )",
                        atoms: [
                            Premise { relation: Diff, columns: [x, v1, v2] },
                            Premise { relation: Cos, columns: [x, v1] },
                            Action { relation: Mul, columns: [v4, v5, v2], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v5, v4, v2] },
                            Action { relation: Sin, columns: [x, v5], entry: [_, U] },
                            Action { relation: Const, columns: [v3, v4], entry: [_, U] },
                            Action { relation: g0, columns: [v3], entry: [!] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t0 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add a b ) ( Add b a ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, b, v2] },
                            Action { relation: Add, columns: [b, a, v2], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a b ) ( Mul b a ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, b, v2] },
                            Action { relation: Mul, columns: [b, a, v2], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add a ( Add b c ) ) ( Add ( Add a b ) c ) )",
                        atoms: [
                            Premise { relation: Add, columns: [a, v3, v4] },
                            Premise { relation: Add, columns: [b, c, v3] },
                            Action { relation: Add, columns: [a, b, v5], entry: [_, _, U] },
                            Action { relation: Add, columns: [b, a, v5] },
                            Action { relation: Add, columns: [c, v5, v4], entry: [_, _, U] },
                            Action { relation: Add, columns: [v5, c, v4] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: Some("c"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Mul b c ) ) ( Mul ( Mul a b ) c ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, v3, v4] },
                            Premise { relation: Mul, columns: [b, c, v3] },
                            Action { relation: Mul, columns: [a, b, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [b, a, v5] },
                            Action { relation: Mul, columns: [c, v5, v4], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v5, c, v4] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: Some("c"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add a ( Const 0 ) ) a )",
                        atoms: [
                            Premise { relation: Add, columns: [a, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g1, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v3, a],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g1, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v3, v2],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Const 1 ) ) a )",
                        atoms: [
                            Premise { relation: Mul, columns: [a, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g2, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v3, a],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul a ( Add b c ) ) ( Add ( Mul a b ) ( Mul a c ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [b, c, v3] },
                            Premise { relation: Mul, columns: [a, v3, v4] },
                            Action { relation: Add, columns: [v5, v6, v4], entry: [_, _, U] },
                            Action { relation: Add, columns: [v6, v5, v4] },
                            Action { relation: Mul, columns: [a, b, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [a, c, v6], entry: [_, _, U] },
                            Action { relation: Mul, columns: [b, a, v5] },
                            Action { relation: Mul, columns: [c, a, v6] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: Some("c"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )",
                        atoms: [
                            Premise { relation: Add, columns: [v2, v4, v5] },
                            Premise { relation: Mul, columns: [a, b, v2] },
                            Premise { relation: Mul, columns: [a, c, v4] },
                            Action { relation: Add, columns: [b, c, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [c, b, v6] },
                            Action { relation: Mul, columns: [a, v6, v5], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v6, a, v5] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: Some("c"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Mul ( Pow a b ) ( Pow a c ) ) ( Pow a ( Add b c ) ) )",
                        atoms: [
                            Premise { relation: Mul, columns: [v2, v4, v5] },
                            Premise { relation: Pow, columns: [a, b, v2] },
                            Premise { relation: Pow, columns: [a, c, v4] },
                            Action { relation: Add, columns: [b, c, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [c, b, v6] },
                            Action { relation: Pow, columns: [a, v6, v5], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("a"), ty: t3 },
                            v1: VariableMeta { name: Some("b"), ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: Some("c"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Pow x ( Const 1 ) ) x )",
                        atoms: [
                            Premise { relation: Pow, columns: [x, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g2, columns: [v1] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v3, x],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )",
                        atoms: [
                            Premise { relation: Pow, columns: [x, v2, v3] },
                            Premise { relation: Const, columns: [v1, v2] },
                            Premise { relation: g3, columns: [v1] },
                            Action { relation: Mul, columns: [x, x, v3], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t0 },
                            v2: VariableMeta { name: None, ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Diff x ( Add a b ) ) ( Add ( Diff x a ) ( Diff x b ) ) )",
                        atoms: [
                            Premise { relation: Diff, columns: [x, v3, v4] },
                            Premise { relation: Add, columns: [a, b, v3] },
                            Action { relation: Diff, columns: [x, a, v5], entry: [_, _, U] },
                            Action { relation: Diff, columns: [x, b, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [v5, v6, v4], entry: [_, _, U] },
                            Action { relation: Add, columns: [v6, v5, v4] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: Some("a"), ty: t3 },
                            v2: VariableMeta { name: Some("b"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Diff x ( Mul a b ) ) ( Add ( Mul a ( Diff x b ) ) ( Mul b ( Diff x a ) ) ) )",
                        atoms: [
                            Premise { relation: Diff, columns: [x, v3, v4] },
                            Premise { relation: Mul, columns: [a, b, v3] },
                            Action { relation: Diff, columns: [x, a, v7], entry: [_, _, U] },
                            Action { relation: Diff, columns: [x, b, v5], entry: [_, _, U] },
                            Action { relation: Add, columns: [v6, v8, v4], entry: [_, _, U] },
                            Action { relation: Add, columns: [v8, v6, v4] },
                            Action { relation: Mul, columns: [a, v5, v6], entry: [_, _, U] },
                            Action { relation: Mul, columns: [b, v7, v8], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v5, a, v6] },
                            Action { relation: Mul, columns: [v7, b, v8] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: Some("a"), ty: t3 },
                            v2: VariableMeta { name: Some("b"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                            v7: VariableMeta { name: None, ty: t3 },
                            v8: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Diff x ( Sin x ) ) ( Cos x ) )",
                        atoms: [
                            Premise { relation: Diff, columns: [x, v1, v2] },
                            Premise { relation: Sin, columns: [x, v1] },
                            Action { relation: Cos, columns: [x, v2], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("x"), ty: t3 },
                            v1: VariableMeta { name: None, ty: t3 },
                            v2: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v3, x, v5] },
                            Premise { relation: Const, columns: [v2, v3] },
                            Premise { relation: g2, columns: [v2] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: None, ty: t0 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: Some("x"), ty: t3 },
                            v5: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [
                            [v5, x],
                        ],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Cos x ) x ) ( Sin x ) )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v3, x, v4] },
                            Premise { relation: Cos, columns: [x, v3] },
                            Action { relation: Sin, columns: [x, v4], entry: [_, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: Some("x"), ty: t3 },
                            v3: VariableMeta { name: None, ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Add f g ) x ) ( Add ( Integral fuel f x ) ( Integral fuel g x ) ) )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v4, x, v6] },
                            Premise { relation: Add, columns: [f, g, v4] },
                            Action { relation: Integral, columns: [fuel, f, x, v7], entry: [_, _, _, U] },
                            Action { relation: Integral, columns: [fuel, g, x, v8], entry: [_, _, _, U] },
                            Action { relation: Add, columns: [v7, v8, v6], entry: [_, _, U] },
                            Action { relation: Add, columns: [v8, v7, v6] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: Some("f"), ty: t3 },
                            v3: VariableMeta { name: Some("g"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: Some("x"), ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                            v7: VariableMeta { name: None, ty: t3 },
                            v8: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Sub f g ) x ) ( Sub ( Integral fuel f x ) ( Integral fuel g x ) ) )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v4, x, v6] },
                            Premise { relation: Sub, columns: [f, g, v4] },
                            Action { relation: Integral, columns: [fuel, f, x, v7], entry: [_, _, _, U] },
                            Action { relation: Integral, columns: [fuel, g, x, v8], entry: [_, _, _, U] },
                            Action { relation: Sub, columns: [v7, v8, v6], entry: [_, _, U] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: Some("f"), ty: t3 },
                            v3: VariableMeta { name: Some("g"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: Some("x"), ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                            v7: VariableMeta { name: None, ty: t3 },
                            v8: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                    SymbolicRule {
                        src: "( rewrite ( Integral ( Fuel fuel ) ( Mul a b ) x ) ( Sub ( Mul a ( Integral fuel b x ) ) ( Integral fuel ( Mul ( Diff x a ) ( Integral fuel b x ) ) x ) ) )",
                        atoms: [
                            Premise { relation: Fuel, columns: [fuel, v1] },
                            Premise { relation: Integral, columns: [v1, v4, x, v6] },
                            Premise { relation: Mul, columns: [a, b, v4] },
                            Action { relation: Diff, columns: [x, a, v9], entry: [_, _, U] },
                            Action { relation: Integral, columns: [fuel, b, x, v7], entry: [_, _, _, U] },
                            Action { relation: Integral, columns: [fuel, v10, x, v11], entry: [_, _, _, U] },
                            Action { relation: Sub, columns: [v8, v11, v6], entry: [_, _, U] },
                            Action { relation: Mul, columns: [a, v7, v8], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v7, a, v8] },
                            Action { relation: Mul, columns: [v7, v9, v10], entry: [_, _, U] },
                            Action { relation: Mul, columns: [v9, v7, v10] },
                        ],
                        variables: {
                            v0: VariableMeta { name: Some("fuel"), ty: t2 },
                            v1: VariableMeta { name: None, ty: t2 },
                            v2: VariableMeta { name: Some("a"), ty: t3 },
                            v3: VariableMeta { name: Some("b"), ty: t3 },
                            v4: VariableMeta { name: None, ty: t3 },
                            v5: VariableMeta { name: Some("x"), ty: t3 },
                            v6: VariableMeta { name: None, ty: t3 },
                            v7: VariableMeta { name: None, ty: t3 },
                            v8: VariableMeta { name: None, ty: t3 },
                            v9: VariableMeta { name: None, ty: t3 },
                            v10: VariableMeta { name: None, ty: t3 },
                            v11: VariableMeta { name: None, ty: t3 },
                        },
                        unify: [],
                    },
                ],
                relations: {
                    r0: Fuel { columns: [FuelUnit, FuelUnit], kind: Table, implicit_rules: {n0: [_, U]} },
                    r1: ZeroFuel { columns: [FuelUnit], kind: Table, implicit_rules: {n0: [U]} },
                    r2: Diff { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r3: Integral { columns: [FuelUnit, Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, _, U]} },
                    r4: Add { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]}, invariant_permutations: {[0, 1, 2], [1, 0, 2]} },
                    r5: Sub { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r6: Mul { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]}, invariant_permutations: {[0, 1, 2], [1, 0, 2]} },
                    r7: Div { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r8: Pow { columns: [Math, Math, Math], kind: Table, implicit_rules: {n0: [_, _, U]} },
                    r9: Ln { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r10: Sqrt { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r11: Sin { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r12: Cos { columns: [Math, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r13: Const { columns: [i64, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r14: Var { columns: [String, Math], kind: Table, implicit_rules: {n0: [_, U]} },
                    r15: g0 { columns: [i64], kind: Global(g0), implicit_rules: {n0: [!]} },
                    r16: g1 { columns: [i64], kind: Global(g1), implicit_rules: {n0: [!]} },
                    r17: g2 { columns: [i64], kind: Global(g2), implicit_rules: {n0: [!]} },
                    r18: g3 { columns: [i64], kind: Global(g3), implicit_rules: {n0: [!]} },
                    r19: g4 { columns: [FuelUnit], kind: Global(g4), implicit_rules: {n0: [!]} },
                    r20: g5 { columns: [FuelUnit], kind: Global(g5), implicit_rules: {n0: [!]} },
                    r21: g6 { columns: [FuelUnit], kind: Global(g6), implicit_rules: {n0: [!]} },
                    r22: fuel3 { columns: [FuelUnit], kind: Global(g7), implicit_rules: {n0: [!]} },
                    r23: g8 { columns: [String], kind: Global(g8), implicit_rules: {n0: [!]} },
                    r24: g9 { columns: [Math], kind: Global(g9), implicit_rules: {n0: [!]} },
                    r25: g10 { columns: [Math], kind: Global(g10), implicit_rules: {n0: [!]} },
                    r26: g11 { columns: [Math], kind: Global(g11), implicit_rules: {n0: [!]} },
                    r27: g12 { columns: [Math], kind: Global(g12), implicit_rules: {n0: [!]} },
                    r28: g13 { columns: [Math], kind: Global(g13), implicit_rules: {n0: [!]} },
                    r29: g14 { columns: [Math], kind: Global(g14), implicit_rules: {n0: [!]} },
                    r30: g15 { columns: [Math], kind: Global(g15), implicit_rules: {n0: [!]} },
                    r31: g16 { columns: [Math], kind: Global(g16), implicit_rules: {n0: [!]} },
                    r32: g17 { columns: [Math], kind: Global(g17), implicit_rules: {n0: [!]} },
                    r33: g18 { columns: [Math], kind: Global(g18), implicit_rules: {n0: [!]} },
                    r34: g19 { columns: [Math], kind: Global(g19), implicit_rules: {n0: [!]} },
                    r35: g20 { columns: [Math], kind: Global(g20), implicit_rules: {n0: [!]} },
                    r36: g21 { columns: [Math], kind: Global(g21), implicit_rules: {n0: [!]} },
                    r37: g22 { columns: [i64], kind: Global(g22), implicit_rules: {n0: [!]} },
                    r38: g23 { columns: [Math], kind: Global(g23), implicit_rules: {n0: [!]} },
                    r39: g24 { columns: [Math], kind: Global(g24), implicit_rules: {n0: [!]} },
                    r40: g25 { columns: [i64], kind: Global(g25), implicit_rules: {n0: [!]} },
                    r41: g26 { columns: [Math], kind: Global(g26), implicit_rules: {n0: [!]} },
                    r42: g27 { columns: [Math], kind: Global(g27), implicit_rules: {n0: [!]} },
                    r43: g28 { columns: [Math], kind: Global(g28), implicit_rules: {n0: [!]} },
                    r44: g29 { columns: [Math], kind: Global(g29), implicit_rules: {n0: [!]} },
                    r45: g30 { columns: [Math], kind: Global(g30), implicit_rules: {n0: [!]} },
                    r46: g31 { columns: [String], kind: Global(g31), implicit_rules: {n0: [!]} },
                    r47: g32 { columns: [Math], kind: Global(g32), implicit_rules: {n0: [!]} },
                    r48: g33 { columns: [Math], kind: Global(g33), implicit_rules: {n0: [!]} },
                    r49: g34 { columns: [Math], kind: Global(g34), implicit_rules: {n0: [!]} },
                    r50: g35 { columns: [Math], kind: Global(g35), implicit_rules: {n0: [!]} },
                    r51: g36 { columns: [Math], kind: Global(g36), implicit_rules: {n0: [!]} },
                    r52: g37 { columns: [Math], kind: Global(g37), implicit_rules: {n0: [!]} },
                    r53: g38 { columns: [Math], kind: Global(g38), implicit_rules: {n0: [!]} },
                    r54: g39 { columns: [String], kind: Global(g39), implicit_rules: {n0: [!]} },
                    r55: g40 { columns: [Math], kind: Global(g40), implicit_rules: {n0: [!]} },
                    r56: g41 { columns: [Math], kind: Global(g41), implicit_rules: {n0: [!]} },
                    r57: g42 { columns: [Math], kind: Global(g42), implicit_rules: {n0: [!]} },
                    r58: g43 { columns: [Math], kind: Global(g43), implicit_rules: {n0: [!]} },
                    r59: g44 { columns: [Math], kind: Global(g44), implicit_rules: {n0: [!]} },
                    r60: g45 { columns: [Math], kind: Global(g45), implicit_rules: {n0: [!]} },
                    r61: g46 { columns: [Math], kind: Global(g46), implicit_rules: {n0: [!]} },
                    r62: g47 { columns: [Math], kind: Global(g47), implicit_rules: {n0: [!]} },
                },
            }"#]]),
        expected_tir: None,
        expected_lir: Some(expect![[r#"
            Theory {
                name: None,
                types: {
                    [t0, i64]: std::primitive::i64,
                    [t1, String]: runtime::IString,
                    [t2, FuelUnit]: [symbolic],
                    [t3, Math]: [symbolic],
                },
                relations: {
                    r0: RelationData {
                        name: "Fuel",
                        param_types: {c0: t2, c1: t2},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union, ir1: 1=>0},
                        },
                    },
                    r1: RelationData {
                        name: "ZeroFuel",
                        param_types: {c0: t2},
                        kind: Table {
                            index_to_info: {ir0: =>0:union},
                        },
                    },
                    r2: RelationData {
                        name: "Diff",
                        param_types: {c0: t3, c1: t3, c2: t3},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 1=>0_2},
                        },
                    },
                    r3: RelationData {
                        name: "Integral",
                        param_types: {c0: t2, c1: t3, c2: t3, c3: t3},
                        kind: Table {
                            index_to_info: {ir0: 0_1_2=>3:union, ir1: 0=>1_2_3, ir2: 0_1=>2_3, ir3: 1=>0_2_3, ir4: 1_2=>0_3},
                        },
                    },
                    r4: RelationData {
                        name: "Add",
                        param_types: {c0: t3, c1: t3, c2: t3},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2, ir2: 2=>0_1},
                        },
                    },
                    r5: RelationData {
                        name: "Sub",
                        param_types: {c0: t3, c1: t3, c2: t3},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 2=>0_1},
                        },
                    },
                    r6: RelationData {
                        name: "Mul",
                        param_types: {c0: t3, c1: t3, c2: t3},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2, ir2: 0_2=>1, ir3: 2=>0_1},
                        },
                    },
                    r7: RelationData {
                        name: "Div",
                        param_types: {c0: t3, c1: t3, c2: t3},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union},
                        },
                    },
                    r8: RelationData {
                        name: "Pow",
                        param_types: {c0: t3, c1: t3, c2: t3},
                        kind: Table {
                            index_to_info: {ir0: 0_1=>2:union, ir1: 0=>1_2, ir2: 0_2=>1, ir3: 1=>0_2, ir4: 2=>0_1},
                        },
                    },
                    r9: RelationData {
                        name: "Ln",
                        param_types: {c0: t3, c1: t3},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union},
                        },
                    },
                    r10: RelationData {
                        name: "Sqrt",
                        param_types: {c0: t3, c1: t3},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union},
                        },
                    },
                    r11: RelationData {
                        name: "Sin",
                        param_types: {c0: t3, c1: t3},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union (check: {{0, 1}})},
                        },
                    },
                    r12: RelationData {
                        name: "Cos",
                        param_types: {c0: t3, c1: t3},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union (check: {{0, 1}})},
                        },
                    },
                    r13: RelationData {
                        name: "Const",
                        param_types: {c0: t0, c1: t3},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union (check: {{0, 1}})},
                        },
                    },
                    r14: RelationData {
                        name: "Var",
                        param_types: {c0: t1, c1: t3},
                        kind: Table {
                            index_to_info: {ir0: 0=>1:union},
                        },
                    },
                    r15: RelationData {
                        name: "g0",
                        param_types: {c0: t0},
                        kind: [Global, g0],
                    },
                    r16: RelationData {
                        name: "g1",
                        param_types: {c0: t0},
                        kind: [Global, g1],
                    },
                    r17: RelationData {
                        name: "g2",
                        param_types: {c0: t0},
                        kind: [Global, g2],
                    },
                    r18: RelationData {
                        name: "g3",
                        param_types: {c0: t0},
                        kind: [Global, g3],
                    },
                    r19: RelationData {
                        name: "g4",
                        param_types: {c0: t2},
                        kind: [Global, g4],
                    },
                    r20: RelationData {
                        name: "g5",
                        param_types: {c0: t2},
                        kind: [Global, g5],
                    },
                    r21: RelationData {
                        name: "g6",
                        param_types: {c0: t2},
                        kind: [Global, g6],
                    },
                    r22: RelationData {
                        name: "g7",
                        param_types: {c0: t2},
                        kind: [Global, g7],
                    },
                    r23: RelationData {
                        name: "g8",
                        param_types: {c0: t1},
                        kind: [Global, g8],
                    },
                    r24: RelationData {
                        name: "g9",
                        param_types: {c0: t3},
                        kind: [Global, g9],
                    },
                    r25: RelationData {
                        name: "g10",
                        param_types: {c0: t3},
                        kind: [Global, g10],
                    },
                    r26: RelationData {
                        name: "g11",
                        param_types: {c0: t3},
                        kind: [Global, g11],
                    },
                    r27: RelationData {
                        name: "g12",
                        param_types: {c0: t3},
                        kind: [Global, g12],
                    },
                    r28: RelationData {
                        name: "g13",
                        param_types: {c0: t3},
                        kind: [Global, g13],
                    },
                    r29: RelationData {
                        name: "g14",
                        param_types: {c0: t3},
                        kind: [Global, g14],
                    },
                    r30: RelationData {
                        name: "g15",
                        param_types: {c0: t3},
                        kind: [Global, g15],
                    },
                    r31: RelationData {
                        name: "g16",
                        param_types: {c0: t3},
                        kind: [Global, g16],
                    },
                    r32: RelationData {
                        name: "g17",
                        param_types: {c0: t3},
                        kind: [Global, g17],
                    },
                    r33: RelationData {
                        name: "g18",
                        param_types: {c0: t3},
                        kind: [Global, g18],
                    },
                    r34: RelationData {
                        name: "g19",
                        param_types: {c0: t3},
                        kind: [Global, g19],
                    },
                    r35: RelationData {
                        name: "g20",
                        param_types: {c0: t3},
                        kind: [Global, g20],
                    },
                    r36: RelationData {
                        name: "g21",
                        param_types: {c0: t3},
                        kind: [Global, g21],
                    },
                    r37: RelationData {
                        name: "g22",
                        param_types: {c0: t0},
                        kind: [Global, g22],
                    },
                    r38: RelationData {
                        name: "g23",
                        param_types: {c0: t3},
                        kind: [Global, g23],
                    },
                    r39: RelationData {
                        name: "g24",
                        param_types: {c0: t3},
                        kind: [Global, g24],
                    },
                    r40: RelationData {
                        name: "g25",
                        param_types: {c0: t0},
                        kind: [Global, g25],
                    },
                    r41: RelationData {
                        name: "g26",
                        param_types: {c0: t3},
                        kind: [Global, g26],
                    },
                    r42: RelationData {
                        name: "g27",
                        param_types: {c0: t3},
                        kind: [Global, g27],
                    },
                    r43: RelationData {
                        name: "g28",
                        param_types: {c0: t3},
                        kind: [Global, g28],
                    },
                    r44: RelationData {
                        name: "g29",
                        param_types: {c0: t3},
                        kind: [Global, g29],
                    },
                    r45: RelationData {
                        name: "g30",
                        param_types: {c0: t3},
                        kind: [Global, g30],
                    },
                    r46: RelationData {
                        name: "g31",
                        param_types: {c0: t1},
                        kind: [Global, g31],
                    },
                    r47: RelationData {
                        name: "g32",
                        param_types: {c0: t3},
                        kind: [Global, g32],
                    },
                    r48: RelationData {
                        name: "g33",
                        param_types: {c0: t3},
                        kind: [Global, g33],
                    },
                    r49: RelationData {
                        name: "g34",
                        param_types: {c0: t3},
                        kind: [Global, g34],
                    },
                    r50: RelationData {
                        name: "g35",
                        param_types: {c0: t3},
                        kind: [Global, g35],
                    },
                    r51: RelationData {
                        name: "g36",
                        param_types: {c0: t3},
                        kind: [Global, g36],
                    },
                    r52: RelationData {
                        name: "g37",
                        param_types: {c0: t3},
                        kind: [Global, g37],
                    },
                    r53: RelationData {
                        name: "g38",
                        param_types: {c0: t3},
                        kind: [Global, g38],
                    },
                    r54: RelationData {
                        name: "g39",
                        param_types: {c0: t1},
                        kind: [Global, g39],
                    },
                    r55: RelationData {
                        name: "g40",
                        param_types: {c0: t3},
                        kind: [Global, g40],
                    },
                    r56: RelationData {
                        name: "g41",
                        param_types: {c0: t3},
                        kind: [Global, g41],
                    },
                    r57: RelationData {
                        name: "g42",
                        param_types: {c0: t3},
                        kind: [Global, g42],
                    },
                    r58: RelationData {
                        name: "g43",
                        param_types: {c0: t3},
                        kind: [Global, g43],
                    },
                    r59: RelationData {
                        name: "g44",
                        param_types: {c0: t3},
                        kind: [Global, g44],
                    },
                    r60: RelationData {
                        name: "g45",
                        param_types: {c0: t3},
                        kind: [Global, g45],
                    },
                    r61: RelationData {
                        name: "g46",
                        param_types: {c0: t3},
                        kind: [Global, g46],
                    },
                    r62: RelationData {
                        name: "g47",
                        param_types: {c0: t3},
                        kind: [Global, g47],
                    },
                },
                rule_variables: {
                    [v0, qfuel]: t2,
                    [v1, qx]: t3,
                    [v10, qv10]: t3,
                    [v100, qc_5]: t3,
                    [v101, qv101]: t3,
                    [v102, qv102]: t3,
                    [v103, qv103]: t3,
                    [v104, qv104]: t3,
                    [v105, qa_18]: t3,
                    [v106, qb_9]: t3,
                    [v107, qc_6]: t3,
                    [v108, qv108]: t3,
                    [v109, qv109]: t3,
                    [v11, qv11]: t0,
                    [v110, qv110]: t3,
                    [v111, qv111]: t3,
                    [v112, qa_19]: t3,
                    [v113, qb_10]: t3,
                    [v114, qv114]: t3,
                    [v115, qc_7]: t3,
                    [v116, qv116]: t3,
                    [v117, qv117]: t3,
                    [v118, qv118]: t3,
                    [v119, qa_20]: t3,
                    [v12, qv12]: t3,
                    [v120, qb_11]: t3,
                    [v121, qv121]: t3,
                    [v122, qc_8]: t3,
                    [v123, qv123]: t3,
                    [v124, qv124]: t3,
                    [v125, qv125]: t3,
                    [v126, qa_21]: t3,
                    [v127, qb_12]: t3,
                    [v128, qv128]: t3,
                    [v129, qc_9]: t3,
                    [v13, qv13]: t3,
                    [v130, qv130]: t3,
                    [v131, qv131]: t3,
                    [v132, qv132]: t3,
                    [v133, qa_22]: t3,
                    [v134, qb_13]: t3,
                    [v135, qv135]: t3,
                    [v136, qc_10]: t3,
                    [v137, qv137]: t3,
                    [v138, qv138]: t3,
                    [v139, qv139]: t3,
                    [v14, qa]: t3,
                    [v140, qx_5]: t3,
                    [v141, qv141]: t0,
                    [v142, qv142]: t3,
                    [v143, qv143]: t3,
                    [v144, qx_6]: t3,
                    [v145, qv145]: t0,
                    [v146, qv146]: t3,
                    [v147, qv147]: t3,
                    [v148, qx_7]: t3,
                    [v149, qv149]: t0,
                    [v15, qb]: t3,
                    [v150, qv150]: t3,
                    [v151, qv151]: t3,
                    [v152, qx_8]: t3,
                    [v153, qv153]: t0,
                    [v154, qv154]: t3,
                    [v155, qv155]: t3,
                    [v156, qx_9]: t3,
                    [v157, qv157]: t0,
                    [v158, qv158]: t3,
                    [v159, qv159]: t3,
                    [v16, qv16]: t3,
                    [v160, qx_10]: t3,
                    [v161, qv161]: t0,
                    [v162, qv162]: t3,
                    [v163, qv163]: t3,
                    [v164, qx_11]: t3,
                    [v165, qa_23]: t3,
                    [v166, qb_14]: t3,
                    [v167, qv167]: t3,
                    [v168, qv168]: t3,
                    [v169, qv169]: t3,
                    [v17, qv17]: t0,
                    [v170, qv170]: t3,
                    [v171, qx_12]: t3,
                    [v172, qa_24]: t3,
                    [v173, qb_15]: t3,
                    [v174, qv174]: t3,
                    [v175, qv175]: t3,
                    [v176, qv176]: t3,
                    [v177, qv177]: t3,
                    [v178, qx_13]: t3,
                    [v179, qa_25]: t3,
                    [v18, qv18]: t3,
                    [v180, qb_16]: t3,
                    [v181, qv181]: t3,
                    [v182, qv182]: t3,
                    [v183, qv183]: t3,
                    [v184, qv184]: t3,
                    [v185, qv185]: t3,
                    [v186, qv186]: t3,
                    [v187, qx_14]: t3,
                    [v188, qa_26]: t3,
                    [v189, qb_17]: t3,
                    [v19, qv19]: t3,
                    [v190, qv190]: t3,
                    [v191, qv191]: t3,
                    [v192, qv192]: t3,
                    [v193, qv193]: t3,
                    [v194, qv194]: t3,
                    [v195, qv195]: t3,
                    [v196, qx_15]: t3,
                    [v197, qv197]: t3,
                    [v198, qv198]: t3,
                    [v199, qx_16]: t3,
                    [v2, qv2]: t3,
                    [v20, qx_3]: t3,
                    [v200, qv200]: t3,
                    [v201, qv201]: t3,
                    [v202, qfuel_3]: t2,
                    [v203, qv203]: t2,
                    [v204, qv204]: t0,
                    [v205, qv205]: t3,
                    [v206, qx_17]: t3,
                    [v207, qv207]: t3,
                    [v208, qfuel_4]: t2,
                    [v209, qv209]: t2,
                    [v21, qv21]: t3,
                    [v210, qv210]: t0,
                    [v211, qv211]: t3,
                    [v212, qx_18]: t3,
                    [v213, qv213]: t3,
                    [v214, qfuel_5]: t2,
                    [v215, qv215]: t2,
                    [v216, qv216]: t0,
                    [v217, qv217]: t3,
                    [v218, qx_19]: t3,
                    [v219, qv219]: t3,
                    [v22, qv22]: t3,
                    [v220, qfuel_6]: t2,
                    [v221, qv221]: t2,
                    [v222, qv222]: t0,
                    [v223, qv223]: t3,
                    [v224, qx_20]: t3,
                    [v225, qv225]: t3,
                    [v226, qfuel_7]: t2,
                    [v227, qv227]: t2,
                    [v228, qx_21]: t3,
                    [v229, qv229]: t3,
                    [v23, qv23]: t0,
                    [v230, qv230]: t3,
                    [v231, qfuel_8]: t2,
                    [v232, qv232]: t2,
                    [v233, qx_22]: t3,
                    [v234, qv234]: t3,
                    [v235, qv235]: t3,
                    [v236, qfuel_9]: t2,
                    [v237, qv237]: t2,
                    [v238, qx_23]: t3,
                    [v239, qv239]: t3,
                    [v24, qv24]: t3,
                    [v240, qv240]: t3,
                    [v241, qfuel_10]: t2,
                    [v242, qv242]: t2,
                    [v243, qf]: t3,
                    [v244, qg]: t3,
                    [v245, qv245]: t3,
                    [v246, qx_24]: t3,
                    [v247, qv247]: t3,
                    [v248, qv248]: t3,
                    [v249, qv249]: t3,
                    [v25, qv25]: t3,
                    [v250, qfuel_11]: t2,
                    [v251, qv251]: t2,
                    [v252, qf_2]: t3,
                    [v253, qg_2]: t3,
                    [v254, qv254]: t3,
                    [v255, qx_25]: t3,
                    [v256, qv256]: t3,
                    [v257, qv257]: t3,
                    [v258, qv258]: t3,
                    [v259, qfuel_12]: t2,
                    [v26, qx_4]: t3,
                    [v260, qv260]: t2,
                    [v261, qf_3]: t3,
                    [v262, qg_3]: t3,
                    [v263, qv263]: t3,
                    [v264, qx_26]: t3,
                    [v265, qv265]: t3,
                    [v266, qv266]: t3,
                    [v267, qv267]: t3,
                    [v268, qfuel_13]: t2,
                    [v269, qv269]: t2,
                    [v27, qv27]: t3,
                    [v270, qf_4]: t3,
                    [v271, qg_4]: t3,
                    [v272, qv272]: t3,
                    [v273, qx_27]: t3,
                    [v274, qv274]: t3,
                    [v275, qv275]: t3,
                    [v276, qv276]: t3,
                    [v277, qfuel_14]: t2,
                    [v278, qv278]: t2,
                    [v279, qf_5]: t3,
                    [v28, qv28]: t3,
                    [v280, qg_5]: t3,
                    [v281, qv281]: t3,
                    [v282, qx_28]: t3,
                    [v283, qv283]: t3,
                    [v284, qv284]: t3,
                    [v285, qv285]: t3,
                    [v286, qfuel_15]: t2,
                    [v287, qv287]: t2,
                    [v288, qf_6]: t3,
                    [v289, qg_6]: t3,
                    [v29, qv29]: t0,
                    [v290, qv290]: t3,
                    [v291, qx_29]: t3,
                    [v292, qv292]: t3,
                    [v293, qv293]: t3,
                    [v294, qv294]: t3,
                    [v295, qfuel_16]: t2,
                    [v296, qv296]: t2,
                    [v297, qa_27]: t3,
                    [v298, qb_18]: t3,
                    [v299, qv299]: t3,
                    [v3, qv3]: t3,
                    [v30, qv30]: t3,
                    [v300, qx_30]: t3,
                    [v301, qv301]: t3,
                    [v302, qv302]: t3,
                    [v303, qv303]: t3,
                    [v304, qv304]: t3,
                    [v305, qv305]: t3,
                    [v306, qv306]: t3,
                    [v307, qfuel_17]: t2,
                    [v308, qv308]: t2,
                    [v309, qa_28]: t3,
                    [v31, qv31]: t3,
                    [v310, qb_19]: t3,
                    [v311, qv311]: t3,
                    [v312, qx_31]: t3,
                    [v313, qv313]: t3,
                    [v314, qv314]: t3,
                    [v315, qv315]: t3,
                    [v316, qv316]: t3,
                    [v317, qv317]: t3,
                    [v318, qv318]: t3,
                    [v319, qfuel_18]: t2,
                    [v32, qa_2]: t3,
                    [v320, qv320]: t2,
                    [v321, qa_29]: t3,
                    [v322, qb_20]: t3,
                    [v323, qv323]: t3,
                    [v324, qx_32]: t3,
                    [v325, qv325]: t3,
                    [v326, qv326]: t3,
                    [v327, qv327]: t3,
                    [v328, qv328]: t3,
                    [v329, qv329]: t3,
                    [v33, qb_2]: t3,
                    [v330, qv330]: t3,
                    [v34, qv34]: t3,
                    [v35, qa_3]: t3,
                    [v36, qb_3]: t3,
                    [v37, qv37]: t3,
                    [v38, qa_4]: t3,
                    [v39, qb_4]: t3,
                    [v4, qv4]: t0,
                    [v40, qc]: t3,
                    [v41, qv41]: t3,
                    [v42, qv42]: t3,
                    [v43, qv43]: t3,
                    [v44, qa_5]: t3,
                    [v45, qb_5]: t3,
                    [v46, qc_2]: t3,
                    [v47, qv47]: t3,
                    [v48, qv48]: t3,
                    [v49, qv49]: t3,
                    [v5, qv5]: t3,
                    [v50, qa_6]: t3,
                    [v51, qb_6]: t3,
                    [v52, qc_3]: t3,
                    [v53, qv53]: t3,
                    [v54, qv54]: t3,
                    [v55, qv55]: t3,
                    [v56, qa_7]: t3,
                    [v57, qb_7]: t3,
                    [v58, qc_4]: t3,
                    [v59, qv59]: t3,
                    [v6, qv6]: t3,
                    [v60, qv60]: t3,
                    [v61, qv61]: t3,
                    [v62, qa_8]: t3,
                    [v63, qv63]: t0,
                    [v64, qv64]: t3,
                    [v65, qv65]: t3,
                    [v66, qa_9]: t3,
                    [v67, qv67]: t0,
                    [v68, qv68]: t3,
                    [v69, qv69]: t3,
                    [v7, qfuel_2]: t2,
                    [v70, qa_10]: t3,
                    [v71, qv71]: t0,
                    [v72, qv72]: t3,
                    [v73, qv73]: t3,
                    [v74, qa_11]: t3,
                    [v75, qv75]: t0,
                    [v76, qv76]: t3,
                    [v77, qv77]: t3,
                    [v78, qa_12]: t3,
                    [v79, qv79]: t0,
                    [v8, qx_2]: t3,
                    [v80, qv80]: t3,
                    [v81, qv81]: t3,
                    [v82, qa_13]: t3,
                    [v83, qv83]: t0,
                    [v84, qv84]: t3,
                    [v85, qv85]: t3,
                    [v86, qa_14]: t3,
                    [v87, qv87]: t0,
                    [v88, qv88]: t3,
                    [v89, qv89]: t3,
                    [v9, qv9]: t3,
                    [v90, qa_15]: t3,
                    [v91, qv91]: t0,
                    [v92, qv92]: t3,
                    [v93, qv93]: t3,
                    [v94, qa_16]: t3,
                    [v95, qv95]: t0,
                    [v96, qv96]: t3,
                    [v97, qv97]: t3,
                    [v98, qa_17]: t3,
                    [v99, qb_8]: t3,
                },
                global_variable_types: {
                    g0: t0,
                    g1: t0,
                    g2: t0,
                    g3: t0,
                    g4: t2,
                    g5: t2,
                    g6: t2,
                    g7: t2,
                    g8: t1,
                    g9: t3,
                    g10: t3,
                    g11: t3,
                    g12: t3,
                    g13: t3,
                    g14: t3,
                    g15: t3,
                    g16: t3,
                    g17: t3,
                    g18: t3,
                    g19: t3,
                    g20: t3,
                    g21: t3,
                    g22: t0,
                    g23: t3,
                    g24: t3,
                    g25: t0,
                    g26: t3,
                    g27: t3,
                    g28: t3,
                    g29: t3,
                    g30: t3,
                    g31: t1,
                    g32: t3,
                    g33: t3,
                    g34: t3,
                    g35: t3,
                    g36: t3,
                    g37: t3,
                    g38: t3,
                    g39: t1,
                    g40: t3,
                    g41: t3,
                    g42: t3,
                    g43: t3,
                    g44: t3,
                    g45: t3,
                    g46: t3,
                    g47: t3,
                },
                rule_tries: [
                    premise: [IterNew, r0(v202, v203)]
                    then: [
                        premise: [JoinAll, r3(v203, v229, v228, v230), ir1]
                        then: [
                            premise: [JoinAll, r4(v243, v244, v229), ir2]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Add f g ) x ) ( Add ( Integral fuel f x ) ( Integral fuel g x ) ) )"
                            actions: [
                                [Action::Entry, r3(v202, v244, v228, v249) on ir0],
                                [Action::Entry, r3(v202, v243, v228, v248) on ir0],
                                [Action::Insert, r4(v248, v249, v230)],
                                [Action::Insert, r4(v249, v248, v230)],
                            ],
                            premise: [JoinAll, r5(v270, v271, v229), ir1]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Sub f g ) x ) ( Sub ( Integral fuel f x ) ( Integral fuel g x ) ) )"
                            actions: [
                                [Action::Entry, r3(v202, v271, v228, v276) on ir0],
                                [Action::Entry, r3(v202, v270, v228, v275) on ir0],
                                [Action::Insert, r5(v275, v276, v230)],
                            ],
                            premise: [JoinAll, r6(v297, v298, v229), ir3]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Mul a b ) x ) ( Sub ( Mul a ( Integral fuel b x ) ) ( Integral fuel ( Mul ( Diff x a ) ( Integral fuel b x ) ) x ) ) )"
                            actions: [
                                [Action::Entry, r3(v202, v298, v228, v302) on ir0],
                                [Action::Entry, r6(v297, v302, v303) on ir0],
                                [Action::Insert, r6(v302, v297, v303)],
                                [Action::Entry, r2(v228, v297, v304) on ir0],
                                [Action::Entry, r6(v302, v304, v305) on ir0],
                                [Action::Insert, r6(v304, v302, v305)],
                                [Action::Entry, r3(v202, v305, v228, v306) on ir0],
                                [Action::Insert, r5(v303, v306, v230)],
                            ],
                            premise: [SemiJoin, r12(v228, v229), ir0]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Cos x ) x ) ( Sin x ) )"
                            actions: [
                                [Action::Insert, r11(v228, v230)],
                            ],
                        ],
                        premise: [JoinAll, r17(v204), ir_bogus]
                        then: [
                            premise: [JoinAll, r13(v204, v205), ir0]
                            then: [
                                premise: [JoinAll, r3(v203, v205, v206, v207), ir2]
                                meta: "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )"
                                actions: [
                                    [Action::Equate, v206=v207],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r2(v20, v21, v22)]
                    then: [
                        premise: [JoinAll, r4(v165, v166, v21), ir2]
                        meta: "( rewrite ( Diff x ( Add a b ) ) ( Add ( Diff x a ) ( Diff x b ) ) )"
                        actions: [
                            [Action::Entry, r2(v20, v166, v170) on ir0],
                            [Action::Entry, r2(v20, v165, v169) on ir0],
                            [Action::Insert, r4(v169, v170, v22)],
                            [Action::Insert, r4(v170, v169, v22)],
                        ],
                        premise: [JoinAll, r6(v179, v180, v21), ir3]
                        meta: "( rewrite ( Diff x ( Mul a b ) ) ( Add ( Mul a ( Diff x b ) ) ( Mul b ( Diff x a ) ) ) )"
                        actions: [
                            [Action::Entry, r2(v20, v180, v183) on ir0],
                            [Action::Entry, r6(v179, v183, v184) on ir0],
                            [Action::Insert, r6(v183, v179, v184)],
                            [Action::Entry, r2(v20, v179, v185) on ir0],
                            [Action::Entry, r6(v180, v185, v186) on ir0],
                            [Action::Insert, r4(v184, v186, v22)],
                            [Action::Insert, r4(v186, v184, v22)],
                            [Action::Insert, r6(v185, v180, v186)],
                        ],
                        premise: [SemiJoin, r11(v20, v21), ir0]
                        meta: "( rewrite ( Diff x ( Sin x ) ) ( Cos x ) )"
                        actions: [
                            [Action::Insert, r12(v20, v22)],
                        ],
                        premise: [SemiJoin, r12(v20, v21), ir0]
                        meta: "( rewrite ( Diff x ( Cos x ) ) ( Mul ( Const -1 ) ( Sin x ) ) )"
                        actions: [
                            [Action::Entry, r15(v23) on ir_bogus],
                            [Action::Entry, r13(v23, v24) on ir0],
                            [Action::Entry, r11(v20, v25) on ir0],
                            [Action::Insert, r6(v24, v25, v22)],
                            [Action::Insert, r6(v25, v24, v22)],
                        ],
                    ],
                    premise: [IterNew, r3(v0, v2, v1, v3)]
                    then: [
                        premise: [SemiJoin, r11(v1, v2), ir0]
                        meta: "( rewrite ( Integral fuel ( Sin x ) x ) ( Mul ( Const -1 ) ( Cos x ) ) )"
                        actions: [
                            [Action::Entry, r15(v4) on ir_bogus],
                            [Action::Entry, r13(v4, v5) on ir0],
                            [Action::Entry, r12(v1, v6) on ir0],
                            [Action::Insert, r6(v5, v6, v3)],
                            [Action::Insert, r6(v6, v5, v3)],
                        ],
                        premise: [SemiJoin, r12(v1, v2), ir0]
                        then: [
                            premise: [JoinOld, r0(v231, v0), ir1]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Cos x ) x ) ( Sin x ) )"
                            actions: [
                                [Action::Insert, r11(v1, v3)],
                            ],
                        ],
                        premise: [JoinAll, r17(v210), ir_bogus]
                        then: [
                            premise: [SemiJoin, r13(v210, v2), ir0]
                            then: [
                                premise: [JoinOld, r0(v208, v0), ir1]
                                meta: "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )"
                                actions: [
                                    [Action::Equate, v1=v3],
                                ],
                            ],
                        ],
                        premise: [SemiJoin, r4(v252, v253, v2), ir2]
                        then: [
                            premise: [JoinOld, r0(v250, v0), ir1]
                            then: [
                                premise: [JoinAll, r4(v252, v253, v2), ir2]
                                meta: "( rewrite ( Integral ( Fuel fuel ) ( Add f g ) x ) ( Add ( Integral fuel f x ) ( Integral fuel g x ) ) )"
                                actions: [
                                    [Action::Entry, r3(v250, v253, v1, v258) on ir0],
                                    [Action::Entry, r3(v250, v252, v1, v257) on ir0],
                                    [Action::Insert, r4(v257, v258, v3)],
                                    [Action::Insert, r4(v258, v257, v3)],
                                ],
                            ],
                        ],
                        premise: [SemiJoin, r5(v279, v280, v2), ir1]
                        then: [
                            premise: [JoinOld, r0(v277, v0), ir1]
                            then: [
                                premise: [JoinAll, r5(v279, v280, v2), ir1]
                                meta: "( rewrite ( Integral ( Fuel fuel ) ( Sub f g ) x ) ( Sub ( Integral fuel f x ) ( Integral fuel g x ) ) )"
                                actions: [
                                    [Action::Entry, r3(v277, v280, v1, v285) on ir0],
                                    [Action::Entry, r3(v277, v279, v1, v284) on ir0],
                                    [Action::Insert, r5(v284, v285, v3)],
                                ],
                            ],
                        ],
                        premise: [SemiJoin, r6(v309, v310, v2), ir3]
                        then: [
                            premise: [JoinOld, r0(v307, v0), ir1]
                            then: [
                                premise: [JoinAll, r6(v309, v310, v2), ir3]
                                meta: "( rewrite ( Integral ( Fuel fuel ) ( Mul a b ) x ) ( Sub ( Mul a ( Integral fuel b x ) ) ( Integral fuel ( Mul ( Diff x a ) ( Integral fuel b x ) ) x ) ) )"
                                actions: [
                                    [Action::Entry, r3(v307, v310, v1, v314) on ir0],
                                    [Action::Entry, r6(v309, v314, v315) on ir0],
                                    [Action::Insert, r6(v314, v309, v315)],
                                    [Action::Entry, r2(v1, v309, v316) on ir0],
                                    [Action::Entry, r6(v314, v316, v317) on ir0],
                                    [Action::Insert, r6(v316, v314, v317)],
                                    [Action::Entry, r3(v307, v317, v1, v318) on ir0],
                                    [Action::Insert, r5(v315, v318, v3)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r4(v32, v33, v34)]
                    actions: [
                        [Action::Insert, r4(v32, v33, v34)],
                        [Action::Insert, r4(v33, v32, v34)],
                    ]
                    then: [
                        premise: [JoinOld, r2(v171, v34, v175), ir1]
                        meta: "( rewrite ( Diff x ( Add a b ) ) ( Add ( Diff x a ) ( Diff x b ) ) )"
                        actions: [
                            [Action::Entry, r2(v171, v33, v177) on ir0],
                            [Action::Entry, r2(v171, v32, v176) on ir0],
                            [Action::Insert, r4(v176, v177, v175)],
                            [Action::Insert, r4(v177, v176, v175)],
                        ],
                        premise: [JoinOld, r3(v260, v34, v264, v265), ir3]
                        then: [
                            premise: [JoinOld, r0(v259, v260), ir1]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Add f g ) x ) ( Add ( Integral fuel f x ) ( Integral fuel g x ) ) )"
                            actions: [
                                [Action::Entry, r3(v259, v33, v264, v267) on ir0],
                                [Action::Entry, r3(v259, v32, v264, v266) on ir0],
                                [Action::Insert, r4(v266, v267, v265)],
                                [Action::Insert, r4(v267, v266, v265)],
                            ],
                        ],
                        premise: [JoinAll, r4(v39, v40, v33), ir2]
                        meta: "( rewrite ( Add a ( Add b c ) ) ( Add ( Add a b ) c ) )"
                        actions: [
                            [Action::Entry, r4(v32, v39, v43) on ir0],
                            [Action::Insert, r4(v39, v32, v43)],
                            [Action::Insert, r4(v40, v43, v34)],
                            [Action::Insert, r4(v43, v40, v34)],
                        ],
                        premise: [JoinOld, r4(v34, v44, v48), ir1]
                        meta: "( rewrite ( Add a ( Add b c ) ) ( Add ( Add a b ) c ) )"
                        actions: [
                            [Action::Entry, r4(v44, v32, v49) on ir0],
                            [Action::Insert, r4(v32, v44, v49)],
                            [Action::Insert, r4(v33, v49, v48)],
                            [Action::Insert, r4(v49, v33, v48)],
                        ],
                        premise: [JoinAll, r6(v34, v98, v102), ir1]
                        meta: "( rewrite ( Mul a ( Add b c ) ) ( Add ( Mul a b ) ( Mul a c ) ) )"
                        actions: [
                            [Action::Entry, r6(v98, v33, v104) on ir0],
                            [Action::Insert, r6(v33, v98, v104)],
                            [Action::Entry, r6(v98, v32, v103) on ir0],
                            [Action::Insert, r4(v103, v104, v102)],
                            [Action::Insert, r4(v104, v103, v102)],
                            [Action::Insert, r6(v32, v98, v103)],
                        ],
                        premise: [JoinAll, r16(v63), ir_bogus]
                        then: [
                            premise: [SemiJoin, r13(v63, v33), ir0]
                            meta: "( rewrite ( Add a ( Const 0 ) ) a )"
                            actions: [
                                [Action::Equate, v32=v34],
                            ],
                        ],
                        premise: [SemiJoin, r6(v112, v113, v32), ir3]
                        then: [
                            premise: [JoinAll, r6(v112, v115, v33), ir3]
                            then: [
                                premise: [JoinAll, r6(v112, v113, v32), ir2]
                                meta: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r4(v113, v115, v118) on ir0],
                                    [Action::Insert, r4(v115, v113, v118)],
                                    [Action::Insert, r6(v112, v118, v34)],
                                    [Action::Insert, r6(v118, v112, v34)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r5(v14, v15, v16)]
                    actions: [
                        [Action::Entry, r15(v17) on ir_bogus],
                        [Action::Entry, r13(v17, v18) on ir0],
                        [Action::Entry, r6(v15, v18, v19) on ir0],
                        [Action::Insert, r4(v14, v19, v16)],
                        [Action::Insert, r4(v19, v14, v16)],
                        [Action::Insert, r6(v18, v15, v19)],
                    ]
                    then: [
                        premise: [JoinOld, r3(v287, v16, v291, v292), ir3]
                        then: [
                            premise: [JoinOld, r0(v286, v287), ir1]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Sub f g ) x ) ( Sub ( Integral fuel f x ) ( Integral fuel g x ) ) )"
                            actions: [
                                [Action::Entry, r3(v286, v15, v291, v294) on ir0],
                                [Action::Entry, r3(v286, v14, v291, v293) on ir0],
                                [Action::Insert, r5(v293, v294, v292)],
                            ],
                        ],
                    ],
                    premise: [IterNew, r6(v35, v36, v37)]
                    actions: [
                        [Action::Insert, r6(v35, v36, v37)],
                        [Action::Insert, r6(v36, v35, v37)],
                    ]
                    then: [
                        premise: [JoinOld, r2(v187, v37, v191), ir1]
                        meta: "( rewrite ( Diff x ( Mul a b ) ) ( Add ( Mul a ( Diff x b ) ) ( Mul b ( Diff x a ) ) ) )"
                        actions: [
                            [Action::Entry, r2(v187, v36, v192) on ir0],
                            [Action::Entry, r6(v35, v192, v193) on ir0],
                            [Action::Insert, r6(v192, v35, v193)],
                            [Action::Entry, r2(v187, v35, v194) on ir0],
                            [Action::Entry, r6(v36, v194, v195) on ir0],
                            [Action::Insert, r4(v193, v195, v191)],
                            [Action::Insert, r4(v195, v193, v191)],
                            [Action::Insert, r6(v194, v36, v195)],
                        ],
                        premise: [JoinOld, r3(v320, v37, v324, v325), ir3]
                        then: [
                            premise: [JoinOld, r0(v319, v320), ir1]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Mul a b ) x ) ( Sub ( Mul a ( Integral fuel b x ) ) ( Integral fuel ( Mul ( Diff x a ) ( Integral fuel b x ) ) x ) ) )"
                            actions: [
                                [Action::Entry, r3(v319, v36, v324, v326) on ir0],
                                [Action::Entry, r6(v35, v326, v327) on ir0],
                                [Action::Insert, r6(v326, v35, v327)],
                                [Action::Entry, r2(v324, v35, v328) on ir0],
                                [Action::Entry, r6(v326, v328, v329) on ir0],
                                [Action::Insert, r6(v328, v326, v329)],
                                [Action::Entry, r3(v319, v329, v324, v330) on ir0],
                                [Action::Insert, r5(v327, v330, v325)],
                            ],
                        ],
                        premise: [JoinOld, r4(v106, v107, v36), ir2]
                        meta: "( rewrite ( Mul a ( Add b c ) ) ( Add ( Mul a b ) ( Mul a c ) ) )"
                        actions: [
                            [Action::Entry, r6(v35, v107, v111) on ir0],
                            [Action::Insert, r6(v107, v35, v111)],
                            [Action::Entry, r6(v35, v106, v110) on ir0],
                            [Action::Insert, r4(v110, v111, v37)],
                            [Action::Insert, r4(v111, v110, v37)],
                            [Action::Insert, r6(v106, v35, v110)],
                        ],
                        premise: [JoinAll, r6(v51, v52, v36), ir3]
                        meta: "( rewrite ( Mul a ( Mul b c ) ) ( Mul ( Mul a b ) c ) )"
                        actions: [
                            [Action::Entry, r6(v35, v51, v55) on ir0],
                            [Action::Insert, r6(v51, v35, v55)],
                            [Action::Insert, r6(v52, v55, v37)],
                            [Action::Insert, r6(v55, v52, v37)],
                        ],
                        premise: [JoinOld, r6(v37, v56, v60), ir1]
                        meta: "( rewrite ( Mul a ( Mul b c ) ) ( Mul ( Mul a b ) c ) )"
                        actions: [
                            [Action::Entry, r6(v56, v35, v61) on ir0],
                            [Action::Insert, r6(v35, v56, v61)],
                            [Action::Insert, r6(v36, v61, v60)],
                            [Action::Insert, r6(v61, v36, v60)],
                        ],
                        premise: [JoinAll, r16(v75), ir_bogus]
                        then: [
                            premise: [SemiJoin, r13(v75, v36), ir0]
                            meta: "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"
                            actions: [
                                [Action::Equate, v36=v37],
                            ],
                        ],
                        premise: [JoinAll, r17(v87), ir_bogus]
                        then: [
                            premise: [SemiJoin, r13(v87, v36), ir0]
                            meta: "( rewrite ( Mul a ( Const 1 ) ) a )"
                            actions: [
                                [Action::Equate, v35=v37],
                            ],
                        ],
                        premise: [SemiJoin, r6(v35, v122, v123), ir1]
                        then: [
                            premise: [JoinOld, r4(v37, v123, v124), ir1]
                            then: [
                                premise: [JoinAll, r6(v35, v122, v123), ir2]
                                meta: "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r4(v36, v122, v125) on ir0],
                                    [Action::Insert, r4(v122, v36, v125)],
                                    [Action::Insert, r6(v35, v125, v124)],
                                    [Action::Insert, r6(v125, v35, v124)],
                                ],
                            ],
                        ],
                        premise: [SemiJoin, r8(v126, v127, v35), ir4]
                        then: [
                            premise: [JoinAll, r8(v126, v129, v36), ir4]
                            then: [
                                premise: [JoinAll, r8(v126, v127, v35), ir2]
                                meta: "( rewrite ( Mul ( Pow a b ) ( Pow a c ) ) ( Pow a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r4(v127, v129, v132) on ir0],
                                    [Action::Insert, r4(v129, v127, v132)],
                                    [Action::Insert, r8(v126, v132, v37)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r8(v133, v134, v135)]
                    then: [
                        premise: [JoinAll, r17(v141), ir_bogus]
                        then: [
                            premise: [SemiJoin, r13(v141, v134), ir0]
                            meta: "( rewrite ( Pow x ( Const 1 ) ) x )"
                            actions: [
                                [Action::Equate, v133=v135],
                            ],
                        ],
                        premise: [JoinAll, r18(v153), ir_bogus]
                        then: [
                            premise: [SemiJoin, r13(v153, v134), ir0]
                            meta: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"
                            actions: [
                                [Action::Insert, r6(v133, v133, v135)],
                            ],
                        ],
                        premise: [SemiJoin, r8(v133, v136, v137), ir1]
                        then: [
                            premise: [JoinOld, r6(v135, v137, v138), ir1]
                            then: [
                                premise: [JoinAll, r8(v133, v136, v137), ir2]
                                meta: "( rewrite ( Mul ( Pow a b ) ( Pow a c ) ) ( Pow a ( Add b c ) ) )"
                                actions: [
                                    [Action::Entry, r4(v134, v136, v139) on ir0],
                                    [Action::Insert, r4(v136, v134, v139)],
                                    [Action::Insert, r8(v133, v139, v138)],
                                ],
                            ],
                        ],
                    ],
                    premise: [IterNew, r11(v8, v9)]
                    then: [
                        premise: [JoinOld, r2(v8, v9, v201), ir0]
                        meta: "( rewrite ( Diff x ( Sin x ) ) ( Cos x ) )"
                        actions: [
                            [Action::Insert, r12(v8, v201)],
                        ],
                        premise: [JoinOld, r3(v7, v9, v8, v10), ir4]
                        meta: "( rewrite ( Integral fuel ( Sin x ) x ) ( Mul ( Const -1 ) ( Cos x ) ) )"
                        actions: [
                            [Action::Entry, r15(v11) on ir_bogus],
                            [Action::Entry, r13(v11, v12) on ir0],
                            [Action::Entry, r12(v8, v13) on ir0],
                            [Action::Insert, r6(v12, v13, v10)],
                            [Action::Insert, r6(v13, v12, v10)],
                        ],
                    ],
                    premise: [IterNew, r12(v26, v27)]
                    then: [
                        premise: [JoinOld, r2(v26, v27, v28), ir0]
                        meta: "( rewrite ( Diff x ( Cos x ) ) ( Mul ( Const -1 ) ( Sin x ) ) )"
                        actions: [
                            [Action::Entry, r15(v29) on ir_bogus],
                            [Action::Entry, r13(v29, v30) on ir0],
                            [Action::Entry, r11(v26, v31) on ir0],
                            [Action::Insert, r6(v30, v31, v28)],
                            [Action::Insert, r6(v31, v30, v28)],
                        ],
                        premise: [JoinOld, r3(v237, v27, v26, v240), ir4]
                        then: [
                            premise: [JoinOld, r0(v236, v237), ir1]
                            meta: "( rewrite ( Integral ( Fuel fuel ) ( Cos x ) x ) ( Sin x ) )"
                            actions: [
                                [Action::Insert, r11(v26, v240)],
                            ],
                        ],
                    ],
                    premise: [IterNew, r13(v67, v68)]
                    then: [
                        premise: [SemiJoin, r16(v67), ir_bogus]
                        then: [
                            premise: [JoinOld, r4(v68, v66, v69), ir1]
                            meta: "( rewrite ( Add a ( Const 0 ) ) a )"
                            actions: [
                                [Action::Equate, v66=v69],
                            ],
                            premise: [JoinOld, r6(v68, v78, v81), ir1]
                            meta: "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"
                            actions: [
                                [Action::Equate, v68=v81],
                            ],
                        ],
                        premise: [SemiJoin, r17(v67), ir_bogus]
                        then: [
                            premise: [JoinOld, r3(v215, v68, v218, v219), ir3]
                            then: [
                                premise: [JoinOld, r0(v214, v215), ir1]
                                meta: "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )"
                                actions: [
                                    [Action::Equate, v218=v219],
                                ],
                            ],
                            premise: [JoinOld, r6(v68, v90, v93), ir1]
                            meta: "( rewrite ( Mul a ( Const 1 ) ) a )"
                            actions: [
                                [Action::Equate, v90=v93],
                            ],
                            premise: [JoinOld, r8(v144, v68, v147), ir3]
                            meta: "( rewrite ( Pow x ( Const 1 ) ) x )"
                            actions: [
                                [Action::Equate, v144=v147],
                            ],
                        ],
                        premise: [SemiJoin, r18(v67), ir_bogus]
                        then: [
                            premise: [JoinOld, r8(v156, v68, v159), ir3]
                            meta: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"
                            actions: [
                                [Action::Insert, r6(v156, v156, v159)],
                            ],
                        ],
                    ],
                    premise: [IterNew, r16(v71)]
                    then: [
                        premise: [JoinOld, r13(v71, v72), ir0]
                        then: [
                            premise: [JoinOld, r4(v72, v70, v73), ir1]
                            meta: "( rewrite ( Add a ( Const 0 ) ) a )"
                            actions: [
                                [Action::Equate, v70=v73],
                            ],
                            premise: [JoinOld, r6(v72, v82, v85), ir1]
                            meta: "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"
                            actions: [
                                [Action::Equate, v72=v85],
                            ],
                        ],
                    ],
                    premise: [IterNew, r17(v95)]
                    then: [
                        premise: [JoinOld, r13(v95, v96), ir0]
                        then: [
                            premise: [JoinOld, r3(v221, v96, v224, v225), ir3]
                            then: [
                                premise: [JoinOld, r0(v220, v221), ir1]
                                meta: "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )"
                                actions: [
                                    [Action::Equate, v224=v225],
                                ],
                            ],
                            premise: [JoinOld, r6(v96, v94, v97), ir1]
                            meta: "( rewrite ( Mul a ( Const 1 ) ) a )"
                            actions: [
                                [Action::Equate, v94=v97],
                            ],
                            premise: [JoinOld, r8(v148, v96, v151), ir3]
                            meta: "( rewrite ( Pow x ( Const 1 ) ) x )"
                            actions: [
                                [Action::Equate, v148=v151],
                            ],
                        ],
                    ],
                    premise: [IterNew, r18(v161)]
                    then: [
                        premise: [JoinOld, r13(v161, v162), ir0]
                        then: [
                            premise: [JoinOld, r8(v160, v162, v163), ir3]
                            meta: "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"
                            actions: [
                                [Action::Insert, r6(v160, v160, v163)],
                            ],
                        ],
                    ],
                ],
                initial: [
                    ComputeGlobal {
                        global_id: g0,
                        compute: Literal(I64(-1)),
                    },
                    ComputeGlobal {
                        global_id: g1,
                        compute: Literal(I64(0)),
                    },
                    ComputeGlobal {
                        global_id: g2,
                        compute: Literal(I64(1)),
                    },
                    ComputeGlobal {
                        global_id: g3,
                        compute: Literal(I64(2)),
                    },
                    ComputeGlobal {
                        global_id: g4,
                        compute: Compute { relation: r1, args: [] },
                    },
                    ComputeGlobal {
                        global_id: g5,
                        compute: Compute { relation: r0, args: [g4] },
                    },
                    ComputeGlobal {
                        global_id: g6,
                        compute: Compute { relation: r0, args: [g5] },
                    },
                    ComputeGlobal {
                        global_id: g7,
                        compute: Compute { relation: r0, args: [g6] },
                    },
                    ComputeGlobal {
                        global_id: g8,
                        compute: Literal(String(IString(0))),
                    },
                    ComputeGlobal {
                        global_id: g9,
                        compute: Compute { relation: r14, args: [g8] },
                    },
                    ComputeGlobal {
                        global_id: g10,
                        compute: Compute { relation: r9, args: [g9] },
                    },
                    ComputeGlobal {
                        global_id: g11,
                        compute: Compute { relation: r3, args: [g7, g10, g9] },
                    },
                    ComputeGlobal {
                        global_id: g12,
                        compute: Compute { relation: r12, args: [g9] },
                    },
                    ComputeGlobal {
                        global_id: g13,
                        compute: Compute { relation: r4, args: [g9, g12] },
                    },
                    ComputeGlobal {
                        global_id: g14,
                        compute: Compute { relation: r3, args: [g7, g13, g9] },
                    },
                    ComputeGlobal {
                        global_id: g15,
                        compute: Compute { relation: r6, args: [g12, g9] },
                    },
                    ComputeGlobal {
                        global_id: g16,
                        compute: Compute { relation: r3, args: [g7, g15, g9] },
                    },
                    ComputeGlobal {
                        global_id: g17,
                        compute: Compute { relation: r13, args: [g2] },
                    },
                    ComputeGlobal {
                        global_id: g18,
                        compute: Compute { relation: r13, args: [g3] },
                    },
                    ComputeGlobal {
                        global_id: g19,
                        compute: Compute { relation: r6, args: [g18, g9] },
                    },
                    ComputeGlobal {
                        global_id: g20,
                        compute: Compute { relation: r4, args: [g17, g19] },
                    },
                    ComputeGlobal {
                        global_id: g21,
                        compute: Compute { relation: r2, args: [g9, g20] },
                    },
                    ComputeGlobal {
                        global_id: g22,
                        compute: Literal(I64(3)),
                    },
                    ComputeGlobal {
                        global_id: g23,
                        compute: Compute { relation: r13, args: [g22] },
                    },
                    ComputeGlobal {
                        global_id: g24,
                        compute: Compute { relation: r8, args: [g9, g23] },
                    },
                    ComputeGlobal {
                        global_id: g25,
                        compute: Literal(I64(7)),
                    },
                    ComputeGlobal {
                        global_id: g26,
                        compute: Compute { relation: r13, args: [g25] },
                    },
                    ComputeGlobal {
                        global_id: g27,
                        compute: Compute { relation: r8, args: [g9, g18] },
                    },
                    ComputeGlobal {
                        global_id: g28,
                        compute: Compute { relation: r6, args: [g26, g27] },
                    },
                    ComputeGlobal {
                        global_id: g29,
                        compute: Compute { relation: r5, args: [g24, g28] },
                    },
                    ComputeGlobal {
                        global_id: g30,
                        compute: Compute { relation: r2, args: [g9, g29] },
                    },
                    ComputeGlobal {
                        global_id: g31,
                        compute: Literal(String(IString(1))),
                    },
                    ComputeGlobal {
                        global_id: g32,
                        compute: Compute { relation: r14, args: [g31] },
                    },
                    ComputeGlobal {
                        global_id: g33,
                        compute: Compute { relation: r4, args: [g9, g32] },
                    },
                    ComputeGlobal {
                        global_id: g34,
                        compute: Compute { relation: r6, args: [g32, g33] },
                    },
                    ComputeGlobal {
                        global_id: g35,
                        compute: Compute { relation: r4, args: [g9, g18] },
                    },
                    ComputeGlobal {
                        global_id: g36,
                        compute: Compute { relation: r4, args: [g9, g9] },
                    },
                    ComputeGlobal {
                        global_id: g37,
                        compute: Compute { relation: r5, args: [g35, g36] },
                    },
                    ComputeGlobal {
                        global_id: g38,
                        compute: Compute { relation: r4, args: [g34, g37] },
                    },
                    ComputeGlobal {
                        global_id: g39,
                        compute: Literal(String(IString(2))),
                    },
                    ComputeGlobal {
                        global_id: g40,
                        compute: Compute { relation: r14, args: [g39] },
                    },
                    ComputeGlobal {
                        global_id: g41,
                        compute: Compute { relation: r10, args: [g40] },
                    },
                    ComputeGlobal {
                        global_id: g42,
                        compute: Compute { relation: r4, args: [g17, g41] },
                    },
                    ComputeGlobal {
                        global_id: g43,
                        compute: Compute { relation: r7, args: [g42, g18] },
                    },
                    ComputeGlobal {
                        global_id: g44,
                        compute: Compute { relation: r5, args: [g17, g41] },
                    },
                    ComputeGlobal {
                        global_id: g45,
                        compute: Compute { relation: r7, args: [g44, g18] },
                    },
                    ComputeGlobal {
                        global_id: g46,
                        compute: Compute { relation: r5, args: [g43, g45] },
                    },
                    ComputeGlobal {
                        global_id: g47,
                        compute: Compute { relation: r7, args: [g17, g46] },
                    },
                ],
            }"#]]),
        expected_codegen: Some(expect![[r#"
            use oatlog::runtime::{self, *};
            eclass_wrapper_ty!(FuelUnit);
            eclass_wrapper_ty!(Math);
            #[derive(Debug, Default)]
            struct FuelRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(FuelUnit, FuelUnit, TimeStamp)>,
                fd_index_0: runtime::HashMap<(FuelUnit,), (FuelUnit, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(FuelUnit,), (FuelUnit, TimeStamp)>,
                fuel_unit_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for FuelRelation {
                type Row = (FuelUnit, FuelUnit);
                type Unification = Unification;
                const COST: u32 = 4u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "fuel", "fuel_unit", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "fuel", "fuel_unit", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "fuel").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "fuel", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((uf.fuel_unit_.find(x0),)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.fuel_unit_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.fuel_unit_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "fuel", {
                        if self.fuel_unit_num_uprooted_at_latest_retain == uf.fuel_unit_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.fuel_unit_num_uprooted_at_latest_retain = uf.fuel_unit_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.fuel_unit_.is_root(x0) & uf.fuel_unit_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "fuel", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.fuel_unit_.find(x0), uf.fuel_unit_.find(x1),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.fuel_unit_.find(x0), uf.fuel_unit_.find(x1),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.fuel_unit_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort01::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, timestamp)| (x1,),
                                    |(x0, x1, timestamp)| (x0, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl FuelRelation {
                fn iter_all_0_to_1(&self, x0: FuelUnit) -> impl Iterator<Item = (FuelUnit,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: FuelUnit,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (FuelUnit,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(&self, x0: FuelUnit, delta: &mut Delta, uf: &mut Unification) -> (FuelUnit,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.fuel_unit_.add_eclass();
                    delta.fuel_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: FuelUnit) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn iter_all_1_to_0(&self, x1: FuelUnit) -> impl Iterator<Item = (FuelUnit,)> + use<'_> {
                    self.nofd_index_1.iter((x1,)).map(|(x0, _timestamp)| (x0,))
                }
                fn iter_old_1_to_0(
                    &self,
                    x1: FuelUnit,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (FuelUnit,)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, timestamp)| (timestamp < latest_timestamp).then_some((x0,)))
                }
                fn check_1(&self, x1: FuelUnit) -> bool {
                    self.iter_all_1_to_0(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct ZeroFuelRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(FuelUnit, TimeStamp)>,
                fd_index_: runtime::HashMap<(), (FuelUnit, TimeStamp)>,
                fuel_unit_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ZeroFuelRelation {
                type Row = (FuelUnit,);
                type Unification = Unification;
                const COST: u32 = 1u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((), (x0, _timestamp))) in
                        self.fd_index_.iter().map(|(k, v)| ((*k), (*v))).enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "zero_fuel", "fuel_unit", x0).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "zero_fuel").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "zero_fuel", {
                        for &(mut x0,) in insertions {
                            match self.fd_index_.entry(()) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y0, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y0;
                                    let changed = changed | (old_val != uf.fuel_unit_.union_mut(&mut x0, y0));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.fuel_unit_.find(x0), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "zero_fuel", {
                        if self.fuel_unit_num_uprooted_at_latest_retain == uf.fuel_unit_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.fuel_unit_num_uprooted_at_latest_retain = uf.fuel_unit_.num_uprooted();
                        self.fd_index_.retain(|&(), &mut (x0, _timestamp)| {
                            if uf.fuel_unit_.is_root(x0) {
                                true
                            } else {
                                insertions.push((x0,));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "zero_fuel", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new
                                .extend(self.fd_index_.iter().filter_map(|(&(), &(x0, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0,))
                                    } else {
                                        None
                                    }
                                }));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_
                                    .iter()
                                    .map(|(&(), &(x0, timestamp))| (x0, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0,)| {
                                assert_eq!((x0,), (uf.fuel_unit_.find(x0),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, _timestamp)| {
                                assert_eq!((x0,), (uf.fuel_unit_.find(x0),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self.all.iter().map(|&(x0, _timestamp)| (x0,)).collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.fuel_unit_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl ZeroFuelRelation {
                fn iter_all__to_0(&self) -> impl Iterator<Item = (FuelUnit,)> + use<'_> {
                    self.fd_index_
                        .get(&())
                        .into_iter()
                        .copied()
                        .map(|(x0, _timestamp)| (x0,))
                }
                fn iter_old__to_0(
                    &self,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (FuelUnit,)> + use<'_> {
                    self.fd_index_
                        .get(&())
                        .into_iter()
                        .copied()
                        .filter_map(move |(x0, timestamp)| (timestamp < latest_timestamp).then_some((x0,)))
                }
                #[allow(unreachable_code)]
                fn entry__to_0(&self, delta: &mut Delta, uf: &mut Unification) -> (FuelUnit,) {
                    if let Some((x0,)) = self.iter_all__to_0().next() {
                        return (x0,);
                    }
                    let x0 = uf.fuel_unit_.add_eclass();
                    delta.zero_fuel_.push((x0,));
                    (x0,)
                }
                fn check_(&self) -> bool {
                    self.iter_all__to_0().next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct DiffRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for DiffRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "diff", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "diff", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "diff", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "diff").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "diff", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "diff", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "diff", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort010::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x1,),
                                    |(x0, x1, x2, timestamp)| (x0, x2, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl DiffRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.diff_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_1_to_0_2(&self, x1: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .map(|(x0, x2, _timestamp)| (x0, x2))
                }
                fn iter_old_1_to_0_2(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x2))
                        })
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0_2(x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct IntegralRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(FuelUnit, Math, Math, Math, TimeStamp)>,
                fd_index_0_1_2: runtime::HashMap<(FuelUnit, Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(FuelUnit,), (Math, Math, Math, TimeStamp)>,
                nofd_index_0_1: runtime::IndexedSortedList<(FuelUnit, Math), (Math, Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (FuelUnit, Math, Math, TimeStamp)>,
                nofd_index_1_2: runtime::IndexedSortedList<(Math, Math), (FuelUnit, Math, TimeStamp)>,
                fuel_unit_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for IntegralRelation {
                type Row = (FuelUnit, Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 20u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1, x2), (x3, _timestamp))) in self
                        .fd_index_0_1_2
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "integral", "fuel_unit", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "integral", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "integral", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "integral", "math", x3).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "integral").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "integral", {
                        for &(mut x0, mut x1, mut x2, mut x3) in insertions {
                            match self.fd_index_0_1_2.entry((
                                uf.fuel_unit_.find(x0),
                                uf.math_.find(x1),
                                uf.math_.find(x2),
                            )) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y3, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y3;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x3, y3));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x3), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "integral", {
                        if self.fuel_unit_num_uprooted_at_latest_retain == uf.fuel_unit_.num_uprooted()
                            && self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted()
                        {
                            return false;
                        }
                        let offset = insertions.len();
                        self.fuel_unit_num_uprooted_at_latest_retain = uf.fuel_unit_.num_uprooted();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1_2
                            .retain(|&(x0, x1, x2), &mut (x3, _timestamp)| {
                                if uf.fuel_unit_.is_root(x0)
                                    & uf.math_.is_root(x1)
                                    & uf.math_.is_root(x2)
                                    & uf.math_.is_root(x3)
                                {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2, x3));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "integral", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1_2.iter().filter_map(
                                |(&(x0, x1, x2), &(x3, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2, x3))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1_2
                                    .iter()
                                    .map(|(&(x0, x1, x2), &(x3, timestamp))| (x0, x1, x2, x3, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2, x3)| {
                                assert_eq!(
                                    (x0, x1, x2, x3,),
                                    (
                                        uf.fuel_unit_.find(x0),
                                        uf.math_.find(x1),
                                        uf.math_.find(x2),
                                        uf.math_.find(x3),
                                    ),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, x3, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2, x3,),
                                    (
                                        uf.fuel_unit_.find(x0),
                                        uf.math_.find(x1),
                                        uf.math_.find(x2),
                                        uf.math_.find(x3),
                                    ),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, x3, _timestamp)| (x0, x1, x2, x3))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.fuel_unit_num_uprooted_at_latest_retain = 0;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                self.all
                                    .sort_unstable_by_key(|&(x0, x1, x2, x3, timestamp)| (x0,));
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, x3, timestamp)| (x0,),
                                    |(x0, x1, x2, x3, timestamp)| (x1, x2, x3, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                self.all
                                    .sort_unstable_by_key(|&(x0, x1, x2, x3, timestamp)| (x0, x1));
                            });
                            unsafe {
                                self.nofd_index_0_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, x3, timestamp)| (x0, x1),
                                    |(x0, x1, x2, x3, timestamp)| (x2, x3, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                self.all
                                    .sort_unstable_by_key(|&(x0, x1, x2, x3, timestamp)| (x1,));
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, x3, timestamp)| (x1,),
                                    |(x0, x1, x2, x3, timestamp)| (x0, x2, x3, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                self.all
                                    .sort_unstable_by_key(|&(x0, x1, x2, x3, timestamp)| (x1, x2));
                            });
                            unsafe {
                                self.nofd_index_1_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, x3, timestamp)| (x1, x2),
                                    |(x0, x1, x2, x3, timestamp)| (x0, x3, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl IntegralRelation {
                fn iter_all_0_1_2_to_3(
                    &self,
                    x0: FuelUnit,
                    x1: Math,
                    x2: Math,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1_2
                        .get(&(x0, x1, x2))
                        .into_iter()
                        .copied()
                        .map(|(x3, _timestamp)| (x3,))
                }
                fn iter_old_0_1_2_to_3(
                    &self,
                    x0: FuelUnit,
                    x1: Math,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1_2
                        .get(&(x0, x1, x2))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x3, timestamp)| (timestamp < latest_timestamp).then_some((x3,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_2_to_3(
                    &self,
                    x0: FuelUnit,
                    x1: Math,
                    x2: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x3,)) = self.iter_all_0_1_2_to_3(x0, x1, x2).next() {
                        return (x3,);
                    }
                    let x3 = uf.math_.add_eclass();
                    delta.integral_.push((x0, x1, x2, x3));
                    (x3,)
                }
                fn check_0_1_2(&self, x0: FuelUnit, x1: Math, x2: Math) -> bool {
                    self.iter_all_0_1_2_to_3(x0, x1, x2).next().is_some()
                }
                fn iter_all_0_to_1_2_3(
                    &self,
                    x0: FuelUnit,
                ) -> impl Iterator<Item = (Math, Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, x3, _timestamp)| (x1, x2, x3))
                }
                fn iter_old_0_to_1_2_3(
                    &self,
                    x0: FuelUnit,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, x3, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2, x3))
                        })
                }
                fn check_0(&self, x0: FuelUnit) -> bool {
                    self.iter_all_0_to_1_2_3(x0).next().is_some()
                }
                fn iter_all_0_1_to_2_3(
                    &self,
                    x0: FuelUnit,
                    x1: Math,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0_1
                        .iter((x0, x1))
                        .map(|(x2, x3, _timestamp)| (x2, x3))
                }
                fn iter_old_0_1_to_2_3(
                    &self,
                    x0: FuelUnit,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0_1
                        .iter((x0, x1))
                        .filter_map(move |(x2, x3, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x2, x3))
                        })
                }
                fn check_0_1(&self, x0: FuelUnit, x1: Math) -> bool {
                    self.iter_all_0_1_to_2_3(x0, x1).next().is_some()
                }
                fn iter_all_1_to_0_2_3(
                    &self,
                    x1: Math,
                ) -> impl Iterator<Item = (FuelUnit, Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .map(|(x0, x2, x3, _timestamp)| (x0, x2, x3))
                }
                fn iter_old_1_to_0_2_3(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (FuelUnit, Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, x2, x3, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x2, x3))
                        })
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0_2_3(x1).next().is_some()
                }
                fn iter_all_1_2_to_0_3(
                    &self,
                    x1: Math,
                    x2: Math,
                ) -> impl Iterator<Item = (FuelUnit, Math)> + use<'_> {
                    self.nofd_index_1_2
                        .iter((x1, x2))
                        .map(|(x0, x3, _timestamp)| (x0, x3))
                }
                fn iter_old_1_2_to_0_3(
                    &self,
                    x1: Math,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (FuelUnit, Math)> + use<'_> {
                    self.nofd_index_1_2
                        .iter((x1, x2))
                        .filter_map(move |(x0, x3, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x3))
                        })
                }
                fn check_1_2(&self, x1: Math, x2: Math) -> bool {
                    self.iter_all_1_2_to_0_3(x1, x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct AddRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_2: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for AddRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 9u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "add", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "add").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "add", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "add", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "add", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort001::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x2,),
                                    |(x0, x1, x2, timestamp)| (x0, x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl AddRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.add_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
                fn iter_all_2_to_0_1(&self, x2: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .map(|(x0, x1, _timestamp)| (x0, x1))
                }
                fn iter_old_2_to_0_1(
                    &self,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .filter_map(move |(x0, x1, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x1))
                        })
                }
                fn check_2(&self, x2: Math) -> bool {
                    self.iter_all_2_to_0_1(x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct SubRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_2: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for SubRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 6u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "sub", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "sub").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "sub", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "sub", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "sub", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort001::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x2,),
                                    |(x0, x1, x2, timestamp)| (x0, x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl SubRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.sub_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_2_to_0_1(&self, x2: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .map(|(x0, x1, _timestamp)| (x0, x1))
                }
                fn iter_old_2_to_0_1(
                    &self,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .filter_map(move |(x0, x1, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x1))
                        })
                }
                fn check_2(&self, x2: Math) -> bool {
                    self.iter_all_2_to_0_1(x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct MulRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_0_2: runtime::IndexedSortedList<(Math, Math), (Math, TimeStamp)>,
                nofd_index_2: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for MulRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 12u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "mul", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "mul").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "mul", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "mul", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "mul", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort101::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0, x2),
                                    |(x0, x1, x2, timestamp)| (x1, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort001::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x2,),
                                    |(x0, x1, x2, timestamp)| (x0, x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl MulRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.mul_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
                fn iter_all_0_2_to_1(&self, x0: Math, x2: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_2_to_1(
                    &self,
                    x0: Math,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                fn check_0_2(&self, x0: Math, x2: Math) -> bool {
                    self.iter_all_0_2_to_1(x0, x2).next().is_some()
                }
                fn iter_all_2_to_0_1(&self, x2: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .map(|(x0, x1, _timestamp)| (x0, x1))
                }
                fn iter_old_2_to_0_1(
                    &self,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .filter_map(move |(x0, x1, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x1))
                        })
                }
                fn check_2(&self, x2: Math) -> bool {
                    self.iter_all_2_to_0_1(x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct DivRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for DivRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 3u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "div", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "div", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "div", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "div").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "div", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "div", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "div", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl DivRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.div_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct PowRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, Math, TimeStamp)>,
                fd_index_0_1: runtime::HashMap<(Math, Math), (Math, TimeStamp)>,
                nofd_index_0: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_0_2: runtime::IndexedSortedList<(Math, Math), (Math, TimeStamp)>,
                nofd_index_1: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                nofd_index_2: runtime::IndexedSortedList<(Math,), (Math, Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for PowRelation {
                type Row = (Math, Math, Math);
                type Unification = Unification;
                const COST: u32 = 15u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0, x1), (x2, _timestamp))) in self
                        .fd_index_0_1
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "pow", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "pow", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "pow", "math", x2).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "pow").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "pow", {
                        for &(mut x0, mut x1, mut x2) in insertions {
                            match self
                                .fd_index_0_1
                                .entry((uf.math_.find(x0), uf.math_.find(x1)))
                            {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y2, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y2;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x2, y2));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x2), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "pow", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0_1
                            .retain(|&(x0, x1), &mut (x2, _timestamp)| {
                                if uf.math_.is_root(x0) & uf.math_.is_root(x1) & uf.math_.is_root(x2) {
                                    true
                                } else {
                                    insertions.push((x0, x1, x2));
                                    false
                                }
                            });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "pow", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(self.fd_index_0_1.iter().filter_map(
                                |(&(x0, x1), &(x2, timestamp))| {
                                    if timestamp == latest_timestamp {
                                        Some((x0, x1, x2))
                                    } else {
                                        None
                                    }
                                },
                            ));
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0_1
                                    .iter()
                                    .map(|(&(x0, x1), &(x2, timestamp))| (x0, x1, x2, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1, x2)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, x2, _timestamp)| {
                                assert_eq!(
                                    (x0, x1, x2,),
                                    (uf.math_.find(x0), uf.math_.find(x1), uf.math_.find(x2),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, x2, _timestamp)| (x0, x1, x2))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort100::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0,),
                                    |(x0, x1, x2, timestamp)| (x1, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort101::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_0_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x0, x2),
                                    |(x0, x1, x2, timestamp)| (x1, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort010::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_1.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x1,),
                                    |(x0, x1, x2, timestamp)| (x0, x2, timestamp),
                                );
                            }
                        });
                        log_duration!("reconstruct index: {}", {
                            log_duration!("reconstruct sort: {}", {
                                RowSort001::sort(&mut self.all);
                            });
                            unsafe {
                                self.nofd_index_2.reconstruct(
                                    &mut self.all,
                                    |(x0, x1, x2, timestamp)| (x2,),
                                    |(x0, x1, x2, timestamp)| (x0, x1, timestamp),
                                );
                            }
                        });
                    }
                }
            }
            impl PowRelation {
                fn iter_all_0_1_to_2(&self, x0: Math, x1: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .map(|(x2, _timestamp)| (x2,))
                }
                fn iter_old_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0_1
                        .get(&(x0, x1))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x2, timestamp)| (timestamp < latest_timestamp).then_some((x2,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_1_to_2(
                    &self,
                    x0: Math,
                    x1: Math,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x2,)) = self.iter_all_0_1_to_2(x0, x1).next() {
                        return (x2,);
                    }
                    let x2 = uf.math_.add_eclass();
                    delta.pow_.push((x0, x1, x2));
                    (x2,)
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_1_to_2(x0, x1).next().is_some()
                }
                fn iter_all_0_to_1_2(&self, x0: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .map(|(x1, x2, _timestamp)| (x1, x2))
                }
                fn iter_old_0_to_1_2(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_0
                        .iter((x0,))
                        .filter_map(move |(x1, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x1, x2))
                        })
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1_2(x0).next().is_some()
                }
                fn iter_all_0_2_to_1(&self, x0: Math, x2: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_2_to_1(
                    &self,
                    x0: Math,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.nofd_index_0_2
                        .iter((x0, x2))
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                fn check_0_2(&self, x0: Math, x2: Math) -> bool {
                    self.iter_all_0_2_to_1(x0, x2).next().is_some()
                }
                fn iter_all_1_to_0_2(&self, x1: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .map(|(x0, x2, _timestamp)| (x0, x2))
                }
                fn iter_old_1_to_0_2(
                    &self,
                    x1: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_1
                        .iter((x1,))
                        .filter_map(move |(x0, x2, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x2))
                        })
                }
                fn check_1(&self, x1: Math) -> bool {
                    self.iter_all_1_to_0_2(x1).next().is_some()
                }
                fn iter_all_2_to_0_1(&self, x2: Math) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .map(|(x0, x1, _timestamp)| (x0, x1))
                }
                fn iter_old_2_to_0_1(
                    &self,
                    x2: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math, Math)> + use<'_> {
                    self.nofd_index_2
                        .iter((x2,))
                        .filter_map(move |(x0, x1, timestamp)| {
                            (timestamp < latest_timestamp).then_some((x0, x1))
                        })
                }
                fn check_2(&self, x2: Math) -> bool {
                    self.iter_all_2_to_0_1(x2).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct LnRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(Math,), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for LnRelation {
                type Row = (Math, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "ln", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "ln", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "ln").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "ln", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((uf.math_.find(x0),)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "ln", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x0) & uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "ln", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl LnRelation {
                fn iter_all_0_to_1(&self, x0: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(&self, x0: Math, delta: &mut Delta, uf: &mut Unification) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.ln_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct SqrtRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(Math,), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for SqrtRelation {
                type Row = (Math, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "sqrt", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "sqrt", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "sqrt").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "sqrt", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((uf.math_.find(x0),)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "sqrt", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x0) & uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "sqrt", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl SqrtRelation {
                fn iter_all_0_to_1(&self, x0: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(&self, x0: Math, delta: &mut Delta, uf: &mut Unification) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.sqrt_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            struct SinRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(Math,), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for SinRelation {
                type Row = (Math, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "sin", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "sin", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "sin").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "sin", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((uf.math_.find(x0),)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "sin", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x0) & uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "sin", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl SinRelation {
                fn iter_all_0_to_1(&self, x0: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(&self, x0: Math, delta: &mut Delta, uf: &mut Unification) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.sin_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_to_1(x0)
                        .next()
                        .is_some_and(|(y1,)| true && x1 == y1)
                }
            }
            #[derive(Debug, Default)]
            struct CosRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(Math, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(Math,), (Math, TimeStamp)>,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for CosRelation {
                type Row = (Math, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "cos", "math", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "cos", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "cos").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "cos", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((uf.math_.find(x0),)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "cos", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x0) & uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "cos", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            RadixSortable::wrap(&mut self.new).voracious_sort();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "new is canonical"
                                );
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!(
                                    (x0, x1,),
                                    (uf.math_.find(x0), uf.math_.find(x1),),
                                    "all is canonical"
                                );
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl CosRelation {
                fn iter_all_0_to_1(&self, x0: Math) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: Math,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(&self, x0: Math, delta: &mut Delta, uf: &mut Unification) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.cos_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: Math) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn check_0_1(&self, x0: Math, x1: Math) -> bool {
                    self.iter_all_0_to_1(x0)
                        .next()
                        .is_some_and(|(y1,)| true && x1 == y1)
                }
            }
            #[derive(Debug, Default)]
            struct ConstRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(std::primitive::i64, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(std::primitive::i64,), (Math, TimeStamp)>,
                i64_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for ConstRelation {
                type Row = (std::primitive::i64, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "i64", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "const", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "const").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "const", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "const", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "const", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl ConstRelation {
                fn iter_all_0_to_1(&self, x0: std::primitive::i64) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: std::primitive::i64,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.const_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: std::primitive::i64) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
                fn check_0_1(&self, x0: std::primitive::i64, x1: Math) -> bool {
                    self.iter_all_0_to_1(x0)
                        .next()
                        .is_some_and(|(y1,)| true && x1 == y1)
                }
            }
            #[derive(Debug, Default)]
            struct VarRelation {
                new: Vec<<Self as Relation>::Row>,
                all: Vec<(runtime::IString, Math, TimeStamp)>,
                fd_index_0: runtime::HashMap<(runtime::IString,), (Math, TimeStamp)>,
                string_num_uprooted_at_latest_retain: usize,
                math_num_uprooted_at_latest_retain: usize,
                deferred: bool,
            }
            impl Relation for VarRelation {
                type Row = (runtime::IString, Math);
                type Unification = Unification;
                const COST: u32 = 2u32;
                fn new() -> Self {
                    Self::default()
                }
                fn has_new(&self) -> bool {
                    !self.new.is_empty()
                }
                fn clear_new(&mut self) {
                    self.new.clear();
                }
                fn iter_new(&self) -> impl '_ + Iterator<Item = Self::Row> {
                    self.new.iter().copied()
                }
                fn len(&self) -> usize {
                    self.all.len()
                }
                fn emit_graphviz(&self, buf: &mut String) {
                    use std::fmt::Write;
                    for (i, ((x0,), (x1, _timestamp))) in self
                        .fd_index_0
                        .iter()
                        .map(|(k, v)| ((*k), (*v)))
                        .enumerate()
                    {
                        writeln!(buf, "{}_{i} -> {}_{};", "var", "string", x0).unwrap();
                        writeln!(buf, "{}_{i} -> {}_{};", "var", "math", x1).unwrap();
                        writeln!(buf, "{}_{i} [shape = box];", "var").unwrap();
                    }
                }
                fn update_begin(
                    &mut self,
                    insertions: &[Self::Row],
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_begin {}: {}", "var", {
                        for &(mut x0, mut x1) in insertions {
                            match self.fd_index_0.entry((x0,)) {
                                runtime::HashMapEntry::Occupied(mut entry) => {
                                    let (y1, timestamp) = entry.get_mut();
                                    let changed = false;
                                    let old_val = *y1;
                                    let changed = changed | (old_val != uf.math_.union_mut(&mut x1, y1));
                                    if changed {
                                        *timestamp = latest_timestamp;
                                    }
                                }
                                runtime::HashMapEntry::Vacant(entry) => {
                                    entry.insert((uf.math_.find(x1), latest_timestamp));
                                }
                            }
                        }
                    });
                }
                fn update(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) -> bool {
                    log_duration!("update {}: {}", "var", {
                        if self.math_num_uprooted_at_latest_retain == uf.math_.num_uprooted() {
                            return false;
                        }
                        let offset = insertions.len();
                        self.math_num_uprooted_at_latest_retain = uf.math_.num_uprooted();
                        self.fd_index_0.retain(|&(x0,), &mut (x1, _timestamp)| {
                            if uf.math_.is_root(x1) {
                                true
                            } else {
                                insertions.push((x0, x1));
                                false
                            }
                        });
                        self.update_begin(&insertions[offset..], uf, latest_timestamp);
                        true
                    })
                }
                fn update_finalize(
                    &mut self,
                    insertions: &mut Vec<Self::Row>,
                    uf: &mut Unification,
                    latest_timestamp: TimeStamp,
                ) {
                    log_duration!("update_finalize {}: {}", "var", {
                        assert!(self.new.is_empty());
                        log_duration!("fill new and all: {}", {
                            self.new.extend(
                                self.fd_index_0
                                    .iter()
                                    .filter_map(|(&(x0,), &(x1, timestamp))| {
                                        if timestamp == latest_timestamp {
                                            Some((x0, x1))
                                        } else {
                                            None
                                        }
                                    }),
                            );
                            self.new.sort_unstable();
                            self.all.clear();
                            self.all.extend(
                                self.fd_index_0
                                    .iter()
                                    .map(|(&(x0,), &(x1, timestamp))| (x0, x1, timestamp)),
                            );
                            insertions.clear();
                        });
                        #[cfg(debug_assertions)]
                        {
                            self.new.iter().for_each(|&(x0, x1)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "new is canonical");
                            });
                            let mut new = self.new.clone();
                            new.sort();
                            new.dedup();
                            assert_eq!(new.len(), self.new.len(), "new only has unique elements");
                            self.all.iter().for_each(|&(x0, x1, _timestamp)| {
                                assert_eq!((x0, x1,), (x0, uf.math_.find(x1),), "all is canonical");
                            });
                            let mut all_: Vec<_> = self.all.clone();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(all_.len(), self.all.len(), "all only has unique elements");
                            let mut all_: Vec<_> = self
                                .all
                                .iter()
                                .map(|&(x0, x1, _timestamp)| (x0, x1))
                                .collect();
                            all_.sort();
                            all_.dedup();
                            assert_eq!(
                                all_.len(),
                                self.all.len(),
                                "all does not have duplicate timestamps"
                            );
                        }
                        self.deferred = true;
                        self.math_num_uprooted_at_latest_retain = 0;
                    });
                }
                fn deferred_update(&mut self) {
                    if self.deferred {
                        self.deferred = false;
                    }
                }
            }
            impl VarRelation {
                fn iter_all_0_to_1(&self, x0: runtime::IString) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .map(|(x1, _timestamp)| (x1,))
                }
                fn iter_old_0_to_1(
                    &self,
                    x0: runtime::IString,
                    latest_timestamp: TimeStamp,
                ) -> impl Iterator<Item = (Math,)> + use<'_> {
                    self.fd_index_0
                        .get(&(x0,))
                        .into_iter()
                        .copied()
                        .filter_map(move |(x1, timestamp)| (timestamp < latest_timestamp).then_some((x1,)))
                }
                #[allow(unreachable_code)]
                fn entry_0_to_1(
                    &self,
                    x0: runtime::IString,
                    delta: &mut Delta,
                    uf: &mut Unification,
                ) -> (Math,) {
                    if let Some((x1,)) = self.iter_all_0_to_1(x0).next() {
                        return (x1,);
                    }
                    let x1 = uf.math_.add_eclass();
                    delta.var_.push((x0, x1));
                    (x1,)
                }
                fn check_0(&self, x0: runtime::IString) -> bool {
                    self.iter_all_0_to_1(x0).next().is_some()
                }
            }
            #[derive(Debug, Default)]
            pub struct Delta {
                fuel_: Vec<<FuelRelation as Relation>::Row>,
                zero_fuel_: Vec<<ZeroFuelRelation as Relation>::Row>,
                diff_: Vec<<DiffRelation as Relation>::Row>,
                integral_: Vec<<IntegralRelation as Relation>::Row>,
                add_: Vec<<AddRelation as Relation>::Row>,
                sub_: Vec<<SubRelation as Relation>::Row>,
                mul_: Vec<<MulRelation as Relation>::Row>,
                div_: Vec<<DivRelation as Relation>::Row>,
                pow_: Vec<<PowRelation as Relation>::Row>,
                ln_: Vec<<LnRelation as Relation>::Row>,
                sqrt_: Vec<<SqrtRelation as Relation>::Row>,
                sin_: Vec<<SinRelation as Relation>::Row>,
                cos_: Vec<<CosRelation as Relation>::Row>,
                const_: Vec<<ConstRelation as Relation>::Row>,
                var_: Vec<<VarRelation as Relation>::Row>,
            }
            impl Delta {
                fn new() -> Self {
                    Self::default()
                }
                fn has_new_inserts(&self) -> bool {
                    let mut has_new_inserts = false;
                    has_new_inserts |= !self.fuel_.is_empty();
                    has_new_inserts |= !self.zero_fuel_.is_empty();
                    has_new_inserts |= !self.diff_.is_empty();
                    has_new_inserts |= !self.integral_.is_empty();
                    has_new_inserts |= !self.add_.is_empty();
                    has_new_inserts |= !self.sub_.is_empty();
                    has_new_inserts |= !self.mul_.is_empty();
                    has_new_inserts |= !self.div_.is_empty();
                    has_new_inserts |= !self.pow_.is_empty();
                    has_new_inserts |= !self.ln_.is_empty();
                    has_new_inserts |= !self.sqrt_.is_empty();
                    has_new_inserts |= !self.sin_.is_empty();
                    has_new_inserts |= !self.cos_.is_empty();
                    has_new_inserts |= !self.const_.is_empty();
                    has_new_inserts |= !self.var_.is_empty();
                    has_new_inserts
                }
                pub fn insert_fuel(&mut self, x: <FuelRelation as Relation>::Row) {
                    self.fuel_.push(x);
                }
                pub fn insert_zero_fuel(&mut self, x: <ZeroFuelRelation as Relation>::Row) {
                    self.zero_fuel_.push(x);
                }
                pub fn insert_diff(&mut self, x: <DiffRelation as Relation>::Row) {
                    self.diff_.push(x);
                }
                pub fn insert_integral(&mut self, x: <IntegralRelation as Relation>::Row) {
                    self.integral_.push(x);
                }
                pub fn insert_add(&mut self, x: <AddRelation as Relation>::Row) {
                    self.add_.push(x);
                }
                pub fn insert_sub(&mut self, x: <SubRelation as Relation>::Row) {
                    self.sub_.push(x);
                }
                pub fn insert_mul(&mut self, x: <MulRelation as Relation>::Row) {
                    self.mul_.push(x);
                }
                pub fn insert_div(&mut self, x: <DivRelation as Relation>::Row) {
                    self.div_.push(x);
                }
                pub fn insert_pow(&mut self, x: <PowRelation as Relation>::Row) {
                    self.pow_.push(x);
                }
                pub fn insert_ln(&mut self, x: <LnRelation as Relation>::Row) {
                    self.ln_.push(x);
                }
                pub fn insert_sqrt(&mut self, x: <SqrtRelation as Relation>::Row) {
                    self.sqrt_.push(x);
                }
                pub fn insert_sin(&mut self, x: <SinRelation as Relation>::Row) {
                    self.sin_.push(x);
                }
                pub fn insert_cos(&mut self, x: <CosRelation as Relation>::Row) {
                    self.cos_.push(x);
                }
                pub fn insert_const(&mut self, x: <ConstRelation as Relation>::Row) {
                    self.const_.push(x);
                }
                pub fn insert_var(&mut self, x: <VarRelation as Relation>::Row) {
                    self.var_.push(x);
                }
            }
            #[derive(Debug, Default)]
            struct Unification {
                pub fuel_unit_: UnionFind<FuelUnit>,
                pub math_: UnionFind<Math>,
            }
            impl Unification {
                fn num_uprooted(&mut self) -> usize {
                    let mut ret = 0;
                    ret += self.fuel_unit_.num_uprooted();
                    ret += self.math_.num_uprooted();
                    ret
                }
                fn reset_num_uprooted(&mut self) {
                    self.fuel_unit_.reset_num_uprooted();
                    self.math_.reset_num_uprooted();
                }
            }
            #[derive(Debug, Default)]
            pub struct Theory {
                pub latest_timestamp: TimeStamp,
                pub delta: Delta,
                pub uf: Unification,
                global_i64: GlobalVars<std::primitive::i64>,
                global_string: GlobalVars<runtime::IString>,
                global_fuel_unit: GlobalVars<FuelUnit>,
                global_math: GlobalVars<Math>,
                pub fuel_: FuelRelation,
                pub zero_fuel_: ZeroFuelRelation,
                pub diff_: DiffRelation,
                pub integral_: IntegralRelation,
                pub add_: AddRelation,
                pub sub_: SubRelation,
                pub mul_: MulRelation,
                pub div_: DivRelation,
                pub pow_: PowRelation,
                pub ln_: LnRelation,
                pub sqrt_: SqrtRelation,
                pub sin_: SinRelation,
                pub cos_: CosRelation,
                pub const_: ConstRelation,
                pub var_: VarRelation,
            }
            impl Theory {
                pub fn new() -> Self {
                    let mut theory = Self::default();
                    theory.global_i64.define(0usize, -1i64);
                    theory.global_i64.define(1usize, 0i64);
                    theory.global_i64.define(2usize, 1i64);
                    theory.global_i64.define(3usize, 2i64);
                    theory.global_fuel_unit.define(0usize, {
                        let tmp_res = theory.uf.fuel_unit_.add_eclass();
                        theory.delta.insert_zero_fuel((tmp_res,));
                        tmp_res
                    });
                    theory.global_fuel_unit.define(1usize, {
                        let tmp0 = theory.global_fuel_unit.get(0usize);
                        let tmp_res = theory.uf.fuel_unit_.add_eclass();
                        theory.delta.insert_fuel((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_fuel_unit.define(2usize, {
                        let tmp0 = theory.global_fuel_unit.get(1usize);
                        let tmp_res = theory.uf.fuel_unit_.add_eclass();
                        theory.delta.insert_fuel((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_fuel_unit.define(3usize, {
                        let tmp0 = theory.global_fuel_unit.get(2usize);
                        let tmp_res = theory.uf.fuel_unit_.add_eclass();
                        theory.delta.insert_fuel((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_string.define(0usize, IString(0u32));
                    theory.global_math.define(0usize, {
                        let tmp0 = theory.global_string.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_var((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(1usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_ln((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(2usize, {
                        let tmp0 = theory.global_fuel_unit.get(3usize);
                        let tmp1 = theory.global_math.get(1usize);
                        let tmp2 = theory.global_math.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_integral((tmp0, tmp1, tmp2, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(3usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_cos((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(4usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(3usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_add((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(5usize, {
                        let tmp0 = theory.global_fuel_unit.get(3usize);
                        let tmp1 = theory.global_math.get(4usize);
                        let tmp2 = theory.global_math.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_integral((tmp0, tmp1, tmp2, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(6usize, {
                        let tmp0 = theory.global_math.get(3usize);
                        let tmp1 = theory.global_math.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_mul((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(7usize, {
                        let tmp0 = theory.global_fuel_unit.get(3usize);
                        let tmp1 = theory.global_math.get(6usize);
                        let tmp2 = theory.global_math.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_integral((tmp0, tmp1, tmp2, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(8usize, {
                        let tmp0 = theory.global_i64.get(2usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(9usize, {
                        let tmp0 = theory.global_i64.get(3usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(10usize, {
                        let tmp0 = theory.global_math.get(9usize);
                        let tmp1 = theory.global_math.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_mul((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(11usize, {
                        let tmp0 = theory.global_math.get(8usize);
                        let tmp1 = theory.global_math.get(10usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_add((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(12usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(11usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_diff((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_i64.define(4usize, 3i64);
                    theory.global_math.define(13usize, {
                        let tmp0 = theory.global_i64.get(4usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(14usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(13usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_pow((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_i64.define(5usize, 7i64);
                    theory.global_math.define(15usize, {
                        let tmp0 = theory.global_i64.get(5usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_const((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(16usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(9usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_pow((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(17usize, {
                        let tmp0 = theory.global_math.get(15usize);
                        let tmp1 = theory.global_math.get(16usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_mul((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(18usize, {
                        let tmp0 = theory.global_math.get(14usize);
                        let tmp1 = theory.global_math.get(17usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_sub((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(19usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(18usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_diff((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_string.define(1usize, IString(1u32));
                    theory.global_math.define(20usize, {
                        let tmp0 = theory.global_string.get(1usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_var((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(21usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(20usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_add((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(22usize, {
                        let tmp0 = theory.global_math.get(20usize);
                        let tmp1 = theory.global_math.get(21usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_mul((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(23usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(9usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_add((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(24usize, {
                        let tmp0 = theory.global_math.get(0usize);
                        let tmp1 = theory.global_math.get(0usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_add((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(25usize, {
                        let tmp0 = theory.global_math.get(23usize);
                        let tmp1 = theory.global_math.get(24usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_sub((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(26usize, {
                        let tmp0 = theory.global_math.get(22usize);
                        let tmp1 = theory.global_math.get(25usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_add((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_string.define(2usize, IString(2u32));
                    theory.global_math.define(27usize, {
                        let tmp0 = theory.global_string.get(2usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_var((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(28usize, {
                        let tmp0 = theory.global_math.get(27usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_sqrt((tmp0, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(29usize, {
                        let tmp0 = theory.global_math.get(8usize);
                        let tmp1 = theory.global_math.get(28usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_add((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(30usize, {
                        let tmp0 = theory.global_math.get(29usize);
                        let tmp1 = theory.global_math.get(9usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_div((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(31usize, {
                        let tmp0 = theory.global_math.get(8usize);
                        let tmp1 = theory.global_math.get(28usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_sub((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(32usize, {
                        let tmp0 = theory.global_math.get(31usize);
                        let tmp1 = theory.global_math.get(9usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_div((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(33usize, {
                        let tmp0 = theory.global_math.get(30usize);
                        let tmp1 = theory.global_math.get(32usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_sub((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.global_math.define(34usize, {
                        let tmp0 = theory.global_math.get(8usize);
                        let tmp1 = theory.global_math.get(33usize);
                        let tmp_res = theory.uf.math_.add_eclass();
                        theory.delta.insert_div((tmp0, tmp1, tmp_res));
                        tmp_res
                    });
                    theory.canonicalize();
                    theory
                }
                pub fn step(&mut self) -> [std::time::Duration; 2] {
                    log_duration!("======== STEP took {} ==========", {
                        [
                            {
                                let start = std::time::Instant::now();
                                log_duration!("apply_rules: {}", {
                                    self.deferred_update();
                                    self.apply_rules();
                                });
                                start.elapsed()
                            },
                            {
                                let start = std::time::Instant::now();
                                self.canonicalize();
                                start.elapsed()
                            },
                        ]
                    })
                }
                #[inline(never)]
                pub fn apply_rules(&mut self) {
                    for (qfuel_3, qv203) in self.fuel_.iter_new() {
                        for (qv229, qx_21, qv230) in self.integral_.iter_all_0_to_1_2_3(qv203) {
                            for (qf, qg) in self.add_.iter_all_2_to_0_1(qv229) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Add f g ) x ) ( Add ( Integral fuel f x ) ( Integral fuel g x ) ) )"]
                                let (qv249,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_3,
                                    qg,
                                    qx_21,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                let (qv248,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_3,
                                    qf,
                                    qx_21,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                self.delta.insert_add((qv248, qv249, qv230));
                                self.delta.insert_add((qv249, qv248, qv230));
                            }
                            for (qf_4, qg_4) in self.sub_.iter_all_2_to_0_1(qv229) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Sub f g ) x ) ( Sub ( Integral fuel f x ) ( Integral fuel g x ) ) )"]
                                let (qv276,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_3,
                                    qg_4,
                                    qx_21,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                let (qv275,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_3,
                                    qf_4,
                                    qx_21,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                self.delta.insert_sub((qv275, qv276, qv230));
                            }
                            for (qa_27, qb_18) in self.mul_.iter_all_2_to_0_1(qv229) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Mul a b ) x ) ( Sub ( Mul a ( Integral fuel b x ) ) ( Integral fuel ( Mul ( Diff x a ) ( Integral fuel b x ) ) x ) ) )"]
                                let (qv302,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_3,
                                    qb_18,
                                    qx_21,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                let (qv303,) =
                                    self.mul_
                                        .entry_0_1_to_2(qa_27, qv302, &mut self.delta, &mut self.uf);
                                self.delta.insert_mul((qv302, qa_27, qv303));
                                let (qv304,) =
                                    self.diff_
                                        .entry_0_1_to_2(qx_21, qa_27, &mut self.delta, &mut self.uf);
                                let (qv305,) =
                                    self.mul_
                                        .entry_0_1_to_2(qv302, qv304, &mut self.delta, &mut self.uf);
                                self.delta.insert_mul((qv304, qv302, qv305));
                                let (qv306,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_3,
                                    qv305,
                                    qx_21,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                self.delta.insert_sub((qv303, qv306, qv230));
                            }
                            if self.cos_.check_0_1(qx_21, qv229) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Cos x ) x ) ( Sin x ) )"]
                                self.delta.insert_sin((qx_21, qv230));
                            }
                        }
                        if let qv204 = self.global_i64.get(2usize) {
                            for (qv205,) in self.const_.iter_all_0_to_1(qv204) {
                                for (qx_17, qv207) in self.integral_.iter_all_0_1_to_2_3(qv203, qv205) {
                                    #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )"]
                                    self.uf.math_.union(qx_17, qv207);
                                }
                            }
                        }
                    }
                    for (qx_3, qv21, qv22) in self.diff_.iter_new() {
                        for (qa_23, qb_14) in self.add_.iter_all_2_to_0_1(qv21) {
                            #[doc = "( rewrite ( Diff x ( Add a b ) ) ( Add ( Diff x a ) ( Diff x b ) ) )"]
                            let (qv170,) =
                                self.diff_
                                    .entry_0_1_to_2(qx_3, qb_14, &mut self.delta, &mut self.uf);
                            let (qv169,) =
                                self.diff_
                                    .entry_0_1_to_2(qx_3, qa_23, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv169, qv170, qv22));
                            self.delta.insert_add((qv170, qv169, qv22));
                        }
                        for (qa_25, qb_16) in self.mul_.iter_all_2_to_0_1(qv21) {
                            #[doc = "( rewrite ( Diff x ( Mul a b ) ) ( Add ( Mul a ( Diff x b ) ) ( Mul b ( Diff x a ) ) ) )"]
                            let (qv183,) =
                                self.diff_
                                    .entry_0_1_to_2(qx_3, qb_16, &mut self.delta, &mut self.uf);
                            let (qv184,) =
                                self.mul_
                                    .entry_0_1_to_2(qa_25, qv183, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qv183, qa_25, qv184));
                            let (qv185,) =
                                self.diff_
                                    .entry_0_1_to_2(qx_3, qa_25, &mut self.delta, &mut self.uf);
                            let (qv186,) =
                                self.mul_
                                    .entry_0_1_to_2(qb_16, qv185, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv184, qv186, qv22));
                            self.delta.insert_add((qv186, qv184, qv22));
                            self.delta.insert_mul((qv185, qb_16, qv186));
                        }
                        if self.sin_.check_0_1(qx_3, qv21) {
                            #[doc = "( rewrite ( Diff x ( Sin x ) ) ( Cos x ) )"]
                            self.delta.insert_cos((qx_3, qv22));
                        }
                        if self.cos_.check_0_1(qx_3, qv21) {
                            #[doc = "( rewrite ( Diff x ( Cos x ) ) ( Mul ( Const -1 ) ( Sin x ) ) )"]
                            let qv23 = self.global_i64.get(0usize);
                            let (qv24,) = self
                                .const_
                                .entry_0_to_1(qv23, &mut self.delta, &mut self.uf);
                            let (qv25,) = self.sin_.entry_0_to_1(qx_3, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qv24, qv25, qv22));
                            self.delta.insert_mul((qv25, qv24, qv22));
                        }
                    }
                    for (qfuel, qv2, qx, qv3) in self.integral_.iter_new() {
                        if self.sin_.check_0_1(qx, qv2) {
                            #[doc = "( rewrite ( Integral fuel ( Sin x ) x ) ( Mul ( Const -1 ) ( Cos x ) ) )"]
                            let qv4 = self.global_i64.get(0usize);
                            let (qv5,) = self.const_.entry_0_to_1(qv4, &mut self.delta, &mut self.uf);
                            let (qv6,) = self.cos_.entry_0_to_1(qx, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qv5, qv6, qv3));
                            self.delta.insert_mul((qv6, qv5, qv3));
                        }
                        if self.cos_.check_0_1(qx, qv2) {
                            for (qfuel_8,) in self.fuel_.iter_old_1_to_0(qfuel, self.latest_timestamp) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Cos x ) x ) ( Sin x ) )"]
                                self.delta.insert_sin((qx, qv3));
                            }
                        }
                        if let qv210 = self.global_i64.get(2usize) {
                            if self.const_.check_0_1(qv210, qv2) {
                                for (qfuel_4,) in self.fuel_.iter_old_1_to_0(qfuel, self.latest_timestamp) {
                                    #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )"]
                                    self.uf.math_.union(qx, qv3);
                                }
                            }
                        }
                        if self.add_.check_2(qv2) {
                            for (qfuel_11,) in self.fuel_.iter_old_1_to_0(qfuel, self.latest_timestamp) {
                                for (qf_2, qg_2) in self.add_.iter_all_2_to_0_1(qv2) {
                                    #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Add f g ) x ) ( Add ( Integral fuel f x ) ( Integral fuel g x ) ) )"]
                                    let (qv258,) = self.integral_.entry_0_1_2_to_3(
                                        qfuel_11,
                                        qg_2,
                                        qx,
                                        &mut self.delta,
                                        &mut self.uf,
                                    );
                                    let (qv257,) = self.integral_.entry_0_1_2_to_3(
                                        qfuel_11,
                                        qf_2,
                                        qx,
                                        &mut self.delta,
                                        &mut self.uf,
                                    );
                                    self.delta.insert_add((qv257, qv258, qv3));
                                    self.delta.insert_add((qv258, qv257, qv3));
                                }
                            }
                        }
                        if self.sub_.check_2(qv2) {
                            for (qfuel_14,) in self.fuel_.iter_old_1_to_0(qfuel, self.latest_timestamp) {
                                for (qf_5, qg_5) in self.sub_.iter_all_2_to_0_1(qv2) {
                                    #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Sub f g ) x ) ( Sub ( Integral fuel f x ) ( Integral fuel g x ) ) )"]
                                    let (qv285,) = self.integral_.entry_0_1_2_to_3(
                                        qfuel_14,
                                        qg_5,
                                        qx,
                                        &mut self.delta,
                                        &mut self.uf,
                                    );
                                    let (qv284,) = self.integral_.entry_0_1_2_to_3(
                                        qfuel_14,
                                        qf_5,
                                        qx,
                                        &mut self.delta,
                                        &mut self.uf,
                                    );
                                    self.delta.insert_sub((qv284, qv285, qv3));
                                }
                            }
                        }
                        if self.mul_.check_2(qv2) {
                            for (qfuel_17,) in self.fuel_.iter_old_1_to_0(qfuel, self.latest_timestamp) {
                                for (qa_28, qb_19) in self.mul_.iter_all_2_to_0_1(qv2) {
                                    #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Mul a b ) x ) ( Sub ( Mul a ( Integral fuel b x ) ) ( Integral fuel ( Mul ( Diff x a ) ( Integral fuel b x ) ) x ) ) )"]
                                    let (qv314,) = self.integral_.entry_0_1_2_to_3(
                                        qfuel_17,
                                        qb_19,
                                        qx,
                                        &mut self.delta,
                                        &mut self.uf,
                                    );
                                    let (qv315,) =
                                        self.mul_
                                            .entry_0_1_to_2(qa_28, qv314, &mut self.delta, &mut self.uf);
                                    self.delta.insert_mul((qv314, qa_28, qv315));
                                    let (qv316,) =
                                        self.diff_
                                            .entry_0_1_to_2(qx, qa_28, &mut self.delta, &mut self.uf);
                                    let (qv317,) =
                                        self.mul_
                                            .entry_0_1_to_2(qv314, qv316, &mut self.delta, &mut self.uf);
                                    self.delta.insert_mul((qv316, qv314, qv317));
                                    let (qv318,) = self.integral_.entry_0_1_2_to_3(
                                        qfuel_17,
                                        qv317,
                                        qx,
                                        &mut self.delta,
                                        &mut self.uf,
                                    );
                                    self.delta.insert_sub((qv315, qv318, qv3));
                                }
                            }
                        }
                    }
                    for (qa_2, qb_2, qv34) in self.add_.iter_new() {
                        {
                            self.delta.insert_add((qa_2, qb_2, qv34));
                            self.delta.insert_add((qb_2, qa_2, qv34));
                        }
                        for (qx_12, qv175) in self.diff_.iter_old_1_to_0_2(qv34, self.latest_timestamp) {
                            #[doc = "( rewrite ( Diff x ( Add a b ) ) ( Add ( Diff x a ) ( Diff x b ) ) )"]
                            let (qv177,) =
                                self.diff_
                                    .entry_0_1_to_2(qx_12, qb_2, &mut self.delta, &mut self.uf);
                            let (qv176,) =
                                self.diff_
                                    .entry_0_1_to_2(qx_12, qa_2, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv176, qv177, qv175));
                            self.delta.insert_add((qv177, qv176, qv175));
                        }
                        for (qv260, qx_26, qv265) in self
                            .integral_
                            .iter_old_1_to_0_2_3(qv34, self.latest_timestamp)
                        {
                            for (qfuel_12,) in self.fuel_.iter_old_1_to_0(qv260, self.latest_timestamp) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Add f g ) x ) ( Add ( Integral fuel f x ) ( Integral fuel g x ) ) )"]
                                let (qv267,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_12,
                                    qb_2,
                                    qx_26,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                let (qv266,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_12,
                                    qa_2,
                                    qx_26,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                self.delta.insert_add((qv266, qv267, qv265));
                                self.delta.insert_add((qv267, qv266, qv265));
                            }
                        }
                        for (qb_4, qc) in self.add_.iter_all_2_to_0_1(qb_2) {
                            #[doc = "( rewrite ( Add a ( Add b c ) ) ( Add ( Add a b ) c ) )"]
                            let (qv43,) = self
                                .add_
                                .entry_0_1_to_2(qa_2, qb_4, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qb_4, qa_2, qv43));
                            self.delta.insert_add((qc, qv43, qv34));
                            self.delta.insert_add((qv43, qc, qv34));
                        }
                        for (qa_5, qv48) in self.add_.iter_old_0_to_1_2(qv34, self.latest_timestamp) {
                            #[doc = "( rewrite ( Add a ( Add b c ) ) ( Add ( Add a b ) c ) )"]
                            let (qv49,) = self
                                .add_
                                .entry_0_1_to_2(qa_5, qa_2, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qa_2, qa_5, qv49));
                            self.delta.insert_add((qb_2, qv49, qv48));
                            self.delta.insert_add((qv49, qb_2, qv48));
                        }
                        for (qa_17, qv102) in self.mul_.iter_all_0_to_1_2(qv34) {
                            #[doc = "( rewrite ( Mul a ( Add b c ) ) ( Add ( Mul a b ) ( Mul a c ) ) )"]
                            let (qv104,) = self
                                .mul_
                                .entry_0_1_to_2(qa_17, qb_2, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qb_2, qa_17, qv104));
                            let (qv103,) = self
                                .mul_
                                .entry_0_1_to_2(qa_17, qa_2, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv103, qv104, qv102));
                            self.delta.insert_add((qv104, qv103, qv102));
                            self.delta.insert_mul((qa_2, qa_17, qv103));
                        }
                        if let qv63 = self.global_i64.get(1usize) {
                            if self.const_.check_0_1(qv63, qb_2) {
                                #[doc = "( rewrite ( Add a ( Const 0 ) ) a )"]
                                self.uf.math_.union(qa_2, qv34);
                            }
                        }
                        if self.mul_.check_2(qa_2) {
                            for (qa_19, qc_7) in self.mul_.iter_all_2_to_0_1(qb_2) {
                                for (qb_10,) in self.mul_.iter_all_0_2_to_1(qa_19, qa_2) {
                                    #[doc = "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"]
                                    let (qv118,) =
                                        self.add_
                                            .entry_0_1_to_2(qb_10, qc_7, &mut self.delta, &mut self.uf);
                                    self.delta.insert_add((qc_7, qb_10, qv118));
                                    self.delta.insert_mul((qa_19, qv118, qv34));
                                    self.delta.insert_mul((qv118, qa_19, qv34));
                                }
                            }
                        }
                    }
                    for (qa, qb, qv16) in self.sub_.iter_new() {
                        {
                            let qv17 = self.global_i64.get(0usize);
                            let (qv18,) = self
                                .const_
                                .entry_0_to_1(qv17, &mut self.delta, &mut self.uf);
                            let (qv19,) = self
                                .mul_
                                .entry_0_1_to_2(qb, qv18, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qa, qv19, qv16));
                            self.delta.insert_add((qv19, qa, qv16));
                            self.delta.insert_mul((qv18, qb, qv19));
                        }
                        for (qv287, qx_29, qv292) in self
                            .integral_
                            .iter_old_1_to_0_2_3(qv16, self.latest_timestamp)
                        {
                            for (qfuel_15,) in self.fuel_.iter_old_1_to_0(qv287, self.latest_timestamp) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Sub f g ) x ) ( Sub ( Integral fuel f x ) ( Integral fuel g x ) ) )"]
                                let (qv294,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_15,
                                    qb,
                                    qx_29,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                let (qv293,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_15,
                                    qa,
                                    qx_29,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                self.delta.insert_sub((qv293, qv294, qv292));
                            }
                        }
                    }
                    for (qa_3, qb_3, qv37) in self.mul_.iter_new() {
                        {
                            self.delta.insert_mul((qa_3, qb_3, qv37));
                            self.delta.insert_mul((qb_3, qa_3, qv37));
                        }
                        for (qx_14, qv191) in self.diff_.iter_old_1_to_0_2(qv37, self.latest_timestamp) {
                            #[doc = "( rewrite ( Diff x ( Mul a b ) ) ( Add ( Mul a ( Diff x b ) ) ( Mul b ( Diff x a ) ) ) )"]
                            let (qv192,) =
                                self.diff_
                                    .entry_0_1_to_2(qx_14, qb_3, &mut self.delta, &mut self.uf);
                            let (qv193,) = self
                                .mul_
                                .entry_0_1_to_2(qa_3, qv192, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qv192, qa_3, qv193));
                            let (qv194,) =
                                self.diff_
                                    .entry_0_1_to_2(qx_14, qa_3, &mut self.delta, &mut self.uf);
                            let (qv195,) = self
                                .mul_
                                .entry_0_1_to_2(qb_3, qv194, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv193, qv195, qv191));
                            self.delta.insert_add((qv195, qv193, qv191));
                            self.delta.insert_mul((qv194, qb_3, qv195));
                        }
                        for (qv320, qx_32, qv325) in self
                            .integral_
                            .iter_old_1_to_0_2_3(qv37, self.latest_timestamp)
                        {
                            for (qfuel_18,) in self.fuel_.iter_old_1_to_0(qv320, self.latest_timestamp) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Mul a b ) x ) ( Sub ( Mul a ( Integral fuel b x ) ) ( Integral fuel ( Mul ( Diff x a ) ( Integral fuel b x ) ) x ) ) )"]
                                let (qv326,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_18,
                                    qb_3,
                                    qx_32,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                let (qv327,) =
                                    self.mul_
                                        .entry_0_1_to_2(qa_3, qv326, &mut self.delta, &mut self.uf);
                                self.delta.insert_mul((qv326, qa_3, qv327));
                                let (qv328,) =
                                    self.diff_
                                        .entry_0_1_to_2(qx_32, qa_3, &mut self.delta, &mut self.uf);
                                let (qv329,) =
                                    self.mul_
                                        .entry_0_1_to_2(qv326, qv328, &mut self.delta, &mut self.uf);
                                self.delta.insert_mul((qv328, qv326, qv329));
                                let (qv330,) = self.integral_.entry_0_1_2_to_3(
                                    qfuel_18,
                                    qv329,
                                    qx_32,
                                    &mut self.delta,
                                    &mut self.uf,
                                );
                                self.delta.insert_sub((qv327, qv330, qv325));
                            }
                        }
                        for (qb_9, qc_6) in self.add_.iter_old_2_to_0_1(qb_3, self.latest_timestamp) {
                            #[doc = "( rewrite ( Mul a ( Add b c ) ) ( Add ( Mul a b ) ( Mul a c ) ) )"]
                            let (qv111,) = self
                                .mul_
                                .entry_0_1_to_2(qa_3, qc_6, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qc_6, qa_3, qv111));
                            let (qv110,) = self
                                .mul_
                                .entry_0_1_to_2(qa_3, qb_9, &mut self.delta, &mut self.uf);
                            self.delta.insert_add((qv110, qv111, qv37));
                            self.delta.insert_add((qv111, qv110, qv37));
                            self.delta.insert_mul((qb_9, qa_3, qv110));
                        }
                        for (qb_6, qc_3) in self.mul_.iter_all_2_to_0_1(qb_3) {
                            #[doc = "( rewrite ( Mul a ( Mul b c ) ) ( Mul ( Mul a b ) c ) )"]
                            let (qv55,) = self
                                .mul_
                                .entry_0_1_to_2(qa_3, qb_6, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qb_6, qa_3, qv55));
                            self.delta.insert_mul((qc_3, qv55, qv37));
                            self.delta.insert_mul((qv55, qc_3, qv37));
                        }
                        for (qa_7, qv60) in self.mul_.iter_old_0_to_1_2(qv37, self.latest_timestamp) {
                            #[doc = "( rewrite ( Mul a ( Mul b c ) ) ( Mul ( Mul a b ) c ) )"]
                            let (qv61,) = self
                                .mul_
                                .entry_0_1_to_2(qa_7, qa_3, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qa_3, qa_7, qv61));
                            self.delta.insert_mul((qb_3, qv61, qv60));
                            self.delta.insert_mul((qv61, qb_3, qv60));
                        }
                        if let qv75 = self.global_i64.get(1usize) {
                            if self.const_.check_0_1(qv75, qb_3) {
                                #[doc = "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"]
                                self.uf.math_.union(qb_3, qv37);
                            }
                        }
                        if let qv87 = self.global_i64.get(2usize) {
                            if self.const_.check_0_1(qv87, qb_3) {
                                #[doc = "( rewrite ( Mul a ( Const 1 ) ) a )"]
                                self.uf.math_.union(qa_3, qv37);
                            }
                        }
                        if self.mul_.check_0(qa_3) {
                            for (qv123, qv124) in self.add_.iter_old_0_to_1_2(qv37, self.latest_timestamp) {
                                for (qc_8,) in self.mul_.iter_all_0_2_to_1(qa_3, qv123) {
                                    #[doc = "( rewrite ( Add ( Mul a b ) ( Mul a c ) ) ( Mul a ( Add b c ) ) )"]
                                    let (qv125,) =
                                        self.add_
                                            .entry_0_1_to_2(qb_3, qc_8, &mut self.delta, &mut self.uf);
                                    self.delta.insert_add((qc_8, qb_3, qv125));
                                    self.delta.insert_mul((qa_3, qv125, qv124));
                                    self.delta.insert_mul((qv125, qa_3, qv124));
                                }
                            }
                        }
                        if self.pow_.check_2(qa_3) {
                            for (qa_21, qc_9) in self.pow_.iter_all_2_to_0_1(qb_3) {
                                for (qb_12,) in self.pow_.iter_all_0_2_to_1(qa_21, qa_3) {
                                    #[doc = "( rewrite ( Mul ( Pow a b ) ( Pow a c ) ) ( Pow a ( Add b c ) ) )"]
                                    let (qv132,) =
                                        self.add_
                                            .entry_0_1_to_2(qb_12, qc_9, &mut self.delta, &mut self.uf);
                                    self.delta.insert_add((qc_9, qb_12, qv132));
                                    self.delta.insert_pow((qa_21, qv132, qv37));
                                }
                            }
                        }
                    }
                    for (qa_22, qb_13, qv135) in self.pow_.iter_new() {
                        if let qv141 = self.global_i64.get(2usize) {
                            if self.const_.check_0_1(qv141, qb_13) {
                                #[doc = "( rewrite ( Pow x ( Const 1 ) ) x )"]
                                self.uf.math_.union(qa_22, qv135);
                            }
                        }
                        if let qv153 = self.global_i64.get(3usize) {
                            if self.const_.check_0_1(qv153, qb_13) {
                                #[doc = "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"]
                                self.delta.insert_mul((qa_22, qa_22, qv135));
                            }
                        }
                        if self.pow_.check_0(qa_22) {
                            for (qv137, qv138) in self.mul_.iter_old_0_to_1_2(qv135, self.latest_timestamp) {
                                for (qc_10,) in self.pow_.iter_all_0_2_to_1(qa_22, qv137) {
                                    #[doc = "( rewrite ( Mul ( Pow a b ) ( Pow a c ) ) ( Pow a ( Add b c ) ) )"]
                                    let (qv139,) =
                                        self.add_
                                            .entry_0_1_to_2(qb_13, qc_10, &mut self.delta, &mut self.uf);
                                    self.delta.insert_add((qc_10, qb_13, qv139));
                                    self.delta.insert_pow((qa_22, qv139, qv138));
                                }
                            }
                        }
                    }
                    for (qx_2, qv9) in self.sin_.iter_new() {
                        for (qv201,) in self
                            .diff_
                            .iter_old_0_1_to_2(qx_2, qv9, self.latest_timestamp)
                        {
                            #[doc = "( rewrite ( Diff x ( Sin x ) ) ( Cos x ) )"]
                            self.delta.insert_cos((qx_2, qv201));
                        }
                        for (qfuel_2, qv10) in
                            self.integral_
                                .iter_old_1_2_to_0_3(qv9, qx_2, self.latest_timestamp)
                        {
                            #[doc = "( rewrite ( Integral fuel ( Sin x ) x ) ( Mul ( Const -1 ) ( Cos x ) ) )"]
                            let qv11 = self.global_i64.get(0usize);
                            let (qv12,) = self
                                .const_
                                .entry_0_to_1(qv11, &mut self.delta, &mut self.uf);
                            let (qv13,) = self.cos_.entry_0_to_1(qx_2, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qv12, qv13, qv10));
                            self.delta.insert_mul((qv13, qv12, qv10));
                        }
                    }
                    for (qx_4, qv27) in self.cos_.iter_new() {
                        for (qv28,) in self
                            .diff_
                            .iter_old_0_1_to_2(qx_4, qv27, self.latest_timestamp)
                        {
                            #[doc = "( rewrite ( Diff x ( Cos x ) ) ( Mul ( Const -1 ) ( Sin x ) ) )"]
                            let qv29 = self.global_i64.get(0usize);
                            let (qv30,) = self
                                .const_
                                .entry_0_to_1(qv29, &mut self.delta, &mut self.uf);
                            let (qv31,) = self.sin_.entry_0_to_1(qx_4, &mut self.delta, &mut self.uf);
                            self.delta.insert_mul((qv30, qv31, qv28));
                            self.delta.insert_mul((qv31, qv30, qv28));
                        }
                        for (qv237, qv240) in
                            self.integral_
                                .iter_old_1_2_to_0_3(qv27, qx_4, self.latest_timestamp)
                        {
                            for (qfuel_9,) in self.fuel_.iter_old_1_to_0(qv237, self.latest_timestamp) {
                                #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Cos x ) x ) ( Sin x ) )"]
                                self.delta.insert_sin((qx_4, qv240));
                            }
                        }
                    }
                    for (qv67, qv68) in self.const_.iter_new() {
                        if qv67 == self.global_i64.get(1usize) {
                            for (qa_9, qv69) in self.add_.iter_old_0_to_1_2(qv68, self.latest_timestamp) {
                                #[doc = "( rewrite ( Add a ( Const 0 ) ) a )"]
                                self.uf.math_.union(qa_9, qv69);
                            }
                            for (qa_12, qv81) in self.mul_.iter_old_0_to_1_2(qv68, self.latest_timestamp) {
                                #[doc = "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"]
                                self.uf.math_.union(qv68, qv81);
                            }
                        }
                        if qv67 == self.global_i64.get(2usize) {
                            for (qv215, qx_19, qv219) in self
                                .integral_
                                .iter_old_1_to_0_2_3(qv68, self.latest_timestamp)
                            {
                                for (qfuel_5,) in self.fuel_.iter_old_1_to_0(qv215, self.latest_timestamp) {
                                    #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )"]
                                    self.uf.math_.union(qx_19, qv219);
                                }
                            }
                            for (qa_15, qv93) in self.mul_.iter_old_0_to_1_2(qv68, self.latest_timestamp) {
                                #[doc = "( rewrite ( Mul a ( Const 1 ) ) a )"]
                                self.uf.math_.union(qa_15, qv93);
                            }
                            for (qx_6, qv147) in self.pow_.iter_old_1_to_0_2(qv68, self.latest_timestamp) {
                                #[doc = "( rewrite ( Pow x ( Const 1 ) ) x )"]
                                self.uf.math_.union(qx_6, qv147);
                            }
                        }
                        if qv67 == self.global_i64.get(3usize) {
                            for (qx_9, qv159) in self.pow_.iter_old_1_to_0_2(qv68, self.latest_timestamp) {
                                #[doc = "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"]
                                self.delta.insert_mul((qx_9, qx_9, qv159));
                            }
                        }
                    }
                    if let Some(qv71) = self.global_i64.get_new(1usize) {
                        for (qv72,) in self.const_.iter_old_0_to_1(qv71, self.latest_timestamp) {
                            for (qa_10, qv73) in self.add_.iter_old_0_to_1_2(qv72, self.latest_timestamp) {
                                #[doc = "( rewrite ( Add a ( Const 0 ) ) a )"]
                                self.uf.math_.union(qa_10, qv73);
                            }
                            for (qa_13, qv85) in self.mul_.iter_old_0_to_1_2(qv72, self.latest_timestamp) {
                                #[doc = "( rewrite ( Mul a ( Const 0 ) ) ( Const 0 ) )"]
                                self.uf.math_.union(qv72, qv85);
                            }
                        }
                    }
                    if let Some(qv95) = self.global_i64.get_new(2usize) {
                        for (qv96,) in self.const_.iter_old_0_to_1(qv95, self.latest_timestamp) {
                            for (qv221, qx_20, qv225) in self
                                .integral_
                                .iter_old_1_to_0_2_3(qv96, self.latest_timestamp)
                            {
                                for (qfuel_6,) in self.fuel_.iter_old_1_to_0(qv221, self.latest_timestamp) {
                                    #[doc = "( rewrite ( Integral ( Fuel fuel ) ( Const 1 ) x ) x )"]
                                    self.uf.math_.union(qx_20, qv225);
                                }
                            }
                            for (qa_16, qv97) in self.mul_.iter_old_0_to_1_2(qv96, self.latest_timestamp) {
                                #[doc = "( rewrite ( Mul a ( Const 1 ) ) a )"]
                                self.uf.math_.union(qa_16, qv97);
                            }
                            for (qx_7, qv151) in self.pow_.iter_old_1_to_0_2(qv96, self.latest_timestamp) {
                                #[doc = "( rewrite ( Pow x ( Const 1 ) ) x )"]
                                self.uf.math_.union(qx_7, qv151);
                            }
                        }
                    }
                    if let Some(qv161) = self.global_i64.get_new(3usize) {
                        for (qv162,) in self.const_.iter_old_0_to_1(qv161, self.latest_timestamp) {
                            for (qx_10, qv163) in self.pow_.iter_old_1_to_0_2(qv162, self.latest_timestamp) {
                                #[doc = "( rewrite ( Pow x ( Const 2 ) ) ( Mul x x ) )"]
                                self.delta.insert_mul((qx_10, qx_10, qv163));
                            }
                        }
                    }
                }
                fn emit_graphviz(&self) -> String {
                    let mut buf = String::new();
                    buf.push_str("digraph G {\n");
                    self.fuel_.emit_graphviz(&mut buf);
                    self.zero_fuel_.emit_graphviz(&mut buf);
                    self.diff_.emit_graphviz(&mut buf);
                    self.integral_.emit_graphviz(&mut buf);
                    self.add_.emit_graphviz(&mut buf);
                    self.sub_.emit_graphviz(&mut buf);
                    self.mul_.emit_graphviz(&mut buf);
                    self.div_.emit_graphviz(&mut buf);
                    self.pow_.emit_graphviz(&mut buf);
                    self.ln_.emit_graphviz(&mut buf);
                    self.sqrt_.emit_graphviz(&mut buf);
                    self.sin_.emit_graphviz(&mut buf);
                    self.cos_.emit_graphviz(&mut buf);
                    self.const_.emit_graphviz(&mut buf);
                    self.var_.emit_graphviz(&mut buf);
                    buf.push_str("}\n");
                    buf
                }
                pub fn get_total_relation_entry_count(&self) -> usize {
                    self.get_relation_entry_count().values().sum()
                }
                pub fn get_relation_entry_count(&self) -> std::collections::BTreeMap<&'static str, usize> {
                    [
                        ("Fuel", self.fuel_.len()),
                        ("ZeroFuel", self.zero_fuel_.len()),
                        ("Diff", self.diff_.len()),
                        ("Integral", self.integral_.len()),
                        ("Add", self.add_.len()),
                        ("Sub", self.sub_.len()),
                        ("Mul", self.mul_.len()),
                        ("Div", self.div_.len()),
                        ("Pow", self.pow_.len()),
                        ("Ln", self.ln_.len()),
                        ("Sqrt", self.sqrt_.len()),
                        ("Sin", self.sin_.len()),
                        ("Cos", self.cos_.len()),
                        ("Const", self.const_.len()),
                        ("Var", self.var_.len()),
                    ]
                    .into_iter()
                    .collect()
                }
                pub fn get_total_uf_count(&self) -> (usize, usize) {
                    self.get_uf_count()
                        .values()
                        .fold((0, 0), |(at, ar), (t, r)| (at + t, ar + r))
                }
                pub fn get_uf_count(&self) -> std::collections::BTreeMap<&'static str, (usize, usize)> {
                    [
                        (
                            "FuelUnit",
                            (self.uf.fuel_unit_.len(), self.uf.fuel_unit_.num_roots()),
                        ),
                        ("Math", (self.uf.math_.len(), self.uf.math_.num_roots())),
                    ]
                    .into_iter()
                    .collect()
                }
                #[inline(never)]
                pub fn canonicalize(&mut self) {
                    self.latest_timestamp.0 += 1;
                    log_duration!("canonicalize (total): {}", {
                        self.fuel_.clear_new();
                        self.zero_fuel_.clear_new();
                        self.diff_.clear_new();
                        self.integral_.clear_new();
                        self.add_.clear_new();
                        self.sub_.clear_new();
                        self.mul_.clear_new();
                        self.div_.clear_new();
                        self.pow_.clear_new();
                        self.ln_.clear_new();
                        self.sqrt_.clear_new();
                        self.sin_.clear_new();
                        self.cos_.clear_new();
                        self.const_.clear_new();
                        self.var_.clear_new();
                        if !self.delta.has_new_inserts() && self.uf.num_uprooted() == 0 {
                            return;
                        }
                        log_duration!("update_begin (total): {}", {
                            self.fuel_
                                .update_begin(&mut self.delta.fuel_, &mut self.uf, self.latest_timestamp);
                            self.zero_fuel_.update_begin(
                                &mut self.delta.zero_fuel_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.diff_
                                .update_begin(&mut self.delta.diff_, &mut self.uf, self.latest_timestamp);
                            self.integral_.update_begin(
                                &mut self.delta.integral_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.add_
                                .update_begin(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                            self.sub_
                                .update_begin(&mut self.delta.sub_, &mut self.uf, self.latest_timestamp);
                            self.mul_
                                .update_begin(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                            self.div_
                                .update_begin(&mut self.delta.div_, &mut self.uf, self.latest_timestamp);
                            self.pow_
                                .update_begin(&mut self.delta.pow_, &mut self.uf, self.latest_timestamp);
                            self.ln_
                                .update_begin(&mut self.delta.ln_, &mut self.uf, self.latest_timestamp);
                            self.sqrt_
                                .update_begin(&mut self.delta.sqrt_, &mut self.uf, self.latest_timestamp);
                            self.sin_
                                .update_begin(&mut self.delta.sin_, &mut self.uf, self.latest_timestamp);
                            self.cos_
                                .update_begin(&mut self.delta.cos_, &mut self.uf, self.latest_timestamp);
                            self.const_.update_begin(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.var_
                                .update_begin(&mut self.delta.var_, &mut self.uf, self.latest_timestamp);
                        });
                        log_duration!("update_loop (total): {}", {
                            loop {
                                let mut progress = false;
                                progress |= self.fuel_.update(
                                    &mut self.delta.fuel_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |= self.zero_fuel_.update(
                                    &mut self.delta.zero_fuel_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |= self.diff_.update(
                                    &mut self.delta.diff_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |= self.integral_.update(
                                    &mut self.delta.integral_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |=
                                    self.add_
                                        .update(&mut self.delta.add_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.sub_
                                        .update(&mut self.delta.sub_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.mul_
                                        .update(&mut self.delta.mul_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.div_
                                        .update(&mut self.delta.div_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.pow_
                                        .update(&mut self.delta.pow_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.ln_
                                        .update(&mut self.delta.ln_, &mut self.uf, self.latest_timestamp);
                                progress |= self.sqrt_.update(
                                    &mut self.delta.sqrt_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |=
                                    self.sin_
                                        .update(&mut self.delta.sin_, &mut self.uf, self.latest_timestamp);
                                progress |=
                                    self.cos_
                                        .update(&mut self.delta.cos_, &mut self.uf, self.latest_timestamp);
                                progress |= self.const_.update(
                                    &mut self.delta.const_,
                                    &mut self.uf,
                                    self.latest_timestamp,
                                );
                                progress |=
                                    self.var_
                                        .update(&mut self.delta.var_, &mut self.uf, self.latest_timestamp);
                                if !progress {
                                    break;
                                }
                            }
                        });
                        log_duration!("update_finalize (total): {}", {
                            self.fuel_.update_finalize(
                                &mut self.delta.fuel_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.zero_fuel_.update_finalize(
                                &mut self.delta.zero_fuel_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.diff_.update_finalize(
                                &mut self.delta.diff_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.integral_.update_finalize(
                                &mut self.delta.integral_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.add_.update_finalize(
                                &mut self.delta.add_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.sub_.update_finalize(
                                &mut self.delta.sub_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.mul_.update_finalize(
                                &mut self.delta.mul_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.div_.update_finalize(
                                &mut self.delta.div_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.pow_.update_finalize(
                                &mut self.delta.pow_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.ln_
                                .update_finalize(&mut self.delta.ln_, &mut self.uf, self.latest_timestamp);
                            self.sqrt_.update_finalize(
                                &mut self.delta.sqrt_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.sin_.update_finalize(
                                &mut self.delta.sin_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.cos_.update_finalize(
                                &mut self.delta.cos_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.const_.update_finalize(
                                &mut self.delta.const_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.var_.update_finalize(
                                &mut self.delta.var_,
                                &mut self.uf,
                                self.latest_timestamp,
                            );
                            self.global_fuel_unit.update(&mut self.uf.fuel_unit_);
                            self.global_math.update(&mut self.uf.math_);
                            self.global_i64.update_finalize();
                            self.global_string.update_finalize();
                            self.global_fuel_unit.update_finalize();
                            self.global_math.update_finalize();
                            self.uf.reset_num_uprooted();
                        });
                    });
                }
                fn deferred_update(&mut self) {
                    self.fuel_.deferred_update();
                    self.zero_fuel_.deferred_update();
                    self.diff_.deferred_update();
                    self.integral_.deferred_update();
                    self.add_.deferred_update();
                    self.sub_.deferred_update();
                    self.mul_.deferred_update();
                    self.div_.deferred_update();
                    self.pow_.deferred_update();
                    self.ln_.deferred_update();
                    self.sqrt_.deferred_update();
                    self.sin_.deferred_update();
                    self.cos_.deferred_update();
                    self.const_.deferred_update();
                    self.var_.deferred_update();
                }
            }
            impl EclassProvider<FuelUnit> for Theory {
                fn make(&mut self) -> FuelUnit {
                    self.uf.fuel_unit_.add_eclass()
                }
                fn find(&mut self, t: FuelUnit) -> FuelUnit {
                    self.uf.fuel_unit_.find(t)
                }
                fn union(&mut self, a: FuelUnit, b: FuelUnit) {
                    self.uf.fuel_unit_.union(a, b);
                }
            }
            impl EclassProvider<Math> for Theory {
                fn make(&mut self) -> Math {
                    self.uf.math_.add_eclass()
                }
                fn find(&mut self, t: Math) -> Math {
                    self.uf.math_.find(t)
                }
                fn union(&mut self, a: Math, b: Math) {
                    self.uf.math_.union(a, b);
                }
            }
            impl std::ops::Deref for Theory {
                type Target = Delta;
                fn deref(&self) -> &Self::Target {
                    &self.delta
                }
            }
            impl std::ops::DerefMut for Theory {
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.delta
                }
            }
        "#]]),
    }
    .check();
}
