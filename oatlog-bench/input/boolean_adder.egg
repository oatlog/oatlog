; https://byjus.com/maths/boolean-algebra-laws/
; This maybe even terminates if somewhat reasonable rules are picked?

(datatype Math
    (And Math Math)
    (Or Math Math)
    (Xor Math Math)
    (Not Math)

    (HalfAddSum Math Math)
    (HalfAddCarry Math Math)
    (FullAddSum Math Math Math)
    (FullAddCarry Math Math Math)

    (Var String)
    (True)
    (False)
)

(rewrite (And x (True)) x)
(rewrite (And x (False)) (False))

(rewrite (Or x (False)) x)
(rewrite (Or x (True)) (True))

(rewrite (Xor x (False)) x)
(rewrite (Xor x (True)) (Not x))

; assertion fails in oatlog
; (rewrite (And x x) x)
; (rewrite (Or x x) x)

(rewrite (And x (Not x)) (False))
(rewrite (Or x (Not x)) (True))
(rewrite (Xor x (Not x)) (True))

(rewrite (And x y) (And y x))
(rewrite (Or x y) (Or y x))
(rewrite (Xor x y) (Xor y x))

(birewrite (And x (Or y z)) (Or (And x y) (And x z)))

(rewrite (And x (Or x y)) x)
(rewrite (Or x (And x y)) x)

; can not be a bi-rewrite because of a lack of forall
(rewrite (Not (Not x)) x)

(birewrite (Not (And x y)) (Or (Not x) (Not y)))
(birewrite (Not (Or x y)) (And (Not x) (Not y)))
(birewrite (Not (Xor x y)) (Xor x (Not y)))
(birewrite (Xor x y) (Xor (Not x) (Not y)))

; could be bi-rewrite, but that would be inverse constant propagation...
(rewrite (And (True) (True)) (True))
(rewrite (And (False) (True)) (False))
(rewrite (And (True) (False)) (False))
(rewrite (And (False) (False)) (False))

(rewrite (Or (True) (True)) (True))
(rewrite (Or (False) (True)) (True))
(rewrite (Or (True) (False)) (True))
(rewrite (Or (False) (False)) (False))

(rewrite (Xor (True) (True)) (False))
(rewrite (Xor (False) (True)) (True))
(rewrite (Xor (True) (False)) (True))
(rewrite (Xor (False) (False)) (False))


(rewrite (FullAddSum x y z) (Xor x (Xor y z)))
(rewrite (FullAddCarry a b c) (Or (And c (Xor a b)) (And a b)))
(rewrite (HalfAddSum x y) (Xor x y))
(rewrite (HalfAddCarry x y) (And x y))

(let s0 (HalfAddSum (Var "x0") (Var "y0")))
(let c0 (HalfAddCarry (Var "x0") (Var "y0")))

(let s1 (FullAddSum c0 (Var "x1") (Var "y1")))
(let c1 (FullAddCarry c0 (Var "x1") (Var "y1")))

(let s2 (FullAddSum c1 (Var "x2") (Var "y2")))
(let c2 (FullAddCarry c1 (Var "x2") (Var "y2")))

(let s3 (FullAddSum c2 (Var "x3") (Var "y3")))
(let c3 (FullAddCarry c2 (Var "x3") (Var "y3")))

(let s4 (FullAddSum c3 (Var "x4") (Var "y4")))
(let c4 (FullAddCarry c3 (Var "x4") (Var "y4")))

(let s5 (FullAddSum c4 (Var "x5") (Var "y5")))
(let c5 (FullAddCarry c4 (Var "x5") (Var "y5")))

(let s6 (FullAddSum c5 (Var "x6") (Var "y6")))
(let c6 (FullAddCarry c5 (Var "x6") (Var "y6")))

(let s7 (FullAddSum c6 (Var "x7") (Var "y7")))
(let c7 (FullAddCarry c6 (Var "x7") (Var "y7")))

(let s8 (FullAddSum c7 (Var "x8") (Var "y8")))
(let c8 (FullAddCarry c7 (Var "x8") (Var "y8")))

(let s9 (FullAddSum c8 (Var "x9") (Var "y9")))
(let c9 (FullAddCarry c8 (Var "x9") (Var "y9")))

(let s10 (FullAddSum c9 (Var "x10") (Var "y10")))
(let c10 (FullAddCarry c9 (Var "x10") (Var "y10")))

